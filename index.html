<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CHENBAOCHENG.COM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="CHENBAOCHENG.COM">
<meta property="og:url" content="http://www.chenbaocheng.com/">
<meta property="og:site_name" content="CHENBAOCHENG.COM">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CHENBAOCHENG.COM">
<meta name="twitter:description">

  
    <link rel="alternative" href="/atom.xml" title="CHENBAOCHENG.COM" type="application/atom+xml">
  
  
    <link rel="icon" href="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/webwxgeticon.jpeg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/webwxgeticon.jpeg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">CBC</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cbc009" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/chenbaocheng" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">CBC</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/webwxgeticon.jpeg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">CBC</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cbc009" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/chenbaocheng" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-JVM垃圾回收算法与回收器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/01/JVM垃圾回收算法与回收器/" class="article-date">
  	<time datetime="2015-07-01T08:29:30.000Z" itemprop="datePublished">7月 1 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/01/JVM垃圾回收算法与回收器/">JVM垃圾回收算法与回收器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="回收算法">回收算法</h4>
<h5 id="引用计数法_(Reference_Counting)">引用计数法 (Reference Counting)</h5>
<p>引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p>
<p>引用计数器的实现也非常简单，只需要为每个对象配置一个整形的计数器即可。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在 Java 的垃圾回收器中没有使用这种算法。</p>
<p>一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p>
<h5 id="标记-清除算法_(Mark-Sweep)">标记-清除算法 (Mark-Sweep)</h5>
<p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p>
<h5 id="复制算法_(Copying)">复制算法 (Copying)</h5>
<p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p>
<p>Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。</p>
<p>在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p>
<h5 id="标记-压缩算法_(Mark-Compact)">标记-压缩算法 (Mark-Compact)</h5>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。</p>
<p>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
<h5 id="增量算法_(Incremental_Collecting)">增量算法 (Incremental Collecting)</h5>
<p>在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p>
<p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h5 id="分代_(Generational_Collecting)">分代 (Generational Collecting)</h5>
<p>根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。在老生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</p>
<p>从不同角度分析垃圾收集器，可以将其分为不同的类型。</p>
<ol>
<li><p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的 CPU 上，使用并行垃圾回收器可以缩短 GC 的停顿时间。</p>
</li>
<li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器 (Stop the world) 一旦运行，就停止应用程序中的其他所有线程，直到垃圾回收过程完全结束。</p>
</li>
<li><p>按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。</p>
</li>
<li><p>按工作的内存区间，又可分为新生代垃圾回收器和老年代垃圾回收器。</p>
</li>
</ol>
<p><strong>可以用以下指标评价一个垃圾处理器的好坏。</strong></p>
<p><strong>吞吐量</strong>：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC 耗时。如果系统运行了 100min，GC 耗时 1min，那么系统的吞吐量就是 (100-1)/100=99%。</p>
<p>垃圾回收器负载：和吞吐量相反，垃圾回收器负载指来记回收器耗时与系统运行总时间的比值。</p>
<p><strong>停顿时间</strong>：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。</p>
<p><strong>垃圾回收频率</strong>：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。</p>
<p><strong>反应时间</strong>：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。</p>
<p><strong>堆分配</strong>：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾收集器应该有一个合理的堆内存区间划分。</p>
<h4 id="JVM_垃圾回收器分类">JVM 垃圾回收器分类</h4>
<h5 id="新生代串行收集器">新生代串行收集器</h5>
<p>串行收集器主要有两个特点：第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。</p>
<p>在串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行收集器却是一个成熟、经过长时间生产环境考验的极为高效的收集器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。</p>
<h5 id="老年代串行收集器">老年代串行收集器</h5>
<p>老年代串行收集器使用的是标记-压缩算法。和新生代串行收集器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会使用比新生代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。虽然如此，老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。若要启用老年代串行回收器，可以尝试使用以下参数：-XX:+UseSerialGC: 新生代、老年代都使用串行回收器。</p>
<p>如果使用-XX:+UseParNewGC 参数设置，表示新生代使用并行收集器，老年代使用串行收集器。</p>
<p>如果使用-XX:+UseParallelGC 参数设置，表示新生代和老年代均使用并行回收收集器。</p>
<h5 id="并行收集器">并行收集器</h5>
<p>并行收集器是工作在新生代的垃圾收集器，它只简单地将串行回收器多线程化。它的回收策略、算法以及参数和串行回收器一样。</p>
<p>并行回收器也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。</p>
<p>开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代使用串行收集器。</p>
<p>设置参数-XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用 CMS。</p>
<p>并行收集器工作时的线程数量可以使用-XX:ParallelGCThreads 参数指定。一般，最好与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量，大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU_Count]/8]。</p>
<h5 id="新生代并行回收_(Parallel_Scavenge)_收集器">新生代并行回收 (Parallel Scavenge) 收集器</h5>
<p>新生代并行回收收集器也是使用复制算法的收集器。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。</p>
<p>新生代并行回收收集器可以使用以下参数启用：</p>
<p>-XX:+UseParallelGC:新生代使用并行回收收集器，老年代使用串行收集器。</p>
<p>-XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器。</p>
<p>新生代并行回收收集器可以使用以下参数启用：</p>
<p>-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间，它的值是一个大于 0 的整数。收集器在工作时会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。如果希望减少停顿时间，而把这个值设置得很小，为了达到预期的停顿时间，JVM 可能会使用一个较小的堆 (一个小堆比一个大堆回收快)，而这将导致垃圾回收变得很频繁，从而增加了垃圾回收总时间，降低了吞吐量。</p>
<p>-XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。比如 GCTimeRatio 等于 19，则系统用于垃圾收集的时间不超过 1/(1+19)=5%。默认情况下，它的取值是 99，即不超过 1%的时间用于垃圾收集。</p>
<p>除此之外，并行回收收集器与并行收集器另一个不同之处在于，它支持一种自适应的 GC 调节策略，使用-XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。</p>
<h5 id="老年代并行回收收集器">老年代并行回收收集器</h5>
<p>老年代的并行回收收集器也是一种多线程并发的收集器。和新生代并行回收收集器一样，它也是一种关注吞吐量的收集器。老年代并行回收收集器使用标记-压缩算法，JDK1.6 之后开始启用。</p>
<p>使用-XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收收集器，这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用。参数-XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。</p>
<h5 id="CMS_收集器">CMS 收集器</h5>
<p>与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。</p>
<p>CMS 工作时，主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。</p>
<p>根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象；并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。</p>
<p>CMS 收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，但是由于它和应用程序线程并发执行，相互抢占 CPU，所以在 CMS 执行期内对应用程序吞吐量造成一定影响。CMS 默认启动的线程数是 (ParallelGCThreads+3)/4),ParallelGCThreads 是新生代并行收集器的线程数，也可以通过-XX:ParallelCMSThreads 参数手工设定 CMS 的线程数量。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
<p>由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</p>
<p>这个回收阈值可以使用-XX:CMSInitiatingOccupancyFraction 来指定，默认是 68。即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，已经出现了内存不足的情况，此时，CMS 回收将会失败，JVM 将启动老年代串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾收集完成，这时，应用程序的停顿时间可能很长。因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction 进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</p>
<p>标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。</p>
<p>-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p>
<h5 id="G1_收集器_(Garbage_First)">G1 收集器 (Garbage First)</h5>
<p>G1 收集器的目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。</p>
<p>与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。</p>
<h5 id="GC_相关参数总结">GC 相关参数总结</h5>
<ol>
<li>与串行回收器相关的参数</li>
</ol>
<p>-XX:+UseSerialGC:在新生代和老年代使用串行回收器。</p>
<p>-XX:+SuivivorRatio:设置 eden 区大小和 survivor 区大小的比例。</p>
<p>-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。</p>
<p>-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</p>
<p>2.与并行 GC 相关的参数</p>
<p>-XX:+UseParNewGC: 在新生代使用并行收集器。</p>
<p>-XX:+UseParallelOldGC: 老年代使用并行回收收集器。</p>
<p>-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。</p>
<p>-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。</p>
<p>-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。</p>
<p>-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
<p>3.与 CMS 回收器相关的参数</p>
<p>-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。</p>
<p>-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。</p>
<p>-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。</p>
<p>-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。</p>
<p>-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。</p>
<p>-XX:+CMSParallelRemarkEndable:启用并行重标记。</p>
<p>-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。</p>
<p>-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。</p>
<p>-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。</p>
<p>4.与 G1 回收器相关的参数</p>
<p>-XX:+UseG1GC：使用 G1 回收器。</p>
<p>-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。</p>
<p>-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。</p>
<p>-XX:+GCPauseIntervalMills:设置停顿间隔时间。</p>
<p>5.其他参数</p>
<p>-XX:+DisableExplicitGC: 禁用显示 GC。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java 8元空间(Metaspace)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/Java 8元空间(Metaspace)/" class="article-date">
  	<time datetime="2015-06-30T07:30:29.000Z" itemprop="datePublished">6月 30 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/Java 8元空间(Metaspace)/">Java 8元空间(Metaspace)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="元空间（Metaspace）：">元空间（Metaspace）：</h4>
<p>相信许多Java开发者都见过“java.lang.OutOfMemoryError: PermGen space”问题，这通常是类加载器相关的内存泄漏以及新类加载器的创建导致的，一般出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，通常“问题”是默认值太低了, 常用的解决方法是将其设置为256MB或更高。</p>
<p>PermGen space的全称是Permanent Generation space,是指JVM永久保存区域，这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。JVM 种类有很多(如Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM）。Oracle-Sun Hotspot才有PermGen space，JRockit以及J9没有这个区域。</p>
<p>随着JAVA8时代的来临,新增一种使用本地内存来存储类元数据信息称之为元空间(Metaspace)，JVM永久区被元空间(Metaspace)替换(JEP 122), 与Oracle JRockit 和IBM JVM’s很相似。JVM参数 -XX:PermSize 和 -XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替，如果使用了-XX:PermSize 和 -XX:MaxPermSize启动时会发出警告。。 这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/06/30/Java 8元空间(Metaspace)/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-JVM内存管理与垃圾回收" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/26/JVM内存管理与垃圾回收/" class="article-date">
  	<time datetime="2015-06-26T03:53:26.000Z" itemprop="datePublished">6月 26 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/26/JVM内存管理与垃圾回收/">JVM内存管理与垃圾回收</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">


      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/06/26/JVM内存管理与垃圾回收/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Java设计模式(一)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/24/Java设计模式(一)/" class="article-date">
  	<time datetime="2015-06-24T07:13:11.000Z" itemprop="datePublished">6月 24 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/24/Java设计模式(一)/">Java设计模式(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/06/24/Java设计模式(一)/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-RabbitMQ基本应用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/16/RabbitMQ基本应用/" class="article-date">
  	<time datetime="2015-06-16T08:05:42.000Z" itemprop="datePublished">6月 16 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/16/RabbitMQ基本应用/">RabbitMQ基本应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/06/16/RabbitMQ基本应用/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-JVM性能监控工具" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/15/JVM性能监控工具/" class="article-date">
  	<time datetime="2015-06-15T07:50:07.000Z" itemprop="datePublished">6月 15 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/JVM性能监控工具/">JVM性能监控工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/06/15/JVM性能监控工具/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Mac-OS-X下使用-Charles-进行抓包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/15/Mac-OS-X下使用-Charles-进行抓包/" class="article-date">
  	<time datetime="2015-06-15T07:14:12.000Z" itemprop="datePublished">6月 15 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/Mac-OS-X下使用-Charles-进行抓包/">Mac OS X下使用 Charles 进行抓包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">http://www.charlesproxy.com/</a></p>
<h4 id="2、启动_Charles，支持正版，如需破解请自行搜索">2、启动 Charles，支持正版，如需破解请自行搜索</h4>
<h4 id="3、手机设置代理,_以_iPhone_为例">3、手机设置代理, 以 iPhone 为例</h4>
<p>设置-无线局域网-选择已连接的局域网-HTTP代理-手动，服务器：你电脑的 IP，端口：8888</p>
<p>第一次用手机请求网络时，Charles会提示是否允许接入，选择Allow就可以了。</p>
<p>如果是 HTTPS 抓包，需要安装证书，证书地址：<a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-MacOS环境使用wireshark抓包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/07/MacOS环境使用wireshark抓包/" class="article-date">
  	<time datetime="2015-05-07T04:17:31.000Z" itemprop="datePublished">5月 7 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/07/MacOS环境使用wireshark抓包/">MacOS环境使用wireshark抓包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/05/07/MacOS环境使用wireshark抓包/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Docker学习-四-Dockerfile" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/05/Docker学习-四-Dockerfile/" class="article-date">
  	<time datetime="2015-05-05T07:37:57.000Z" itemprop="datePublished">5月 5 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/Docker学习-四-Dockerfile/">Docker学习(四) Dockerfile</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/docker/">docker</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/05/05/Docker学习-四-Dockerfile/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Docker学习-三-Docker镜像和容器的常用操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/" class="article-date">
  	<time datetime="2015-04-30T08:06:29.000Z" itemprop="datePublished">4月 30 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/">Docker学习(三) Docker镜像和容器的常用操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/docker/">docker</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 CBC
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>

<script src="/js/main.js" type="text/javascript"></script>







<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>
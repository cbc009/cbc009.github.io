<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CHENBAOCHENG.COM]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.chenbaocheng.com/"/>
  <updated>2015-04-30T05:30:23.152Z</updated>
  <id>http://www.chenbaocheng.com/</id>
  
  <author>
    <name><![CDATA[CBC]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux开机获取IP发送到指定邮箱]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Linux%E5%BC%80%E6%9C%BA%E8%8E%B7%E5%8F%96IP%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Linux开机获取IP发送到指定邮箱/</id>
    <published>2015-04-30T05:20:19.000Z</published>
    <updated>2015-04-30T05:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br><a id="more"></a><br>2、修改配置文件</p>
<p>vim  /etc/mail.rc</p>
<p>添加如下内容：<br>set from=xxxxxx@163.com smtp=smtp.163.com smtp-auth-user={username} smtp-auth-password={password} smtp-auth=login</p>
<p>3、配置开机发邮件</p>
<p>vim /etc/rc.local</p>
<p>ifconfig | mail -s “重启开机邮件 - 最新 IP” xxxx@xxxx.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br>]]>
    
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 github 开源了一个spring-boot-jpa DEMO]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/29/%E5%9C%A8-github-%E5%BC%80%E6%BA%90%E4%BA%86%E4%B8%80%E4%B8%AAspring-boot-jpa-DEMO/"/>
    <id>http://www.chenbaocheng.com/2015/04/29/在-github-开源了一个spring-boot-jpa-DEMO/</id>
    <published>2015-04-29T08:58:12.000Z</published>
    <updated>2015-04-29T09:04:32.000Z</updated>
    <content type="html"><![CDATA[<p>在 github 开源了一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entity，声明 Dao，在 Service 层包装一下业务, controller 里去做 WEB 页面展示的准备工作就好了。</p>
<p>这个DEMO主要演示基于 spring boot 的项目开发，如何使用 jpa 对数据库 CRUD 操作，如何用 freemarker 展示页面。</p>
<p>项目地址：<a href="https://github.com/cbc009/spring-boot-jpa" target="_blank" rel="external">spring-boot-jpa DEMO</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 github 开源了一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Ent]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java : Unsupported major.minor version 51.0解决方法]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/"/>
    <id>http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/</id>
    <published>2015-04-23T06:44:35.000Z</published>
    <updated>2015-04-28T03:53:43.000Z</updated>
    <content type="html"><![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
<a id="more"></a>

<p>51.0是对应JDK1.7, 看一下当前的 java 版本什么呢？<br>$ java -version<br>java version “1.7.0_79”<br>Java(TM) SE Runtime Environment (build 1.7.0_79-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</p>
<p>看起来JDK没问题。</p>
<p>那会不会是 intellij 默认用1.6启动的呢？<br>$ vim /Applications/IntelliJ\ IDEA\ 14.app/Contents/Info.plist</p>
<p>100、101行：<br>      <key>JVMVersion</key><br>      <string>1.6,1.7<em></em></string><br>看起来像是这里的问题，修改一下，把1.6去掉试试:<br>      <key>JVMVersion</key><br>      <string>1.7</string></p>
<p>保存，重新启动Intellij Idea, 出现提示:您要应用程序“Intellij Idea 14.app”接受传入网络连接吗?这是由于修改应用内文件导致Apple 签名失效了。简单粗暴解决一下，进入系统管理-关闭防火墙即可。</p>
<p>重新启动软件，一切正常了~~~ Intellij idea 为什么不默认使用系统 JDK 版本呢？或者给用户一个修改 JDK 版本的界面？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[oh-my-zsh替代品prezto]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/02/oh-my-zsh%E6%9B%BF%E4%BB%A3%E5%93%81prezto/"/>
    <id>http://www.chenbaocheng.com/2015/04/02/oh-my-zsh替代品prezto/</id>
    <published>2015-04-02T07:46:44.000Z</published>
    <updated>2015-04-02T10:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre><a id="more"></a>

<p><br>3、创建Zsh配置文件</p>
<pre><code>setopt EXTENDED_GLOB
 <span class="keyword">for</span> rcfile <span class="keyword">in</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>"</span>/.zprezto/runcoms/^README.md(.N); <span class="keyword">do</span>
   ln <span class="operator">-s</span> <span class="string">"<span class="variable">$rcfile</span>"</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.<span class="variable">${rcfile:t}</span>"</span>
 <span class="keyword">done</span>
</code></pre><p><br>4、设置 Zsh 为默认shell</p>
<pre><code>chsh <span class="operator">-s</span> /bin/zsh
</code></pre><p><br>5、新开窗口体验~~~</p>
<h6 id="关于更新"><br>关于更新</h6>
<pre><code><span class="keyword">cd</span>  ~/.zprezto
git pull &amp;&amp; git submodule <span class="keyword">update</span> --init --recursive
</code></pre><h6 id="oh-my-zsh的_z_命令替代品_fasd"><br>oh-my-zsh的 z 命令替代品 fasd</h6>
<pre><code>brew install fasd

<span class="keyword">vim</span> ~/.zshrc
<span class="built_in">eval</span> <span class="string">"$(fasd --init auto)"</span>

<span class="keyword">vim</span>  ~/.zpreztorc
zstyle <span class="string">':prezto:load'</span> pmodule \
    <span class="string">'environment'</span> \
    <span class="string">'terminal'</span> \
    <span class="string">'editor'</span> \
    <span class="string">'history'</span> \
    <span class="string">'directory'</span> \
    <span class="string">'spectrum'</span> \
    <span class="string">'utility'</span> \
    <span class="string">'completion'</span> \
    <span class="string">'history'</span> \
    <span class="string">'history-substring-search'</span> \
    <span class="string">'prompt'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre>]]>
    
    </summary>
    
      <category term="效率" scheme="http://www.chenbaocheng.com/categories/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS网络诊断命令]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/26/MacOS%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.chenbaocheng.com/2015/02/26/MacOS网络诊断命令/</id>
    <published>2015-02-26T06:54:18.000Z</published>
    <updated>2015-04-28T03:55:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活动网卡</span>
ifconfig

<span class="preprocessor">#查看所有网卡信息，包括活动、非活动网卡</span>
ifconfig -a

<span class="preprocessor">#查看某个网卡的信息</span>
ifconfig eth0

<span class="preprocessor">#配置某个网卡的ip地址 格式：ifconfig  ethx IP/MASK</span>
ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.20</span>/<span class="number">16</span>
</code></pre><h3 id="路由">路由</h3>
<pre><code><span class="preprocessor">#显示路由表</span>
netstat -nr

<span class="preprocessor">#追踪到达IP目的地的全程路由</span>
traceroute nis.nsf.net
</code></pre><h3 id="网络监听_-_tcpdump">网络监听 - tcpdump</h3>
<pre><code><span class="built_in">sudo</span> tcpdump -i en0

监听en0接口的所有通信

<span class="built_in">sudo</span> tcpdump -A -i en0 

用ASCII显示en0接口的通信内容
<span class="built_in">sudo</span> tcpdump -i en0 <span class="string">'port 8080'</span>

显示en0接口的<span class="number">8080</span>端口的通信

<span class="built_in">sudo</span> tcpdump -i eth1 src <span class="number">192.168</span>.<span class="number">1.200</span>

显示eth1接口，来自<span class="number">192.168</span>.<span class="number">1.200</span>的通信

<span class="built_in">sudo</span> tcpdump -i eth1 dst <span class="number">192.168</span>.<span class="number">1.101</span> and port <span class="number">80</span>

显示eth1接口<span class="number">80</span>端口，目的地为<span class="number">192.168</span>.<span class="number">1.101</span>的通信

<span class="built_in">sudo</span> tcpdump -w record.pcap -i lo0

将lo0接口的通信存入文件record.pcap
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活]]>
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS管理多个JDK版本]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/23/Mac-OS%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAJDK%E7%89%88%E6%9C%AC/"/>
    <id>http://www.chenbaocheng.com/2015/02/23/Mac-OS管理多个JDK版本/</id>
    <published>2015-02-22T18:36:02.000Z</published>
    <updated>2015-02-22T21:01:19.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre><a id="more"></a>

<h5 id="配置">配置</h5>
<pre><code>jenv <span class="keyword">add</span> /System/<span class="keyword">Library</span>/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">7.0</span>_60.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">8.0</span>_05.jdk/Contents/Home/
 jenv enable-plugin export
</code></pre><h5 id="使用">使用</h5>
<pre><code><span class="comment">'显示全部版本</span>
 jenv versions 

 <span class="comment">' 设置默认版本</span>
 jenv <span class="keyword">global</span> oracle64-<span class="number">1.6</span><span class="number">.0</span><span class="number">.65</span>

 <span class="comment">' 设置目录对应的JDK版本。在目录下创建.java-version文件记录版本号</span>
 jenv local <span class="number">1.8</span>

 <span class="comment">' 撤销上一步操作</span>
 jenv local --unset
</code></pre><h5 id="插件">插件</h5>
<pre><code>jenv plugins

 ant
 <span class="keyword">export</span>
 golo
 gradle
 grails
 groovy
 lein
 maven
 sbt
 scala
 springboot
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[50道Java线程面试题]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/22/50%E9%81%93Java%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.chenbaocheng.com/2015/02/22/50道Java线程面试题/</id>
    <published>2015-02-22T14:16:07.000Z</published>
    <updated>2015-02-22T17:35:31.000Z</updated>
    <content type="html"><![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
<a id="more"></a>

<h5 id="4)_用Runnable还是Thread？">4) 用Runnable还是Thread？</h5>
<p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。<a href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="6)_Thread_类中的start()_和_run()_方法有什么区别？">6) Thread 类中的start() 和 run() 方法有什么区别？</h5>
<p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。<a href="http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html" target="_blank" rel="external">更多讨论</a></p>
<h5 id="7)_Java中Runnable和Callable有什么不同？">7) Java中Runnable和Callable有什么不同？</h5>
<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h5 id="8)_Java中CyclicBarrier_和_CountDownLatch有什么不同？">8) Java中CyclicBarrier 和 CountDownLatch有什么不同？</h5>
<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。<a href="http://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html" target="_blank" rel="external">点此查看更多信息和示例代码</a>。</p>
<h5 id="9)_Java内存模型是什么？">9) Java内存模型是什么？</h5>
<p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>可传递性<br>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
<h5 id="10)_Java中的volatile_变量是什么？">10) Java中的volatile 变量是什么？</h5>
<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。<a href="http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html" target="_blank" rel="external">查看更多volatile的相关内容</a>。</p>
<h5 id="11)_什么是线程安全？Vector是一个线程安全类吗？_（详见这里)">11) 什么是线程安全？Vector是一个线程安全类吗？ （详见这里)</h5>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h5 id="12)_Java中什么是竞态条件？_举个例子说明。">12) Java中什么是竞态条件？ 举个例子说明。</h5>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，<a href="http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html" target="_blank" rel="external">详见答案</a>。</p>
<h5 id="13)_Java中如何停止一个线程？">13) Java中如何停止一个线程？</h5>
<p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。<a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="external">查看示例代码</a>。</p>
<h5 id="14)_一个线程运行时发生异常会怎样？">14) 一个线程运行时发生异常会怎样？</h5>
<p>这是我在一次面试中遇到的一个<a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="external">很刁钻的Java面试题</a>, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h5 id="15）_如何在两个线程间共享数据？">15） 如何在两个线程间共享数据？</h5>
<p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《<a href="http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html" target="_blank" rel="external">Java线程间通信</a>》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<h5 id="16)_Java中notify_和_notifyAll有什么区别？">16) Java中notify 和 notifyAll有什么区别？</h5>
<p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。<a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="external">更详细的资料和示例代码</a>。</p>
<h5 id="17)_为什么wait,_notify_和_notifyAll这些方法不在thread类里面？">17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h5>
<p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以<a href="http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html" target="_blank" rel="external">查看这篇文章</a>了解更多。</p>
<h5 id="18)_什么是ThreadLocal变量？">18) 什么是ThreadLocal变量？</h5>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。<a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="external">查看答案</a>了解更多。</p>
<h5 id="19)_什么是FutureTask？">19) 什么是FutureTask？</h5>
<p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h5 id="20)_Java中interrupted_和_isInterruptedd方法的区别？">20) Java中interrupted 和 isInterruptedd方法的区别？</h5>
<p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="external">静态方法</a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h5 id="21)_为什么wait和notify方法要在同步块中调用？">21) 为什么wait和notify方法要在同步块中调用？</h5>
<p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h5 id="22)_为什么你应该在循环中检查等待条件?">22) 为什么你应该在循环中检查等待条件?</h5>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h5 id="23)_Java中的同步集合与并发集合有什么区别？">23) Java中的同步集合与并发集合有什么区别？</h5>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见<a href="http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="24）_Java中堆和栈有什么不同？">24） Java中堆和栈有什么不同？</h5>
<p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。<br>更多内容详见<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="25）_什么是线程池？_为什么要使用它？">25） 什么是线程池？ 为什么要使用它？</h5>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">更多详细内容</a>。</p>
<h5 id="26）_如何写代码来解决生产者消费者问题？">26） 如何写代码来解决生产者消费者问题？</h5>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它<a href="http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="27）_如何避免死锁？">27） 如何避免死锁？</h5>
<p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节<a href="http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="28)_Java中活锁和死锁有什么区别？">28) Java中活锁和死锁有什么区别？</h5>
<p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h5 id="29）_怎么检测一个线程是否拥有锁？">29） 怎么检测一个线程是否拥有锁？</h5>
<p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多，<a href="http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="30)_你如何在Java中获取线程堆栈？">30) 你如何在Java中获取线程堆栈？</h5>
<p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h5 id="31)_JVM中哪个参数是用来控制线程的栈堆栈小的">31) JVM中哪个参数是用来控制线程的栈堆栈小的</h5>
<p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看<a href="http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html" target="_blank" rel="external">JVM配置列表</a>来了解这个参数的更多信息。</p>
<h5 id="32）_Java中synchronized_和_ReentrantLock_有什么不同？">32） Java中synchronized 和 ReentrantLock 有什么不同？</h5>
<p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。<a href="http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html" target="_blank" rel="external">查看这篇文章了解更多</a></p>
<h5 id="33）_有三个线程T1，T2，T3，怎么确保它们按顺序执行？">33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h5>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。<a href="http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html" target="_blank" rel="external">查看这篇文章了解更多</a>。</p>
<h5 id="34)_Thread类中的yield方法有什么作用？">34) Thread类中的yield方法有什么作用？</h5>
<p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。<a href="http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html" target="_blank" rel="external">查看更多yield方法的相关内容</a>。</p>
<h5 id="35）_Java中ConcurrentHashMap的并发度是什么？">35） Java中ConcurrentHashMap的并发度是什么？</h5>
<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章<a href="http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html" target="_blank" rel="external">How ConcurrentHashMap works in Java</a>。</p>
<h5 id="36）_Java中Semaphore是什么？">36） Java中Semaphore是什么？</h5>
<p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。<a href="http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="37）如果你提交任务时，线程池队列已满。会时发会生什么？">37）如果你提交任务时，线程池队列已满。会时发会生什么？</h5>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h5 id="38)_Java线程池中submit()_和_execute()方法有什么区别？">38) Java线程池中submit() 和 execute()方法有什么区别？</h5>
<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。<a href="http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="39)_什么是阻塞式方法？">39) 什么是阻塞式方法？</h5>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。<a href="http://javarevisited.blogspot.sg/2012/02/what-is-blocking-methods-in-java-and.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="40)_Swing是线程安全的吗？_为什么？">40) Swing是线程安全的吗？ 为什么？</h5>
<p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。<a href="http://javarevisited.blogspot.com/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html" target="_blank" rel="external">查看更多swing和线程安全的相关内容</a>。</p>
<h5 id="41）_Java中invokeAndWait_和_invokeLater有什么区别？">41） Java中invokeAndWait 和 invokeLater有什么区别？</h5>
<p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。<a href="http://javarevisited.blogspot.com/2011/09/invokeandwait-invokelater-swing-example.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="42)_Swing_API中那些方法是线程安全的？">42) Swing API中那些方法是线程安全的？</h5>
<p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h5 id="43)_如何在Java中创建Immutable对象？">43) 如何在Java中创建Immutable对象？</h5>
<p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章<a href="http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" target="_blank" rel="external">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p>
<h5 id="44）_Java中的ReadWriteLock是什么？">44） Java中的ReadWriteLock是什么？</h5>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h5 id="45)_多线程中的忙循环是什么?">45) 多线程中的忙循环是什么?</h5>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。<a href="http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html" target="_blank" rel="external">你可以查看这篇文章获得更多信息</a>。</p>
<h5 id="46）volatile_变量和_atomic_变量有什么不同？">46）volatile 变量和 atomic 变量有什么不同？</h5>
<p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h5 id="47)_如果同步块内的线程抛出异常会发生什么？">47) 如果同步块内的线程抛出异常会发生什么？</h5>
<p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="external">finally block</a>里释放锁实现。</p>
<h5 id="48）_单例模式的双检锁是什么？">48） 单例模式的双检锁是什么？</h5>
<p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看<a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">how double checked locking on Singleton works</a>这篇文章获得更多信息。</p>
<h5 id="49）_如何在Java中创建线程安全的Singleton？">49） 如何在Java中创建线程安全的Singleton？</h5>
<p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。<a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="50)_写出3条你遵循的多线程最佳实践">50) 写出3条你遵循的多线程最佳实践</h5>
<p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。<br>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明, <a href="http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="51)_如何强制启动一个线程？">51) 如何强制启动一个线程？</h5>
<p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h5 id="52)_Java中的fork_join框架是什么？">52) Java中的fork join框架是什么？</h5>
<p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。<a href="http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="53）_Java多线程中调用wait()_和_sleep()方法有什么不同？">53） Java多线程中调用wait() 和 sleep()方法有什么不同？</h5>
<p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<a href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<p>以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC OS批量删除文件－删除文件夹下的所有.svn目录]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/22/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89-svn%E7%9B%AE%E5%BD%95/"/>
    <id>http://www.chenbaocheng.com/2015/02/22/删除文件夹下的所有-svn目录/</id>
    <published>2015-02-22T13:25:11.000Z</published>
    <updated>2015-02-22T17:37:29.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">".svn"</span> | xargs rm -fr</div></pre></td></tr></table></figure>

<p><br>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -type d -name <span class="string">".svn"</span> | xargs rm -rf</div></pre></td></tr></table></figure>

<p>xargs它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题</p>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">".svn"</span> -exec rm -fr <span class="string">'{}'</span> +</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">]]>
    </summary>
    
      <category term="os" scheme="http://www.chenbaocheng.com/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言学习 - 配置开发环境(IntelliJ IDEA 14 For Mac OS 10.10)]]></title>
    <link href="http://www.chenbaocheng.com/2015/01/23/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IntelliJ-IDEA-14-For-Mac-OS-10-10/"/>
    <id>http://www.chenbaocheng.com/2015/01/23/Go语言学习-配置开发环境-IntelliJ-IDEA-14-For-Mac-OS-10-10/</id>
    <published>2015-01-23T05:11:31.000Z</published>
    <updated>2015-02-22T17:37:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong>1、安装 Go-Lang</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew install go</div><div class="line">$ go version</div></pre></td></tr></table></figure>

<p><br><strong>2、配置环境变量</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ vim ~/.zshrc</div><div class="line"><span class="keyword">export</span> GOROOT=/usr/local/opt/go/libexec</div><div class="line"><span class="keyword">export</span> GOPATH=<span class="variable">$HOME</span>/.go</div></pre></td></tr></table></figure>

<p><br><strong>3、Intellij IDEA 安装 go-lang-idea-plugin</strong></p>
<ul>
<li>IntelliJ IDEA -&gt; Preferences -&gt; Plugins -&gt; Browse Repositories</li>
<li>搜索golang，点击 “Install plugin”</li>
<li>安装完重启</li>
</ul>
<p><strong>go-lang-idea-plugin会提示配置GOROOT,GOPATH。。。搜了各种资料，需要这样配置一下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim .zshrc</div><div class="line">launchctl setenv GOROOT /usr/local/opt/go/libexec</div><div class="line">launchctl setenv GOBIN /usr/local/opt/go/libexec/bin</div><div class="line">launchctl setenv GOPATH /ROOT/www/go</div></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、安装 Go-Lang</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="li]]>
    </summary>
    
      <category term="golang" scheme="http://www.chenbaocheng.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo写博客 --- Hexo的配置与使用]]></title>
    <link href="http://www.chenbaocheng.com/2015/01/09/%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%20---%20Hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/01/09/用Hexo写博客 --- Hexo的配置与使用/</id>
    <published>2015-01-09T07:20:45.000Z</published>
    <updated>2015-02-22T18:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>本站由 SourceForge 迁移到 GitHub.</p>
<p>之前是在 SourceForge 提供的空间搭了一个 Wordpress, 访问很慢。</p>
<pre><code>Hexo is <span class="operator">a</span> fast, simple &amp; powerful blog framework powered <span class="keyword">by</span> Node.js.
</code></pre><p><br>Hexo 基于 Node.js 开发的一个轻量级的 Blog 框架，使用自然没有 Wordpress 那么方便，好在也是生成 HTML，访问会快些。</p>
<p><strong>搭建本站过程看的一些资料整理一下，逐步操作如下：</strong><br><a id="more"></a><br>1、Mac OS x 默认自带 git，无需重复安装</p>
<p>2、安装 Node.js </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure>

<p><em><br>进入本地存放博客的目录继续操作……</em></p>
<p>3、安装、初始化 Hexo</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#install hexo</span></div><div class="line">npm install -g hexo</div><div class="line"> </div><div class="line"><span class="comment">#init hexo</span></div><div class="line">hexo init ./</div><div class="line">npm install</div></pre></td></tr></table></figure>

<p><br>4、预览网站</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure><br>通过以上操作，一个基于 Hexo 搭建的网站就初步完成了，通过浏览器访问一下劳(piao)动(qie)成果：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br><br><strong>Hexo 的常用操作</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#初始化</span></div><div class="line">hexo init [folder]</div><div class="line"> </div><div class="line"><span class="comment">#新发一片page|post</span></div><div class="line">hexo new [layout] &lt;title&gt;</div><div class="line"> </div><div class="line"><span class="comment">#生成静态文件</span></div><div class="line">hexo generate</div><div class="line"> </div><div class="line"><span class="comment">#清理缓存 --- db.json、public/</span></div><div class="line">hexo clean</div><div class="line"> </div><div class="line"><span class="comment">#启动本地服务，默认端口4000</span></div><div class="line">hexo server</div><div class="line"> </div><div class="line"><span class="comment">#将public/下的文件部署到配置文件制定的服务器</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure><br>详细查看官方文档:<a href="http://hexo.io/docs/commands.html" target="_blank" rel="external">http://hexo.io/docs/commands.html</a><br><br>现在网站已经搭起来了，开始写点什么~<br><br>Hexo 里写文章是用Markdown，如果之前没有用过，建议看看这篇文章 : <a href="http://wowubuntu.com/markdown" target="_blank" rel="external">http://wowubuntu.com/markdown</a><br><br>现在已经了解 Markdown 是什么，那我们继续，<strong>开始用 Hexo 写文章</strong><br><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"Hello world !"</span></div><div class="line"><span class="comment">#会提示你输入dquote，请输入双引号 — ”</span></div><div class="line"><span class="comment">#如果你的文件名里没有特殊字符就不要加双引号了~~~</span></div></pre></td></tr></table></figure>

<p><br>用你喜欢的编辑用户打开 source/_posts/Hello-world.md，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: 标题</div><div class="line">date: 2015-01-09 17:42:00</div><div class="line">categories:</div><div class="line">tags:</div><div class="line">---</div><div class="line">文章正文，啦啦啦啦~</div></pre></td></tr></table></figure>

<p><br>更多编辑文章技能看官方文档：<a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">http://hexo.io/docs/writing.html</a></p>
<p>刷新浏览器，文章列表是不是发生变化了！</p>
<p><strong>如果需要发布到服务器</strong>，需要先生成一下静态文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line"><span class="comment">#hexo generate的简写</span></div></pre></td></tr></table></figure>

<p><br>生成的静态文件地址跟类型相关：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">生成目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post (Default)</td>
<td style="text-align:center">source/_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
</tbody>
</table>
<p><br>OK, 现在网站已经有，是不是迫不及待想发布到服务器让大家来访问了？！</p>
<p>首先，你得有一个 github.com 的账号，如果没有请先<a href="https://github.com/join" target="_blank" rel="external">去注册</a></p>
<p>1、新建一个your_user_name.github.com的仓库<br>2、添加SSH公钥.Account settings &gt; SSH Keys &gt; Add SSH Key<br>3、修改本地博客根目录下的 _config.yml，</p>
<pre><code>deploy:
      <span class="class"><span class="keyword">type</span>: <span class="title">github</span></span>
      repo: https:<span class="comment">//github.com/your_user_name/your_user_name.github.io.git</span>
</code></pre><p><br>4、执行 hexo d</p>
<p>如果想绑定域名，在仓库里新建一个CNAME,文件内容为你的域名，比如chenbaocheng.com,前面不要加http://</p>
<p>修改域名 DNS 信息：</p>
<p>1、增加CNAME记录：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">your_user_name.github.io</td>
</tr>
</tbody>
</table>
<p><br>2、增加 A 记录</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">192.30.252.153</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">192.30.252.154</td>
</tr>
</tbody>
</table>
<p><br>域名绑定参考官方文档：<a href="https://help.github.com/articles/my-custom-domain-isn-t-working/" target="_blank" rel="external">https://help.github.com/articles/my-custom-domain-isn-t-working/</a></p>
<p>—全文完—</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本站由 SourceForge 迁移到 GitHub.</p>
<p>之前是在 SourceForge 提供的空间搭了一个 Wordpress, 访问很慢。</p>
<pre><code>Hexo is <span class="operator">a</span> fast, simple &amp; powerful blog framework powered <span class="keyword">by</span> Node.js.
</code></pre><p><br>Hexo 基于 Node.js 开发的一个轻量级的 Blog 框架，使用自然没有 Wordpress 那么方便，好在也是生成 HTML，访问会快些。</p>
<p><strong>搭建本站过程看的一些资料整理一下，逐步操作如下：</strong><br>]]>
    
    </summary>
    
  </entry>
  
</feed>

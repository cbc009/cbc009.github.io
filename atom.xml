<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CHENBAOCHENG.COM]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.chenbaocheng.com/"/>
  <updated>2015-07-03T07:17:20.488Z</updated>
  <id>http://www.chenbaocheng.com/</id>
  
  <author>
    <name><![CDATA[CBC]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ZooKeeper配置与使用]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/03/ZooKeeper%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/07/03/ZooKeeper配置与使用/</id>
    <published>2015-07-03T06:16:00.000Z</published>
    <updated>2015-07-03T07:17:09.000Z</updated>
    <content type="html"><![CDATA[<p>ZooKeeper Server是一个Java语言实现的分布式协调服务框架，因此需要JDK6+的支持。为了确保ZooKeeper服务的稳定与可靠性，通常是搭建成一个ZK集群来对外提供服务。ZK有一个重要的特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的，所以建议集群的机器数量为奇数。</p>
<h4 id="1、安装JDK6+">1、安装JDK6+</h4>
<h4 id="2、去官网选择一个合适的版本下载。">2、去官网选择一个合适的版本下载。</h4>
<pre><code><span class="comment">#官网 http://www.apache.org/dyn/closer.cgi/zookeeper/</span>

wget <span class="symbol">http:</span>/<span class="regexp">/mirrors.cnnic.cn/apache</span><span class="regexp">/zookeeper/zookeeper</span>-<span class="number">3.4</span>.<span class="number">6</span>/zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
tar zxf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
cd zookeeper-<span class="number">3.4</span>.<span class="number">6</span>
</code></pre><a id="more"></a>

<h4 id="3、配置">3、配置</h4>
<pre><code>mv conf/zoo_sample.cfg  conf/zoo.cfg 

<span class="comment">#创建数据存储路径</span>
mkdir -p /ROOT/data/zookeeper/

<span class="comment">#修改dataDir</span>
vi conf/zoo.cfg

修改一下内容：
<span class="variable">tickTime=</span><span class="number">2000</span>
<span class="variable">dataDir=</span>/ROOT/data/zookeeper/ 
<span class="variable">clientPort=</span><span class="number">2181</span>
<span class="variable">initLimit=</span><span class="number">5</span>
<span class="variable">syncLimit=</span><span class="number">2</span>
server.<span class="number">1</span>=zk1:<span class="number">2888</span>:<span class="number">3888</span>
server.<span class="number">2</span>=zk2:<span class="number">2888</span>:<span class="number">3888</span>
server.<span class="number">3</span>=zk3:<span class="number">2888</span>:<span class="number">3888</span>
</code></pre><p><strong>server.id=host:port:port</strong> 关于id，我们称之为Server ID，用来标识该host在集群中的机器序号，id的取值范围是1~255。</p>
<p><strong>注意：集群中所有节点的配置文件必须保持一致</strong></p>
<h4 id="4、启动">4、启动</h4>
<pre><code>bin/zkServer.<span class="keyword">sh</span> start 
</code></pre><h4 id="5、检查是否安装成功">5、检查是否安装成功</h4>
<pre><code>bin/zkCli.<span class="keyword">sh</span> 
或
<span class="keyword">echo</span> stat|nc localhost <span class="number">2181</span>
</code></pre><h4 id="关于带GUI管理工具">关于带GUI管理工具</h4>
<ul>
<li><strong>TaoKeeper</strong></li>
</ul>
<p>淘宝开源的ZK监控与报表系统，看上去很久不更新的样子。如果自己下载源码进行编译，可能会出现依赖，需要手动安装JAR到本地maven库，使用不是特别方便。</p>
<ul>
<li><strong>Node_Zookeeper_Admin</strong></li>
</ul>
<p>用NodeJs开发，没用过，看界面还不错，由于需要安装nodejs环境，还是不试了。</p>
<h4 id="zoo-cfg文件参数详解">zoo.cfg文件参数详解</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>clientPort</td>
<td>客户端连接server的端口，即对外服务端口，一般设置为2181吧。</td>
</tr>
<tr>
<td>dataDir</td>
<td>存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。</td>
</tr>
<tr>
<td>tickTime</td>
<td>ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。</td>
</tr>
<tr>
<td>dataLogDir</td>
<td>事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能。（No Java system property）</td>
</tr>
<tr>
<td>globalOutstandingLimit</td>
<td>最大请求堆积数。默认是1000。ZK运行的时候， 尽管server已经没有空闲来处理更多的客户端请求了，但是还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。(Java system property:zookeeper.globalOutstandingLimit.)</td>
</tr>
<tr>
<td>preAllocSize</td>
<td>预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果ZK的快照频率较大的话，建议适当减小这个参数。(Java system property:zookeeper.preAllocSize)</td>
</tr>
<tr>
<td>snapCount</td>
<td>每进行snapCount次事务日志输出后，触发一次快照(snapshot), 此时，ZK会生成一个snapshot.<em>文件，同时创建一个新的事务日志文件log.</em>。默认是100000.（真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能）(Java system property:zookeeper.snapCount)</td>
</tr>
<tr>
<td>traceFile</td>
<td>用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java system property:?requestTraceFile)</td>
</tr>
<tr>
<td>maxClientCnxns</td>
<td>单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60（3.4.0开始，默认值调整为60，之前的默认值是10），如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台ZK服务器之间的连接数限制，不是针对指定客户端IP，也不是ZK集群的连接数限制，也不是单台ZK对所有客户端的连接数限制。指定客户端IP的限制策略，这里有一个patch，可以尝试一下：<a href="http://rdc.taobao.com/team/jm/archives/1334（No" target="_blank" rel="external">http://rdc.taobao.com/team/jm/archives/1334（No</a> Java system property）</td>
</tr>
<tr>
<td>clientPortAddress</td>
<td>对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听clientPort指定的端口。New in 3.3.0</td>
</tr>
<tr>
<td>minSessionTimeoutmaxSessionTimeout</td>
<td>Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2 <em> tickTime ~ 20 </em> tickTime这个范围 New in 3.3.0</td>
</tr>
<tr>
<td>fsync.warningthresholdms</td>
<td>事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。(Java system property:fsync.warningthresholdms) New in 3.3.4</td>
</tr>
<tr>
<td>autopurge.purgeInterval</td>
<td>在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>autopurge.snapRetainCount</td>
<td>这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>electionAlg</td>
<td>在之前的版本中， 这个参数配置是允许我们选择leader选举算法，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property)</td>
</tr>
<tr>
<td>initLimit</td>
<td>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property)</td>
</tr>
<tr>
<td>syncLimit</td>
<td>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property)</td>
</tr>
<tr>
<td>leaderServes</td>
<td>默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper.leaderServes)。</td>
</tr>
<tr>
<td>server.x=[hostname]:nnnnn[:nnnnn]</td>
<td>这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。(No Java system property)</td>
</tr>
<tr>
<td>group.x=nnnnn[:nnnnn]weight.x=nnnnn</td>
<td>对机器分组和权重设置，可以 <a href="http://zookeeper.apache.org/doc/r3.4.3/zookeeperHierarchicalQuorums.html" target="_blank" rel="external">参见这里</a>(No Java system property)</td>
</tr>
<tr>
<td>cnxTimeout</td>
<td>Leader选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper.cnxTimeout)</td>
</tr>
<tr>
<td>zookeeper.DigestAuthenticationProvider.superDigest</td>
<td>ZK权限设置相关，具体参见<a href="http://nileader.blog.51cto.com/1381108/930635" target="_blank" rel="external">《使用super身份对有权限的节点进行操作》</a> 和 <a href="http://nileader.blog.51cto.com/1381108/795525" target="_blank" rel="external">《ZooKeeper权限控制》</a></td>
</tr>
<tr>
<td>skipACL</td>
<td>对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property:zookeeper.skipACL)</td>
</tr>
<tr>
<td>forceSync</td>
<td>这个参数确定了是否需要在事务日志提交的时候调用FileChannel.force来保证数据完全同步到磁盘。(Java system property:zookeeper.forceSync)</td>
</tr>
<tr>
<td>jute.maxbuffer</td>
<td>每个节点最大数据量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property:jute.maxbuffer)</td>
</tr>
</tbody>
</table>
<h4 id="常用命令">常用命令</h4>
<p><strong>conf</strong></p>
<pre><code><span class="comment"># 输出server的详细配置信息</span>
$ <span class="built_in">echo</span> conf|nc localhost <span class="number">2181</span>
</code></pre><p><strong>cons</strong> </p>
<pre><code><span class="comment">#输出指定server上所有客户端连接的详细信息，包括客户端IP，会话ID等</span>
$ <span class="built_in">echo</span> cons|nc localhost <span class="number">2181</span>
</code></pre><p><strong>crst</strong></p>
<pre><code><span class="preprocessor">#功能性命令。重置所有连接的统计信息。</span>
</code></pre><p><strong>dump</strong></p>
<pre><code><span class="preprocessor">#这个命令针对Leader执行，用于输出所有等待队列中的会话和临时节点的信息。 </span>
</code></pre><p><strong>envi</strong></p>
<pre><code><span class="preprocessor">#用于输出server的环境变量。包括操作系统环境和Java环境。</span>
</code></pre><p><strong>ruok</strong></p>
<pre><code><span class="preprocessor">#用于测试server是否处于无错状态。如果正常，则返回“imok”,否则没有任何响应。</span>

注意：
ruok不是一个特别有用的命令，它不能反映一个server是否处于正常工作。“stat”命令更靠谱。
</code></pre><p><strong>stat</strong></p>
<pre><code><span class="preprocessor">#输出server简要状态和连接的客户端信息。</span>
</code></pre><p><strong>srvr</strong></p>
<pre><code><span class="comment">#和stat类似</span>

$ <span class="built_in">echo</span> stat|nc localhost <span class="number">2181</span>

$ <span class="built_in">echo</span> srvr|nc localhost <span class="number">2181</span>
</code></pre><p><strong>srst</strong></p>
<pre><code><span class="preprocessor">#重置server的统计信息。</span>
</code></pre><p><strong>wchs</strong></p>
<pre><code><span class="preprocessor">#列出所有watcher信息概要信息，数量等。</span>
</code></pre><p><strong>wchc</strong></p>
<pre><code><span class="comment">#列出所有watcher信息，以watcher的session为归组单元排列，列出该会话订阅了哪些path</span>

$ <span class="built_in">echo</span> wchc|nc localhost <span class="number">2181</span>
</code></pre><p><strong>wchp</strong></p>
<pre><code><span class="comment">#列出所有watcher信息，以watcher的path为归组单元排列，列出该path被哪些会话订阅着</span>

$ <span class="built_in">echo</span> wchp|nc localhost <span class="number">2181</span>
</code></pre><p><strong>mntr</strong></p>
<pre><code><span class="comment">#输出一些ZK运行时信息，通过对这些返回结果的解析，可以达到监控的效果。</span>

$ <span class="built_in">echo</span> mntr | nc localhost <span class="number">2185</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>ZooKeeper Server是一个Java语言实现的分布式协调服务框架，因此需要JDK6+的支持。为了确保ZooKeeper服务的稳定与可靠性，通常是搭建成一个ZK集群来对外提供服务。ZK有一个重要的特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的，所以建议集群的机器数量为奇数。</p>
<h4 id="1、安装JDK6+">1、安装JDK6+</h4>
<h4 id="2、去官网选择一个合适的版本下载。">2、去官网选择一个合适的版本下载。</h4>
<pre><code><span class="comment">#官网 http://www.apache.org/dyn/closer.cgi/zookeeper/</span>

wget <span class="symbol">http:</span>/<span class="regexp">/mirrors.cnnic.cn/apache</span><span class="regexp">/zookeeper/zookeeper</span>-<span class="number">3.4</span>.<span class="number">6</span>/zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
tar zxf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
cd zookeeper-<span class="number">3.4</span>.<span class="number">6</span>
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM G1垃圾回收器]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/02/JVM%20G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.chenbaocheng.com/2015/07/02/JVM G1垃圾回收器/</id>
    <published>2015-07-02T02:35:59.000Z</published>
    <updated>2015-07-02T06:33:17.000Z</updated>
    <content type="html"><![CDATA[<p>回顾一下主流的(HotSpot JVM)JAVA垃圾回收器，堆被内存分解为三个区域，具体分为：新生代、老年代、持久代。</p>
<p><strong>Java 7 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java7-jvm-space.png">

<p><strong>Java 8 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java8-jvm-space.png">

<a id="more"></a>

<p>1、绝大部分新生成的对象都放在Eden区，当Eden区将满，JVM会因申请不到内存，而触发Young GC ,进行Eden区+有对象的Survivor区(设为S0区)垃圾回收，把存活的对象用复制算法拷贝到一个空的Survivor(S1)中，此时Eden区被清空，另外一个Survivor S0也为空。下次触发Young GC回收Eden+S0，将存活对象拷贝到S1中。新生代垃圾回收简单、粗暴、高效。</p>
<p>2、若发现Survivor区满了，则将这些对象拷贝到old区或者Survivor没满但某些对象足够Old,也拷贝到Old区(每次Young GC都会使Survivor区存活对象值+1，直到阈值)。 </p>
<p>3、Old区也会进行垃圾收集(Young GC),发生一次 Major GC 至少伴随一次Young GC，一般比Young GC慢十倍以上。<br>JVM在Old区申请不到内存，会进行Full GC。Old区使用一般采用Concurrent-Mark–Sweep策略回收内存。</p>
<p><strong>总结</strong>：</p>
<p>Java垃圾回收器是一种“自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>GC过程中会出现STW(Stop-The-World)，若Old区对象太多，STW耗费大量时间。</li>
<li>CMS收集器对CPU资源很敏感。</li>
<li>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</li>
<li>CMS导致内存碎片问题。</li>
</ul>
<h4 id="G1收集器">G1收集器</h4>
<p>在G1中，堆被划分成 许多个连续的区域(region)。每个区域大小相等，在1M~32M之间。JVM最多支持2000个区域，可推算G1能支持的最大内存为2000*32M=62.5G。区域(region)的大小在JVM初始化的时候决定，也可以用-XX:G1HeapReginSize设置。</p>
<p>在G1中没有物理上的Yong(Eden/Survivor)/Old Generation，它们是逻辑的，使用一些非连续的区域(Region)组成的。</p>
<p><strong>新生代收集</strong></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-young-1.png">

<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-young-2.png">

<p>被圈起的绿色部分为新生代的区域(region)，经过Young GC后存活的对象被复制到一个或者多个区域空闲中，这些被填充的区域将是新的新生代；当新生代对象的年龄(逃逸过一次Young GC年龄增加１)已经达到某个阈值(ParNew默认15)，被复制到老年代的区域中。</p>
<p>回收过程是停顿的(STW,Stop-The-Word);回收完成之后根据Young GC的统计信息调整Eden和Survivor的大小，有助于合理利用内存，提高回收效率。</p>
<p>回收的过程多个回收线程并发收集。</p>
<p><strong>老年代收集</strong></p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-1.jpg">

<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-2.jpg">

<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-3.jpg">

<p><strong>关于Remembered Set概念</strong>：G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用是使用Remembered Set来避免扫描全堆。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序对Reference类型数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之间(在分代中例子中就是检查是否老年代中的对象引用了新生代的对象)，如果是便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当内存回收时，在GC根节点的枚举范围加入Remembered Set即可保证不对全局堆扫描也不会有遗漏。</p>
<p>G1虽然保留了CMS关于代的概念，但是代已经不是物理上连续区域，而是一个逻辑的概念。在标记过程中，每个区域的对象活性都被计算，在回收时候，就可以根据用户设置的停顿时间，选择活性较低的区域收集，这样既能保证垃圾回收，又能保证停顿时间，而且也不会降低太多的吞吐量。Remark阶段新算法的运用，以及收集过程中的压缩，都弥补了CMS不足。引用Oracle官网的一句话：“G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS)”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>回顾一下主流的(HotSpot JVM)JAVA垃圾回收器，堆被内存分解为三个区域，具体分为：新生代、老年代、持久代。</p>
<p><strong>Java 7 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java7-jvm-space.png">

<p><strong>Java 8 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java8-jvm-space.png">

]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8元空间(Metaspace)]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/30/Java%208%E5%85%83%E7%A9%BA%E9%97%B4(Metaspace)/"/>
    <id>http://www.chenbaocheng.com/2015/06/30/Java 8元空间(Metaspace)/</id>
    <published>2015-06-30T07:30:29.000Z</published>
    <updated>2015-06-30T09:35:47.000Z</updated>
    <content type="html"><![CDATA[<h4 id="元空间（Metaspace）：">元空间（Metaspace）：</h4>
<p>相信许多Java开发者都见过“java.lang.OutOfMemoryError: PermGen space”问题，这通常是类加载器相关的内存泄漏以及新类加载器的创建导致的，一般出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，通常“问题”是默认值太低了, 常用的解决方法是将其设置为256MB或更高。</p>
<p>PermGen space的全称是Permanent Generation space,是指JVM永久保存区域，这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。JVM 种类有很多(如Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM）。Oracle-Sun Hotspot才有PermGen space，JRockit以及J9没有这个区域。</p>
<p>随着JAVA8时代的来临,新增一种使用本地内存来存储类元数据信息称之为元空间(Metaspace)，JVM永久区被元空间(Metaspace)替换(JEP 122), 与Oracle JRockit 和IBM JVM’s很相似。JVM参数 -XX:PermSize 和 -XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替，如果使用了-XX:PermSize 和 -XX:MaxPermSize启动时会发出警告。。 这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用。</p>
<a id="more"></a>

<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-8-metaspace.jpg">

<h4 id="Metaspace_内存分配模型">Metaspace 内存分配模型</h4>
<ul>
<li>大部分类元数据都在本地内存中分配。</li>
<li>用于描述类元数据的“klasses”已经被移除。</li>
</ul>
<h4 id="Metaspace_容量">Metaspace 容量</h4>
<ul>
<li>默认情况下，类元数据只受可用的本地内存限制（容量取决于是32位或是64位操作系统的可用虚拟内存大小）。</li>
<li>新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。</li>
</ul>
<h4 id="Metaspace_垃圾回收">Metaspace 垃圾回收</h4>
<ul>
<li>对于僵死的类及类加载器的垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行。</li>
<li>适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。</li>
</ul>
<h4 id="Java_堆内存的影响">Java 堆内存的影响</h4>
<p>一些杂项数据已经移到Java堆空间中。升级到JDK8之后，会发现Java堆 空间有所增长。</p>
<h4 id="Metaspace_监控">Metaspace 监控</h4>
<p>元空间的使用情况可以从HotSpot1.8的详细GC日志输出中看到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="元空间（Metaspace）：">元空间（Metaspace）：</h4>
<p>相信许多Java开发者都见过“java.lang.OutOfMemoryError: PermGen space”问题，这通常是类加载器相关的内存泄漏以及新类加载器的创建导致的，一般出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，通常“问题”是默认值太低了, 常用的解决方法是将其设置为256MB或更高。</p>
<p>PermGen space的全称是Permanent Generation space,是指JVM永久保存区域，这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。JVM 种类有很多(如Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM）。Oracle-Sun Hotspot才有PermGen space，JRockit以及J9没有这个区域。</p>
<p>随着JAVA8时代的来临,新增一种使用本地内存来存储类元数据信息称之为元空间(Metaspace)，JVM永久区被元空间(Metaspace)替换(JEP 122), 与Oracle JRockit 和IBM JVM’s很相似。JVM参数 -XX:PermSize 和 -XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替，如果使用了-XX:PermSize 和 -XX:MaxPermSize启动时会发出警告。。 这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用。</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM内存管理与垃圾回收]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/26/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.chenbaocheng.com/2015/06/26/JVM内存管理与垃圾回收/</id>
    <published>2015-06-26T03:53:26.000Z</published>
    <updated>2015-06-29T04:14:46.000Z</updated>
    <content type="html"><![CDATA[<p>Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

<a id="more"></a>

<h4 id="JVM_运行时数据区域">JVM 运行时数据区域</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm_memory_structure.png">

<p>Java 虚拟机在执行Java 程序过程中会把它所管理的内存划分为几个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p>这几个区域如下：</p>
<ul>
<li>方法区（Method Area）</li>
<li>虚拟机栈（VM Stack）</li>
<li>本地方法栈（Natvie Method Stack）</li>
<li>堆（Heap）</li>
<li>程序计数器（Program Counter Register）</li>
</ul>
<h4 id="JVM中Stack和Heap的关系">JVM中Stack和Heap的关系</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们经常会把 Java 内存分为堆内存（Heap）和栈内存（Stack），这是一种比较粗糙区分方式。我们平时所关注的也主要是这两个区域。栈指的是上图中的Java虚拟机栈。Java 虚拟机栈是线程私有的，其生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息，<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-thread-stack.gif">

<p>&nbsp;&nbsp;&nbsp;&nbsp;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和 returnAddress（指向一条字节码指令的地址）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果线程请求的栈深度大于虚拟机允许的深度，会抛出 StackOverflowException 异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存时会抛出 OutOfMemoryError 异常。递归调用时如果深度过深，很容易出现栈溢出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用程序来说，堆(Heap)是Java虚拟机管理的内存中最大的一块。 堆是所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在Java体系中，即便是最简单的对象访问，也会涉及栈、堆、方法区这三个最重要的内存区域。例如下面这行代码：</p>
<ul>
<li>Object obj = new Object();</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;假如这段代码出现在方法体中，Object obj 这部分的语意会反映到Java虚拟机栈的本地变量表中，做为一个reference 类型数据出现。new Object()这部分语意会反映在Java堆中，形成一块存储了 Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存。不同虚拟机的对象访问方式有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>
<h4 id="堆内存">堆内存</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Java中堆是JVM 管理的最大一块内存空间，主要用于存放各种类的实例对象。堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。堆的内存模型大致为：</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-memory-heap.png">

<ul>
<li>堆大小 = 新生代 + 老年代</li>
</ul>
<h4 id="常用的内存区域调节参数">常用的内存区域调节参数</h4>
<ul>
<li><p>-Xms：初始堆大小，默认为物理内存的1/64(&lt;1GB)；默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</p>
</li>
<li><p>-Xmx：最大堆大小，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</p>
</li>
<li><p>-Xmn：新生代的内存空间大小，注意：此处的大小是（eden+ 2 survivor space)。与jmap -heap中显示的New gen是不同的。整个堆大小=新生代大小 + 老生代大小 + 永久代大小。 在保证堆大小不变的情况下，增大新生代后,将会减小老生代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8。</p>
</li>
<li><p>-XX:SurvivorRatio：新生代中Eden区域与Survivor区域的容量比值，默认值为8。两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10。</p>
</li>
<li><p>-Xss：每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。应根据应用的线程所需内存大小进行适当调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。一般小的应用， 如果栈不是很深， 应该是128k够用的，大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</p>
</li>
<li><p>-XX:PermSize：设置永久代(perm gen)初始值。默认值为物理内存的1/64。</p>
</li>
<li><p>-XX:MaxPermSize：设置持久代最大值。物理内存的1/4。</p>
</li>
</ul>
<h4 id="GC_堆">GC 堆</h4>
<p>&nbsp;&nbsp;Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。<br>当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。<br>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。<br>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p>
<h4 id="GC_日志">GC 日志</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    Object obj = <span class="keyword">new</span> Object();
    System.gc();
    System.<span class="keyword">out</span>.println();
    obj = <span class="keyword">new</span> Object();
    obj = <span class="keyword">new</span> Object();
    System.gc();
    System.<span class="keyword">out</span>.println();
}
</code></pre><p>设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-log-1.png"><br><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-log-2.png">

<p>&nbsp;&nbsp;从 Full GC 信息可知，新生代可用的内存大小约为 18M，则新生代实际分配得到的内存空间约为 20M(为什么是 20M? 请继续看下面…)。老年代分得的内存大小约为 42M，堆的可用内存的大小约为 60M。可以计算出： 18432K ( 新生代可用空间 ) + 42112K ( 老年代空间 ) = 60544K ( 堆的可用空间 )<br>新生代约占堆大小的 1/3，老年代约占堆大小的 2/3。也可以看出，GC 对新生代的回收比较乐观，而对老年代以及方法区的回收并不明显或者说不及新生代。<br>并且在这里 Full GC 耗时是 Minor GC 的 22.89 倍。</p>
<h4 id="JVM_参数选项">JVM 参数选项</h4>
<p>jvm 可配置的参数选项可以参考 Oracle 官方网站给出的相关信息：<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td> -Xms</td>
<td>初始堆大小。如：-Xms256m</td>
</tr>
<tr>
<td> -Xmx</td>
<td>最大堆大小。如：-Xmx512m</td>
</tr>
<tr>
<td> -Xmn</td>
<td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td>
</tr>
<tr>
<td> -Xss</td>
<td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td>
</tr>
<tr>
<td> -XX:NewRatio</td>
<td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</td>
</tr>
<tr>
<td> -XX:SurvivorRatio</td>
<td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td>
</tr>
<tr>
<td> -XX:PermSize</td>
<td>永久代(方法区)的初始大小</td>
</tr>
<tr>
<td> -XX:MaxPermSize</td>
<td>永久代(方法区)的最大值</td>
</tr>
<tr>
<td> -XX:+PrintGCDetails</td>
<td>打印 GC 信息</td>
</tr>
<tr>
<td> -XX:+HeapDumpOnOutOfMemoryError</td>
<td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td>
</tr>
</tbody>
</table>
<pre><code><span class="javadoc">/**
    -Xms60m
    -Xmx60m
    -Xmn20m
    -XX:NewRatio=2 ( 若 Xms = Xmx, 并且设定了 Xmn, 那么该项配置就不需要配置了 )
    -XX:SurvivorRatio=8
    -XX:PermSize=30m
    -XX:MaxPermSize=30m
    -XX:+PrintGCDetails
*/</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    <span class="keyword">new</span> Test().doTest();
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span>(){
    Integer M = <span class="keyword">new</span> Integer(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);  <span class="comment">//单位, 兆(M)</span>
    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M]; <span class="comment">//申请 1M 大小的内存空间</span>
    bytes = <span class="keyword">null</span>;  <span class="comment">//断开引用链</span>
    System.gc();   <span class="comment">//通知 GC 收集垃圾</span>
    System.out.println();
    bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M];  <span class="comment">//重新申请 1M 大小的内存空间</span>
    bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M];  <span class="comment">//再次申请 1M 大小的内存空间</span>
    System.gc();
    System.out.println();
}
</code></pre><p>按上面代码中注释的信息设定 jvm 相关的参数项，并执行程序，下面是一次执行完成控制台打印的结果：</p>
<pre><code>[ GC [ PSYoungGen:  <span class="number">1351</span><span class="keyword">K</span> -&gt; <span class="number">288</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  <span class="number">1351</span><span class="keyword">K</span> -&gt; <span class="number">288</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>), <span class="number">0.0012389</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs ] 
[ <span class="keyword">Full</span> GC (System)  [ PSYoungGen:  <span class="number">288</span><span class="keyword">K</span> -&gt; <span class="number">0</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  [ PSOldGen:  <span class="number">0</span><span class="keyword">K</span> -&gt; <span class="number">160</span><span class="keyword">K</span> (<span class="number">40960</span><span class="keyword">K</span>) ]  <span class="number">288</span><span class="keyword">K</span> -&gt; <span class="number">160</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>)  [ PSPermGen:  <span class="number">2942</span><span class="keyword">K</span> -&gt; <span class="number">2942</span><span class="keyword">K</span> (<span class="number">30720</span><span class="keyword">K</span>) ],  <span class="number">0.0057649</span> secs ] [ <span class="keyword">Times</span>:  user=<span class="number">0.00</span>  sys=<span class="number">0.00</span>,  real=<span class="number">0.01</span> secs ] 

[ GC [ PSYoungGen:  <span class="number">2703</span><span class="keyword">K</span> -&gt; <span class="number">1056</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  <span class="number">2863</span><span class="keyword">K</span> -&gt; <span class="number">1216</span><span class="keyword">K</span>(<span class="number">59392</span><span class="keyword">K</span>),  <span class="number">0.0008206</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs ] 
[ <span class="keyword">Full</span> GC (System)  [ PSYoungGen:  <span class="number">1056</span><span class="keyword">K</span> -&gt; <span class="number">0</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  [ PSOldGen:  <span class="number">160</span><span class="keyword">K</span> -&gt; <span class="number">1184</span><span class="keyword">K</span> (<span class="number">40960</span><span class="keyword">K</span>) ]  <span class="number">1216</span><span class="keyword">K</span> -&gt; <span class="number">1184</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>)  [ PSPermGen:  <span class="number">2951</span><span class="keyword">K</span> -&gt; <span class="number">2951</span><span class="keyword">K</span> (<span class="number">30720</span><span class="keyword">K</span>) ], <span class="number">0.0052445</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs ] 

Heap
PSYoungGen      total <span class="number">18432</span><span class="keyword">K</span>, used <span class="number">327</span><span class="keyword">K</span> [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)
eden space <span class="number">16384</span><span class="keyword">K</span>, <span class="number">2</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec51f58</span>,<span class="number">0x00000000ffc00000</span>)
from space <span class="number">2048</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x0000000100000000</span>)
to   space <span class="number">2048</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffe00000</span>)
PSOldGen        total <span class="number">40960</span><span class="keyword">K</span>, used <span class="number">1184</span><span class="keyword">K</span> [<span class="number">0x00000000fc400000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)
object space <span class="number">40960</span><span class="keyword">K</span>, <span class="number">2</span>% used [<span class="number">0x00000000fc400000</span>,<span class="number">0x00000000fc5281f8</span>,<span class="number">0x00000000fec00000</span>)
PSPermGen       total <span class="number">30720</span><span class="keyword">K</span>, used <span class="number">2959</span><span class="keyword">K</span> [<span class="number">0x00000000fa600000</span>, <span class="number">0x00000000fc400000</span>, <span class="number">0x00000000fc400000</span>)
object space <span class="number">30720</span><span class="keyword">K</span>, <span class="number">9</span>% used [<span class="number">0x00000000fa600000</span>,<span class="number">0x00000000fa8e3ce0</span>,<span class="number">0x00000000fc400000</span>)
</code></pre><p>从打印结果可以看出，堆中新生代的内存空间为 18432K ( 约 18M )，eden 的内存空间为 16384K ( 约 16M)，from / to survivor 的内存空间为 2048K ( 约 2M)。<br>这里所配置的 Xmn 为 20M，也就是指定了新生代的内存空间为 20M，可是从打印的堆信息来看，新生代怎么就只有 18M 呢? 另外的 2M 哪里去了?<br>别急，是这样的。新生代 = eden + from + to = 16 + 2 + 2 = 20M，可见新生代的内存空间确实是按 Xmn 参数分配得到的。<br>而且这里指定了 SurvivorRatio = 8，因此，eden = 8/10 的新生代空间 = 8/10 <em> 20 = 16M。from = to = 1/10 的新生代空间 = 1/10 </em> 20 = 2M。<br>堆信息中新生代的 total 18432K 是这样来的： eden + 1 个 survivor = 16384K + 2048K = 18432K，即约为 18M。<br>因为 jvm 每次只是用新生代中的 eden 和 一个 survivor，因此新生代实际的可用内存空间大小为所指定的 90%。<br>因此可以知道，这里新生代的内存空间指的是新生代可用的总的内存空间，而不是指整个新生代的空间大小。<br>另外，可以看出老年代的内存空间为 40960K ( 约 40M )，堆大小 = 新生代 + 老年代。因此在这里，老年代 = 堆大小 – 新生代 = 60 – 20 = 40M。<br>最后，这里还指定了 PermSize = 30m，PermGen 即永久代 ( 方法区 )，它还有一个名字，叫非堆，主要用来存储由 jvm 加载的类文件信息、常量、静态变量等。</p>
<p>打个盹，回到 doTest() 方法中，可以看到代码在第 17、21、22 这三行中分别申请了一块 1M 大小的内存空间，并在 19 和 23 这两行中分别显式的调用了 System.gc()。从控制台打印的信息来看，每次调 System.gc()，是先进行 Minor GC，然后再进行 Full GC。<br>第 19 行触发的 Minor GC 收集分析：<br>从信息 PSYoungGen :  1351K -&gt; 288K，可以知道，在第 17 行为 bytes 分配的内存空间已经被回收完成。<br>引起 GC 回收这 1M 内存空间的因素是第 18 行的 bytes = null;   bytes 为 null 表明之前申请的那 1M 大小的内存空间现在已经没有任何引用变量在使用它了，<br>并且在内存中它处于一种不可到达状态 ( 即没有任何引用链与 GC Roots 相连 )。那么，当 Minor GC 发生的时候，GC 就会来回收掉这部分的内存空间。<br>第 19 行触发的 Full GC 收集分析：<br>在 Minor GC 的时候，信息显示 PSYoungGen :  1351K -&gt; 288K，再看看 Full GC 中显示的 PSYoungGen :  288K -&gt; 0K，可以看出，Full GC 后，新生代的内存使用变成<br>0K 了 ( 0K，零 K，有没有人看成是英文的 OK 的 ? 好吧。我承认我第一次看的时候以为是英文的 OK，当时还特意在控制台打印 0K 和 OK 来确认。最后发现英文的 O 长得比阿拉伯数字的 0 要丰满和胖一些。现在印象还是比较深刻的。好像。。我跑题了 ~~ )<br>刚刚说到 Full GC 后，新生代的内存使用从 288K 变成 0K 了，那么这 288K 到底哪去了 ? 难道都被 GC 当成垃圾回收掉了 ? 当然不是了。我还特意在 main 方法中 new 了一个 Test 类的实例，这里的 Test 类的实例属于小对象，它应该被分配到新生代内存当中，现在还在调用这个实例的 doTest 方法呢，GC 不可能在这个时候来回收它的。<br>接着往下看 Full GC 的信息，会发现一个很有趣的现象，PSOldGen:  0K  -&gt; 160K，可以看到，Full GC 后，老年代的内存使用从 0K 变成了 160K，想必你已经猜到大概是怎么回事了。当 Full GC 进行的时候，默认的方式是尽量清空新生代 ( YoungGen )，因此在调 System.gc() 时，新生代 ( YoungGen ) 中存活的对象会提前进入老年代。<br>第 23 行触发的 Minor GC 收集分析：<br>从信息 PSYoungGen :  2703K -&gt; 1056K，可以知道，在第 21 行创建的，大小为 1M 的数组被 GC 回收了。在第 22 行创建的，大小也为 1M 的数组由于 bytes 引用变量还在引用它，因此，它暂时未被 GC 回收。<br>第 23 行触发的 Full GC 收集分析：<br>在 Minor GC 的时候，信息显示 PSYoungGen :  2703K -&gt; 1056K，Full GC 中显示的 PSYoungGen :  1056K -&gt; 0K，以及 PSOldGen:  160K -&gt; 1184K，可以知道，新生代 ( YoungGen ) 中存活的对象又提前进入老年代了。</p>
<h4 id="GC算法">GC算法</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm.png">

<h5 id="新生代可用GC">新生代可用GC</h5>
<p><strong>1）串行GC(Serial Copying)：</strong></p>
<p>client模式下默认GC方式，也可通过-XX:+UseSerialGC来强制指定；默认情况下 eden、s0、s1的大小通过-XX:SurvivorRatio来控制，默认为8，含义<br>为eden:s0的比例，启动后可通过jmap –heap [pid]来查看。</p>
<p>默认情况下，仅在TLAB或eden上分配，只有两种情况下会在老生代分配： </p>
<p>1、需要分配的内存大小超过eden space大小；<br>2、在配置了PretenureSizeThreshold的情况下，对象大小大于此值。</p>
<p>默认情况下，触发Minor GC时：<br>之前Minor GC晋级到old的平均大小 &lt; 老生代的剩余空间 &lt; eden+from Survivor的使用空间。当HandlePromotionFailure为true，则仅触发minor gc；如为false，则触发full GC。</p>
<p>默认情况下，新生代对象晋升到老生代的规则：</p>
<p>1、经历多次minor gc仍存活的对象，可通过以下参数来控制：以MaxTenuringThreshold值为准，默认为15。<br>2、to space放不下的，直接放入老生代；</p>
<p>**2）并行GC（ParNew）：</p>
<p>GC时默认采用，也可采用-XX:+UseParNewGC强制指定；垃圾回收的时候采用多线程的方式。</p>
<p><strong>3）并行回收GC(Parallel Scavenge)：</strong></p>
<p>server模式下默认的GC方式，也可采用-XX:+UseParallelGC强制指定；eden、s0、s1的大小可通过-XX:SurvivorRatio来控制，但默认情况下<br>以-XX:InitialSurivivorRatio为准，此值默认为8，代表的为新生代大小 : s0，这点要特别注意。</p>
<p>默认情况下，当TLAB、eden上分配都失败时，判断需要分配的内存大小是否 &gt;= eden space的一半大小，如是就直接在老生代上分配；</p>
<p><strong>默认情况下的垃圾回收规则：</strong></p>
<ol>
<li>在回收前PS GC会先检测之前每次PS GC时，晋升到老生代的平均大小是否大于老生代的剩余空间，如大于则直接触发full GC；</li>
<li>在回收后，也会按照上面的规则进行检测。</li>
</ol>
<p><strong>默认情况下的新生代对象晋升到老生代的规则：</strong></p>
<ol>
<li><p>经历多次minor gc仍存活的对象，可通过以下参数来控制：AlwaysTenure，默认false，表示只要minor GC时存活，就晋升到老生代；NeverTenure，默认false，表示永不晋升到老生代；上面两个都没设置的情冴下，如UseAdaptiveSizePolicy，启动时以InitialTenuringThreshold值作为存活次数的阈值，在每次ps gc后会动态调整，如不使用UseAdaptiveSizePolicy，则以MaxTenuringThreshold为准。</p>
</li>
<li><p>to space放不下的，直接放入老生代。在回收后，如UseAdaptiveSizePolicy，PS GC会根据运行状态动态调整eden、to以及TenuringThreshold的大小。如果不希望动态调整可设置-XX:-UseAdaptiveSizePolicy。如希望跟踪每次的变化情况，可在启劢参数上增加： PrintAdaptiveSizePolicy。</p>
</li>
</ol>
<h5 id="二、老生代可用GC">二、老生代可用GC</h5>
<p><strong>1、串行GC(Serial Copying)：</strong><br>client方式下默认GC方式，可通过-XX:+UseSerialGC强制指定。</p>
<p>触发机制：</p>
<ol>
<li>old gen空间不足；</li>
<li>perm gen空间不足；</li>
<li>minor gc时的悲观策略；</li>
<li>minor GC后在eden上分配内存仍然失败；</li>
<li>执行heap dump时；</li>
<li>外部调用System.gc，可通过-XX:+DisableExplicitGC来禁止。</li>
</ol>
<p><strong>2、并行回收GC(Parallel Scavenge)：</strong> server模式下默认GC方式，可通过-XX:+UseParallelGC强制指定； 并行的线程数为当cpu core&lt;=8 ? cpu core : 3+(cpu core*5)/8或通过-XX:ParallelGCThreads=x来强制指定。如ScavengeBeforeFullGC为true（默认值），则先执行minor GC。</p>
<p><strong>3、并行Compacting：</strong><br>可通过-XX:+UseParallelOldGC强制指定。</p>
<p><strong>4、并发CMS：</strong><br>可通过-XX:+UseConcMarkSweepGC来强制指定。并发的线程数默认为:( 并行GC线程数+3)/4，也可通过ParallelCMSThreads指定。</p>
<p>触发机制：</p>
<ol>
<li><p>当老生代空间的使用到达一定比率时触发；<br>Hotspot V 1.6中默认为65%，可通过PrintCMSInitiationStatistics（此参数在V 1.5中不能用）来查看这个值到底是多少；可通过CMSInitiatingOccupancyFraction来强制指定，默认值并不是赋值在了这个值上，是根据如下公式计算出来的： ((100 - MinHeapFreeRatio) +(double)(CMSTriggerRatio * MinHeapFreeRatio) / 100.0)/ 100.0; 其中,MinHeapFreeRatio默认值： 40   CMSTriggerRatio默认值： 80。</p>
</li>
<li><p>当perm gen采用CMS收集且空间使用到一定比率时触发；<br>perm gen采用CMS收集需设置：-XX:+CMSClassUnloadingEnabled   Hotspot V 1.6中默认为65%；可通过CMSInitiatingPermOccupancyFraction来强制指定，同样，它是根据如下公式计算出来的：((100 - MinHeapFreeRatio) +(double)(CMSTriggerPermRatio* MinHeapFreeRatio) / 100.0)/ 100.0; 其中，MinHeapFreeRatio默认值： 40    CMSTriggerPermRatio默认值： 80。</p>
</li>
<li><p>Hotspot根据成本计算决定是否需要执行CMS GC；可通过-XX:+UseCMSInitiatingOccupancyOnly来去掉这个动态执行的策略。</p>
</li>
<li>外部调用了System.gc，且设置了ExplicitGCInvokesConcurrent；需要注意，在hotspot 6中，在这种情况下如应用同时使用了NIO，可能会出现bug。</li>
</ol>
<p><strong>WEB SERVER 选择并行GC + CMS即可</strong></p>
<p><strong>默认GC组合</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm-default.png">

<p><strong>可选的GC组合</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm-option-combination.png">


<h4 id="GC监测">GC监测</h4>
<p>命令行工具</p>
<pre><code>jstat –gcutil [pid] [intervel] [count]
-<span class="ruby"><span class="symbol">verbose:</span>gc /<span class="regexp">/ 可以辅助输出一些详细的GC信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDetails</span> /<span class="regexp">/ 输出GC详细信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCApplicationStoppedTime</span> /<span class="regexp">/ 输出GC造成应用暂停的时间
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDateStamps</span> /<span class="regexp">/ GC发生的时间信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintHeapAtGC</span> /<span class="regexp">/ 在GC前后输出堆中各个区域的大小；
</span></span>-<span class="ruby"><span class="constant">Xloggc</span><span class="symbol">:</span>[file] /<span class="regexp">/ 将GC信息输出到单独的文件中，建议都加上，这个消耗不大，而且对查问题和调优有很大的帮助。gc的日志拿下来后可使用GCLogViewer或gchisto进行分析。</span></span>
</code></pre><p>也可以用图形化工具jvisualvm进行分析</p>
<h4 id="系统调优方法">系统调优方法</h4>
<p>调优步骤：</p>
<ol>
<li>评估现状 </li>
<li>设定目标 </li>
<li>尝试调优 </li>
<li>衡量调优</li>
<li>细微调整</li>
</ol>
<p><strong>设定目标：</strong></p>
<ol>
<li>降低Full GC的执行频率？</li>
<li>降低Full GC的消耗时间？</li>
<li>降低Full GC所造成的应用停顿时间？</li>
<li>降低Minor GC执行频率？</li>
<li>降低Minor GC消耗时间？<br>例如某系统的GC调优目标：降低Full GC执行频率的同时，尽可能降低minor GC的执行频率、消耗时间以及GC对应用造成的停顿时间。</li>
</ol>
<p><strong>衡量调优：</strong></p>
<p>1、衡量工具<br>    1）打印GC日志信息：-XX:+PrintGCDetails –XX:+PrintGCApplicationStoppedTime     -Xloggc: {文件名}  -XX:+PrintGCTimeStamps</p>
<pre><code><span class="number">2</span>）jmap：（由于每个版本<span class="keyword">jvm</span>的默认值可能会有改变，建议还是用jmap首先观察下目前每个代的内存大小、<span class="type">GC</span>方式） 

<span class="number">3</span>）运行状况监测工具：jstat、jvisualvm、sar 、gclogviewer
</code></pre><p>2、应收集的信息<br>    1）minor gc的执行频率；full gc的执行频率，每次GC耗时多少？</p>
<pre><code><span class="number">2</span>）高峰期什么状况？

<span class="number">3</span>）minor gc回收的效果如何？survivor的消耗状况如何，每次有多少对象会进入老生代？

<span class="number">4</span>）full gc回收的效果如何？（简单的memory leak判断方法）

<span class="number">5</span>）系统的<span class="built_in">load</span>、cpu消耗、qps <span class="keyword">or</span> tps、响应时间
</code></pre><p>QPS每秒查询率：是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。在因特网上，作为域名服务器的机器性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。<br>TPS(Transaction Per Second)：每秒钟系统能够处理的交易或事务的数量。</p>
<p><strong>尝试调优：</strong></p>
<p>注意Java RMI的定时GC触发机制，可通过：-XX:+DisableExplicitGC来禁止或通过 -Dsun.rmi.dgc.server.gcInterval=3600000来控制触发的时间。</p>
<p>1）降低Full GC执行频率 – 通常瓶颈<br>老生代本身占用的内存空间就一直偏高，所以只要稍微放点对象到老生代，就full GC了；<br>通常原因：系统缓存的东西太多；<br>例如：使用oracle 10g驱动时preparedstatement cache太大；<br>查找办法：现执行Dump然后再进行MAT分析；</p>
<p>（1）Minor GC后总是有对象不断的进入老生代，导致老生代不断的满<br>通常原因：Survivor太小了<br>系统表现：系统响应太慢、请求量太大、每次请求分配的内存太多、分配的对象太大…<br>查找办法：分析两次minor GC之间到底哪些地方分配了内存；<br>利用jstat观察Survivor的消耗状况，-XX:PrintHeapAtGC，输出GC前后的详细信息；<br>对于系统响应慢可以采用系统优化，不是GC优化的内容；</p>
<p>（2）老生代的内存占用一直偏高<br>调优方法：① 扩大老生代的大小（减少新生代的大小或调大heap的 大小）；<br>减少new注意对minor gc的影响并且同时有可能造成full gc还是严重；<br>调大heap注意full gc的时间的延长，cpu够强悍嘛，os是32 bit的吗？<br>② 程序优化（去掉一些不必要的缓存）</p>
<p>（3）Minor GC后总是有对象不断的进入老生代<br>前提：这些进入老生代的对象在full GC时大部分都会被回收<br>调优方法：<br>① 降低Minor GC的执行频率；<br>② 让对象尽量在Minor GC中就被回收掉：增大Eden区、增大survivor、增大TenuringThreshold；注意这些可能会造成minor gc执行频繁；<br>③ 切换成CMS GC：老生代还没有满就回收掉，从而降低Full GC触发的可能性；<br>④ 程序优化：提升响应速度、降低每次请求分配的内存、</p>
<p>（4）降低单次Full GC的执行时间<br>通常原因：老生代太大了…<br>调优方法：1）是并行GC吗？   2）升级CPU  3）减小Heap或老生代</p>
<p>（5）降低Minor GC执行频率<br>通常原因：每次请求分配的内存多、请求量大<br>通常办法：1）扩大heap、扩大新生代、扩大eden。注意点：降低每次请求分配的内存；横向增加机器的数量分担请求的数量。</p>
<p>（6）降低Minor GC执行时间<br>通常原因：新生代太大了，响应速度太慢了，导致每次Minor GC时存活的对象多<br>通常办法：1）减小点新生代吧；2）增加CPU的数量、升级CPU的配置；加快系统的响应速度</p>
<p>细微调整：</p>
<p>首先需要了解以下情况：</p>
<p>① 当响应速度下降到多少或请求量上涨到多少时，系统会宕掉？</p>
<p>② 参数调整后系统多久会执行一次Minor GC，多久会执行一次Full GC，高峰期会如何？</p>
<p>需要计算的量：</p>
<p>①每次请求平均需要分配多少内存？系统的平均响应时间是多少呢？请求量是多少、多常时间执行一次Minor GC、Full GC？</p>
<p>②现有参数下，应该是多久一次Minor GC、Full GC，对比真实状况，做一定的调整；</p>
<p>必杀技：提升响应速度、降低每次请求分配的内存？</p>
<h4 id="垃圾回收的实现原理">垃圾回收的实现原理</h4>
<p> 内存回收的实现方法：1）引用计数：不适合复杂对象的引用关系，尤其是循环依赖的场景。2）有向图Tracing：适合于复杂对象的引用关系场景，Hotspot采用这种。常用算法：Copying、Mark-Sweep、Mark-Compact。</p>
<p>Hotspot从root set开始扫描有引用的对象并对Reference类型的对象进行特殊处理。以下是Root Set的列表：<br>1）当前正在执行的线程；<br>2）全局/静态变量；<br>3）JVM Handles；<br>4）JNI 【 Java Native Interface 】Handles；</p>
<p>另外：minor GC只扫描新生代，当老生代的对象引用了新生代的对象时，会采用如下的处理方式：在给对象赋引用时，会经过一个write barrier的过程，以便检查是否有老生代引用新生代对象的情况，如有则记录到remember set中。并在minor gc时，remember set指向的新生代对象也作为root set。</p>
<p><strong>新生代串行GC(Serial Copying)：</strong></p>
<p>新生代串行GC(Serial Copying)完整内存的分配策略：</p>
<p>1）首先在TLAB（本地线程分配缓冲区）上尝试分配；</p>
<p>2）检查是否需要在新生代上分配，如需要分配的大小小于PretenureSizeThreshold，则在eden区上进行分配，分配成功则返回；分配失败则继续；</p>
<p>3）检查是否需要尝试在老生代上分配，如需要，则遍历所有代并检查是否可在该代上分配，如可以则进行分配；如不需要在老生代上尝试分配，则继续；</p>
<p>4）根据策略决定执行新生代GC或Full GC，执行full gc时不清除soft Ref；</p>
<p>5）如需要分配的大小大于PretenureSizeThreshold，尝试在老生代上分配，否则尝试在新生代上分配；</p>
<p>6）尝试扩大堆并分配；</p>
<p>7）执行full gc，并清除所有soft Ref，按步骤5继续尝试分配。  </p>
<p>新生代串行GC(Serial Copying)完整内存回收策略<br>1）检查to是否为空，不为空返回false；</p>
<p>2）检查老生代剩余空间是否大于当前eden+from已用的大小，如大于则返回true，如小于且HandlePromotionFailure为true，则检查剩余空间是否大于之前每次minor gc晋级到老生代的平均大小，如大于返回true，如小于返回false。</p>
<p>3）如上面的结果为false，则执行full gc；如上面的结果为true，执行下面的步骤；</p>
<p>4）扫描引用关系，将活的对象copy到to space，如对象在minor gc中的存活次数超过tenuring_threshold或分配失败，则往老生代复制，如仍然复制失败，则取决于HandlePromotionFailure，如不需要处理，直接抛出OOM，并退出vm，如需处理，则保持这些新生代对象不动；</p>
<p><strong>新生代可用GC-PS</strong></p>
<p>完整内存分配策略<br>1）先在TLAB上分配，分配失败则直接在eden上分配；</p>
<p>2）当eden上分配失败时，检查需要分配的大小是否 &gt;= eden space的一半，如是，则直接在老生代分配；</p>
<p>3）如分配仍然失败，且gc已超过频率，则抛出OOM；</p>
<p>4）进入基本分配策略失败的模式；</p>
<p>5）执行PS GC，在eden上分配；</p>
<p>6）执行非最大压缩的full gc，在eden上分配；</p>
<p>7）在旧生代上分配；</p>
<p>8）执行最大压缩full gc，在eden上分配；</p>
<p>9）在旧生代上分配；</p>
<p>10）如还失败，回到2。</p>
<p>最悲惨的情况，分配触发多次PS GC和多次Full GC，直到OOM。</p>
<p>完整内存回收策略<br>1）如gc所执行的时间超过，直接结束；</p>
<p>2）先调用invoke_nopolicy<br>    2.1 先检查是不是要尝试scavenge；<br>    2.1.1 to space必须为空，如不为空，则返回false；<br>    2.1.2 获取之前所有minor gc晋级到old的平均大小，并对比目前eden+from已使用的大小，取更小的一个值，如老生代剩余空间小于此值，则返回false，如大于则返回true；<br>    2.2 如不需要尝试scavenge，则返回false，否则继续；<br>    2.3 多线程扫描活的对象，并基亍copying算法回收，回收时相应的晋升对象到旧生代；<br>    2.4 如UseAdaptiveSizePolicy，那么重新计算to space和tenuringThreshold的值，并调整。</p>
<p>3）如invoke_nopolicy返回的是false，或之前所有minor gc晋级到老生代的平均大小 &gt; 旧生代的剩余空间，那么继续下面的步骤，否则结束；</p>
<p>4）如UseParallelOldGC，则执行PSParallelCompact，如不是UseParallelOldGC，则执行PSMarkSweep。</p>
<p><strong>老生代并行CMS GC：</strong></p>
<p>优缺点：</p>
<ol>
<li>大部分时候和应用并发进行，因此只会造成很短的暂停时间；</li>
<li>浮动垃圾，没办法，所以内存空间要稍微大一点；</li>
<li>内存碎片，-XX:+UseCMSCompactAtFullCollection 来解决；</li>
<li>争抢CPU，这GC方式就这样；</li>
<li>多次remark，所以总的gc时间会比并行的长；</li>
<li>内存分配，free list方式，so性能稍差，对minor GC会有一点影响；</li>
<li>和应用并发，有可能分配和回收同时，产生竞争，引入了锁，JVM分配优先。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java设计模式(一)]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/24/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/"/>
    <id>http://www.chenbaocheng.com/2015/06/24/Java设计模式(一)/</id>
    <published>2015-06-24T07:13:11.000Z</published>
    <updated>2015-06-24T08:09:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre><a id="more"></a>

<h4 id="设计模式的六大原则">设计模式的六大原则</h4>
<h5 id="1、开闭原则（Open_Close_Principle）">1、开闭原则（Open Close Principle）</h5>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h5 id="2、里氏代换原则（Liskov_Substitution_Principle）">2、里氏代换原则（Liskov Substitution Principle）</h5>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<h5 id="3、依赖倒转原则（Dependence_Inversion_Principle）">3、依赖倒转原则（Dependence Inversion Principle）</h5>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<h5 id="4、接口隔离原则（Interface_Segregation_Principle）">4、接口隔离原则（Interface Segregation Principle）</h5>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<h5 id="5、迪米特法则（最少知道原则）（Demeter_Principle）">5、迪米特法则（最少知道原则）（Demeter Principle）</h5>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h5 id="6、合成复用原则（Composite_Reuse_Principle）">6、合成复用原则（Composite Reuse Principle）</h5>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RabbitMQ基本应用]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/16/RabbitMQ%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/06/16/RabbitMQ基本应用/</id>
    <published>2015-06-16T08:05:42.000Z</published>
    <updated>2015-06-17T04:32:11.000Z</updated>
    <content type="html"><![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br><a id="more"></a></p>
<h4 id="基本概念">基本概念</h4>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>消息队列服务器的实体</td>
</tr>
<tr>
<td>Exchange</td>
<td>消息交换机，它指定消息按什么规则，路由到哪个队列。如果没有队列绑定在exchange上面，那么发送到exchange上面的消息会丢失，一个exchange可以绑定多个队列，一个队列也可以被多个exchange绑定。声明一个已经存在的exchange，只是赋予不同的类型，则会出现创建错误，客户端需要删除已经存在的exchange，然后重新创建新类型的exchange。 exchange的属性，如果启用持久性，则exchange在服务重启前都有效，如果启用自动删除，则exchange在其绑定的queue都被删除后会自动删除掉自身。<br><strong>常用类型的exchange</strong>：<br><strong>direct</strong>：转发消息到routingkey指定的队列，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。<br><strong>topic</strong>：按照规则转发消息，对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”<em>”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.</em>”只匹配”abc.def”。<br><strong>fanout</strong>：转发消息到所有绑定的队列，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列载体，每个消息都会被投入到一个或多个队列。</td>
</tr>
<tr>
<td>Binding</td>
<td>绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</td>
</tr>
<tr>
<td>Routing Key</td>
<td>路由关键字，exchange根据这个关键字进行消息投递。</td>
</tr>
<tr>
<td>vhost</td>
<td>虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</td>
</tr>
<tr>
<td>producer</td>
<td>消息生产者，就是投递消息的程序。</td>
</tr>
<tr>
<td>consumer</td>
<td>消息消费者，就是接受消息的程序。</td>
</tr>
<tr>
<td>channel</td>
<td>消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</td>
</tr>
</tbody>
</table>
<h4 id="客户端消息投递流程">客户端消息投递流程</h4>
<ol>
<li>连接到消息队列服务器，打开一个channel</li>
<li>声明一个exchange，并设置相关属性</li>
<li>声明一个queue，并设置相关属性</li>
<li>使用routing key，在exchange和queue之间建立好绑定关系</li>
<li>投递消息到exchange,exchange接收到消息后，根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里</li>
</ol>
<h4 id="rabbitmqctl">rabbitmqctl</h4>
<pre><code>rabbitmqctl [-<span class="keyword">n</span> &lt;node&gt;] [-<span class="keyword">q</span>] &lt;<span class="keyword">command</span>&gt; [&lt;<span class="keyword">command</span> <span class="keyword">options</span>&gt;] 
-<span class="keyword">n</span> node 默认node名称是<span class="string">"rabbit@server"</span>，如果你的主机明是<span class="string">'server.example.com'</span>，那么node名称是<span class="string">'rabbit@server'</span>。
-<span class="keyword">q</span> 安静输出模式，信息会被禁止输出
</code></pre><h4 id="[_command_]">[ command ]</h4>
<p><strong>基本的管理功能</strong></p>
<pre><code>stop [&lt;pid_file&gt;]
<span class="preprocessor">#停止在erlang node上运行的rabbitmq，会使rabbitmq停止</span>

stop_app 
<span class="preprocessor">#停止erlang node上的rabbitmq的应用，但是erlang node还是会继续运行</span>

start_app
<span class="preprocessor">#启动erlan node上的rabbitmq的应用</span>

wait &lt;pid_file&gt;
<span class="preprocessor">#等待rabbitmq服务启动</span>

reset
<span class="preprocessor">#初始化node状态，会从集群中删除该节点，从管理数据库中删除所有数据，例如vhosts等等。在初始化之前rabbitmq的应用必须先停止</span>

force_reset
<span class="preprocessor">#无条件的初始化node状态</span>

rotate_logs &lt;suffix&gt;
<span class="preprocessor">#轮转日志文</span>
</code></pre><p><strong>cluster管理</strong></p>
<pre><code>join_cluster &lt;clusternode&gt; [--ram]  
<span class="preprocessor">#clusternode表示node名称，--ram表示node以ram node加入集群中。默认node以disc node加入集群，在一个node加入cluster之前，必须先停止该node的rabbitmq应用，即先执行stop_app。</span>

cluster_status  
<span class="preprocessor">#显示cluster中的所有node</span>

change_cluster_node_type disc | ram  
<span class="preprocessor">#改变一个cluster中node的模式，该节点在转换前必须先停止，不能把一个集群中唯一的disk node转化为ram node</span>

forget_cluster_node [--offline]  
<span class="preprocessor">#远程移除cluster中的一个node，前提是该node必须处于offline状态，如果是online状态，则需要加--offline参数。</span>

update_cluster_nodes clusternode   

sync_queue queue  
<span class="preprocessor">#同步镜像队列</span>

cancel_sync_queue queue    
</code></pre><p><strong>用户管理</strong></p>
<pre><code>add_user <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;password&gt;</span>  
<span class="comment">#在rabbitmq的内部数据库添加用户</span>

delete_user <span class="variable">&lt;username&gt;</span>  
<span class="comment">#删除一个用户</span>

change_password <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;newpassword&gt;</span>  
<span class="comment">#改变用户密码  \\改变web管理登陆密码</span>

clear_password <span class="variable">&lt;username&gt;</span> 
<span class="comment">#清除用户密码，禁止用户登录</span>

set_user_tags <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;tag&gt;</span> ...
<span class="comment">#设置用户tags</span>

list_users  
<span class="comment">#列出用户</span>

add_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#创建一个vhosts</span>

delete_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#删除一个vhosts</span>

list_vhosts [<span class="variable">&lt;vhostinfoitem&gt;</span> ...]  
<span class="comment">#列出vhosts</span>

set_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;user&gt;</span> <span class="variable">&lt;conf&gt;</span> <span class="variable">&lt;write&gt;</span> <span class="variable">&lt;read&gt;</span>  
<span class="comment">#针对一个vhosts 给用户赋予相关权限</span>

clear_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;username&gt;</span>  
<span class="comment">#清除一个用户对vhosts的权限</span>

list_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>]   
<span class="comment">#列出哪些用户可以访问该vhosts</span>

list_user_permissions <span class="variable">&lt;username&gt;</span>  
<span class="comment">#列出该用户的访问权限</span>

set_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;name&gt;</span> <span class="variable">&lt;value&gt;</span>
<span class="comment">#</span>

clear_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;key&gt;</span>
<span class="comment">#</span>

list_parameters [-p <span class="variable">&lt;vhostpath&gt;</span>]
<span class="comment">#</span>
</code></pre><p><strong>policy管理，策略用来控制和修改queues和exchange在集群中的行为，策略可以应用到vhost</strong></p>
<pre><code>set_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] [--priority <span class="variable">&lt;priority&gt;</span>] [--apply-to <span class="variable">&lt;apply-to&gt;</span>]  
<span class="variable">&lt;name&gt;</span> <span class="variable">&lt;pattern&gt;</span> <span class="variable">&lt;definition&gt;</span>    
<span class="comment">#name 策略名称，pattern  正则表达式，用来匹配资源，符合的就会应用设置的策略，apply-to 表示策略应用到什么类型的地方，一般有queues、exchange和all，默认是all。priority 是个整数优先级，definition 是json格式设置的策略。</span>

clear_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;name&gt;</span>  
<span class="comment">#清除一个策略</span>

list_policies [-p <span class="variable">&lt;vhostpath&gt;</span>]  
<span class="comment">#列出已有的策略</span>
</code></pre><p><strong>queues &amp;&amp; exchange状态信息</strong></p>
<pre><code>list_queues [-p &lt;vhostpath&gt;] [&lt;queueinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回queue的信息，如果省略了-p参数，则默认显示的是"/"vhosts的信息。</span>

list_exchanges [-p &lt;vhostpath&gt;] [&lt;exchangeinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回exchange的信息。</span>

list_bindings [-p &lt;vhostpath&gt;] [&lt;bindinginfoitem&gt; <span class="keyword">...</span>] 
<span class="comment">#返回绑定信息。</span>

list_connections [&lt;connectioninfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回链接信息。</span>

list_channels [&lt;channelinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回目前所有的channels。</span>

list_consumers [-p &lt;vhostpath&gt;]  
<span class="comment">#返回consumers，</span>

status  
<span class="comment">#显示broker的状态</span>

environment  
<span class="comment">#显示环境参数的信息</span>

report  
<span class="comment">#返回一个服务状态report，</span>

eval &lt;expr&gt;
</code></pre><h4 id="rabbitmq-plugins_插件的开启和关闭">rabbitmq-plugins 插件的开启和关闭</h4>
<pre><code>rabbitmq-plugins &lt;command&gt; [&lt;command options&gt;]
Commands:
list [-v] [-m] [-E] [-e] [&lt;pattern&gt;]  显示所有的的插件。-v 显示版本 -m 显示名称 -E 显示明确已经开启的 -e显示明确的和暗中开启的
enable &lt;plugin&gt; <span class="keyword">...</span>   开启一个插件
disable &lt;plugin&gt; <span class="keyword">...</span>  关闭一个插件
</code></pre><h4 id="开启rabbitmq_management,_插件在安装目录的/plugins下面">开启rabbitmq_management, 插件在安装目录的/plugins下面</h4>
<pre><code>rabbitmq-plugins enable rabbitmq_management
abbitmq_management提供一个基于HTTP的API接口，来管理和监控你的rabbitmq。他有web方式和<span class="keyword">CLI</span>方式，其实web方式是在后端调用HTTP api
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM性能监控工具]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/JVM性能监控工具/</id>
    <published>2015-06-15T07:50:07.000Z</published>
    <updated>2015-06-15T08:10:36.000Z</updated>
    <content type="html"><![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<a id="more"></a>

<hr>
<h4 id="jps_虚拟机进程状况工具">jps 虚拟机进程状况工具</h4>
<pre><code>命令格式：
<span class="tag">jps</span> <span class="attr_selector">[options]</span> <span class="attr_selector">[hostid]</span>

<span class="tag">jps</span> 可以查看通过 <span class="tag">rmi</span> 协议查询开启了 <span class="tag">rmi</span> 服务的原创虚拟机进程状态，<span class="tag">hostid</span> 是 <span class="tag">rmi</span> 注册表中注册的主机。
</code></pre><h6 id="options">options</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>只输出 LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机启动时候传递给 main 方法的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出类的全名</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时 JVM 参数</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="jstack_分析_java_堆栈">jstack 分析 java 堆栈</h4>
<p>jstack 用来生成当前时刻线程快照。</p>
<pre><code>命令格式：
jstack [ <span class="preprocessor">option</span> ] pid
jstack [ <span class="preprocessor">option</span> ] executable core
jstack [ <span class="preprocessor">option</span> ] [server-id@]remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jstat_虚拟机统计信息监视工具">jstat 虚拟机统计信息监视工具</h4>
<p>jstat 可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、 JIT 编译等运行数据。</p>
<pre><code>命令格式：
<span class="tag">jstat</span> <span class="attr_selector">[option vmid [interval]</span> <span class="attr_selector">[count]</span>]
</code></pre><h6 id="option">option</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总看见以及类装载消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视 java 堆状况，包括 eden 区、两个 survivor 区、年老代、永久代等的容量、已用空间、gc 时间合计等</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>内容与 -gc 基本相同，输出主要关注 java 堆各个区使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>内容与 -gc 基本相同，关注已使用区域占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>内容与 -gcutil 一样，并且多输出导致上一次 gc 产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>与 -gcnew 相同，主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出 JIT 编译器编译过的方法、耗时等信息</td>
</tr>
</tbody>
</table>
<h6 id="-gcutil_所产生的内容：">-gcutil 所产生的内容：</h6>
<pre><code>S0、S1 分别代表了 Survivor0 和 Survivor1;
<span class="keyword">E</span> 代表 Eden 区;
<span class="keyword">O</span> 代表老年区;
P 代表永久代;
YGC 代表 Young GC 的次数;
YGCT 代表时间
</code></pre><hr>
<h4 id="jinfo_查看_java_配置信息工具">jinfo 查看 java 配置信息工具</h4>
<pre><code>命令格式：
jinfo [ <span class="preprocessor">option</span> ] pid
jinfo [ <span class="preprocessor">option</span> ] executable core
jinfo [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jmap_生产_java_内存_dump">jmap 生产 java 内存 dump</h4>
<p>jmap 除了可以生成 dump 文件外，还可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率和当前用的是哪种收集器等。</p>
<pre><code>命令格式：
jmap [ <span class="preprocessor">option</span> ] pid
jmap [ <span class="preprocessor">option</span> ] executable core
jmap [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><h6 id="option-1">option</h6>
<pre><code>-<span class="ruby">heap
</span>-<span class="ruby">permstat</span>
</code></pre><hr>
<h4 id="jhat_虚拟机堆快照分析工具">jhat 虚拟机堆快照分析工具</h4>
<p>我们可以使用 jhat 来分析 jmap 生成的 dump 文件。默认会开 7000 端口进行 web 访问。一般不使用这个命令来分析，会使用专业的工具来分析 dump 文件，如 eclipse memory analyzer 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X下使用 Charles 进行抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/Mac-OS-X%E4%B8%8B%E4%BD%BF%E7%94%A8-Charles-%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/Mac-OS-X下使用-Charles-进行抓包/</id>
    <published>2015-06-15T07:14:12.000Z</published>
    <updated>2015-06-15T07:40:25.000Z</updated>
    <content type="html"><![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">http://www.charlesproxy.com/</a></p>
<h4 id="2、启动_Charles，支持正版，如需破解请自行搜索">2、启动 Charles，支持正版，如需破解请自行搜索</h4>
<h4 id="3、手机设置代理,_以_iPhone_为例">3、手机设置代理, 以 iPhone 为例</h4>
<p>设置-无线局域网-选择已连接的局域网-HTTP代理-手动，服务器：你电脑的 IP，端口：8888</p>
<p>第一次用手机请求网络时，Charles会提示是否允许接入，选择Allow就可以了。</p>
<p>如果是 HTTPS 抓包，需要安装证书，证书地址：<a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" t]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS环境使用wireshark抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/07/MacOS%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8wireshark%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/05/07/MacOS环境使用wireshark抓包/</id>
    <published>2015-05-07T04:17:31.000Z</published>
    <updated>2015-05-07T04:47:46.000Z</updated>
    <content type="html"><![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p><a id="more"></a></p>
<h5 id="端口过滤">端口过滤</h5>
<pre><code><span class="comment">#tcp</span>
tcp.<span class="variable">port =</span>= <span class="number">80</span>
tcp.<span class="variable">dstport =</span>= <span class="number">80</span>
tcp.<span class="variable">srcport =</span>= <span class="number">80</span>
<span class="comment">#udp</span>
udp.<span class="variable">port =</span>= <span class="number">80</span>
udp.<span class="variable">dstport =</span>= <span class="number">80</span>
udp.<span class="variable">srcport =</span>= <span class="number">80</span>
</code></pre><h5 id="协议过滤">协议过滤</h5>
<pre><code><span class="preprocessor">#支持的协议</span>
udp
arp
icmp
http
smtp
ftp
dns
msnms
ip
ssl
<span class="preprocessor">#例如过滤协议为不是 UDP 的请求</span>
!udp
</code></pre><h5 id="包长度过滤：">包长度过滤：</h5>
<pre><code><span class="preprocessor">#30 = udp本身固定长度8 + 数据包长度22</span>
udp.length == <span class="number">30</span>
<span class="preprocessor">#指ip数据包长度,不包括tcp本身长度</span>
tcp.len &gt;= <span class="number">10</span> 
<span class="preprocessor">#除以太网头固定长度14,其它都算是ip.len,即从ip本身到最后</span>
ip.len == <span class="number">94</span> 
<span class="preprocessor">#整个数据包长度,从eth开始到最后</span>
frame.len == <span class="number">119</span> 
</code></pre><h5 id="HTTP模式过滤">HTTP模式过滤</h5>
<pre><code><span class="comment">#请求类型过滤</span>
http.request.<span class="keyword">method</span> == “[<span class="type">GET</span>|<span class="type">POST</span>|<span class="type">DELETE</span>|<span class="type">PUT</span>]”
<span class="comment">#请求地址过滤</span>
http.request.uri == “/resume/index”
<span class="comment">#包含 GET 字符串的</span>
http contains “<span class="type">GET</span>”
</code></pre><h5 id="多过滤条件">多过滤条件</h5>
<pre><code>#多过滤条件用  <span class="built_in">and</span> | <span class="built_in">or</span> 链接
</code></pre><h5 id="正则过滤">正则过滤</h5>
<pre><code><span class="operator">matches</span>
<span class="comment">#举个例子</span>
http <span class="operator">matches</span> “/corp/\d+/*”
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(四) Dockerfile]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/05/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-Dockerfile/"/>
    <id>http://www.chenbaocheng.com/2015/05/05/Docker学习-四-Dockerfile/</id>
    <published>2015-05-05T07:37:57.000Z</published>
    <updated>2015-05-05T08:47:33.000Z</updated>
    <content type="html"><![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p><a id="more"></a></p>
<h5 id="RUN命令">RUN命令</h5>
<pre><code><span class="comment"># RUN命令会在上面FROM指定的镜像里执行任何命令，然后提交(commit)结果。RUN是在building image时会运行的指令, 在Dockerfile中可以写多条RUN指令.</span>

RUN &lt;command&gt; (the command is run <span class="keyword">in</span> a shell - `/bin/sh -c`)
或
RUN [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span> <span class="keyword">...</span> ]  (exec form)

<span class="comment">#RUN命令等价于:</span>
docker run image command
docker commit container_id
</code></pre><h5 id="ENTRYPOINT命令">ENTRYPOINT命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>

ENTRYPOINT [<span class="string">"cmd"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span><span class="keyword">...</span>]
或
ENTRYPOINT cmd param1 param2 <span class="keyword">...</span>

<span class="comment">#举个例子</span>
cbc ~ <span class="comment"># cat Dockerfile</span>
FROM tomcat
ENTRYPOINT echo <span class="string">"Hello world!"</span>

cbc ~ <span class="comment"># docker run 62fda5e450d5</span>
Hello world!
</code></pre><h5 id="CMD命令">CMD命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>
CMD [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>] (like <span class="operator">an</span> exec, preferred form)
或
CMD [<span class="string">"param1"</span>,<span class="string">"param2"</span>] (<span class="keyword">as</span> default parameters <span class="built_in">to</span> ENTRYPOINT)
或
CMD <span class="command"><span class="keyword">command</span> <span class="title">param1</span> <span class="title">param2</span> (<span class="title">as</span> <span class="title">a</span> <span class="title">shell</span>)</span>
</code></pre><h6 id="#CMD和ENTRYPOINT是在运行container时会运行的指令,_都只能写一条,_如果写多条,_只有最后一条生效。CMD在运行时会被command覆盖,_ENTRYPOINT不会被运行时的command覆盖,_如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image,_例如apache,_mysql等-_在使用这种image启动container时,_自动启动相关服务-下面的示例_psql_会覆盖_Dockerfile_里的_CMD">#CMD和ENTRYPOINT是在运行container时会运行的指令, 都只能写一条, 如果写多条, 只有最后一条生效。CMD在运行时会被command覆盖, ENTRYPOINT不会被运行时的command覆盖, 如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image, 例如apache, mysql等. 在使用这种image启动container时, 自动启动相关服务.下面的示例 psql 会覆盖 Dockerfile 里的 CMD</h6>
<pre><code>docker run postgre<span class="variable">s:9</span>.<span class="number">3.5</span> psql 
</code></pre><h5 id="USER命令">USER命令</h5>
<pre><code><span class="preprocessor">#指定 ENTRYPOINT 执行命令时的运行用户,下面的例子是指开机启动 NGINX 时用 www 用户身份启动。</span>

ENTRYPOINT [<span class="string">"nginx"</span>]
USER www
</code></pre><h5 id="EXPOSE命令">EXPOSE命令</h5>
<pre><code><span class="comment">#设置镜像运行时对外暴露的端口</span>
EXPOSE &lt;port&gt; [&lt;port&gt;<span class="keyword">...</span>]
</code></pre><h5 id="ENV命令">ENV命令</h5>
<pre><code><span class="input"><span class="prompt">#设置环境变量，设置后，后续的RUN命令都可以使用该环境变量
ENV &lt;key&gt;</span> &lt;value&gt;</span>
</code></pre><h5 id="ADD命令">ADD命令</h5>
<pre><code><span class="input"><span class="prompt">#从src复制文件到容器的dest路径。src可以是文件、目录或一个远程url。
ADD &lt;src&gt;</span> &lt;dest&gt;</span>
</code></pre><h5 id="VOLUME命令">VOLUME命令</h5>
<pre><code><span class="preprocessor">#创建一个挂载点用于共享目录</span>
VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]
</code></pre><h5 id="WORKDIR命令">WORKDIR命令</h5>
<pre><code><span class="preprocessor">#为RUN, CMD, ENTRYPOINT命令设置当前工作路径</span>
WORKDIR /path/to/workdir
</code></pre><h5 id="ONBUILD命令">ONBUILD命令</h5>
<pre><code><span class="preprocessor">#ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(三) Docker镜像和容器的常用操作]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%89-Docker%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/</id>
    <published>2015-04-30T08:06:29.000Z</published>
    <updated>2015-04-30T10:07:26.000Z</updated>
    <content type="html"><![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre><a id="more"></a>

<h5 id="查找镜像">查找镜像</h5>
<pre><code>这里我们是找一个名为tengine的镜像，tengine是淘宝版的nginx

cbc ~ <span class="comment"># docker search tengine</span>
NAME                           DESCRIPTION   STARS     OFFICIAL   AUTOMATED
mimosa/tengine                               <span class="number">1</span>                    [OK]
netengine/renderer-nginx                     <span class="number">1</span>                    [OK]
utgard/tengine                               <span class="number">0</span>                    [OK]
sugamele/tengine               Tengine       <span class="number">0</span>
vpanton/docker-tengine-dyups                 <span class="number">0</span>                    [OK]
hyperboloide/tengine                         <span class="number">0</span>
guilhem30/updatengine                        <span class="number">0</span>                    [OK]
</code></pre><h5 id="获取镜像">获取镜像</h5>
<pre><code>cbc ~ <span class="comment"># docker pull mimosa/tengine</span>
<span class="constant">Pulling</span> repository mimosa/tengine
<span class="symbol">f614dc8befa6:</span> <span class="constant">Pulling</span> dependent layers
<span class="number">511136</span><span class="symbol">ea3c5a:</span> <span class="constant">Download</span> complete
<span class="number">5</span><span class="symbol">e66087f3ffe:</span> <span class="constant">Downloading</span> <span class="number">17.96</span> <span class="constant">MB</span>

<span class="comment"># 下载过程中，会输出获取镜像的每一层信息。</span>
<span class="comment"># 你可以按照下面的格式从指定注册服务器的仓库下载相应标记的镜像：</span>
docker pull 注册服务器地址[<span class="symbol">:</span>端口号]/仓库名<span class="symbol">:TAG</span>名称
</code></pre><h4 id="删除镜像">删除镜像</h4>
<pre><code>docker rmi ae0c2d0bdc10
<span class="preprocessor"># 移除镜像前，先移除依赖该镜像的容器</span>
</code></pre><h4 id="使用镜像创建一个容器">使用镜像创建一个容器</h4>
<pre><code>cbc ~ # docker run -itd --name tengine01 mimosa/tengine /bin/bash
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -t 让docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入</span>
<span class="preprocessor"># -i 让容器的标准输入保持打开</span>
<span class="preprocessor"># -d 让容器在后台以守护进程（Daemonized）形式运行</span>
<span class="preprocessor"># --name 给容器起个名儿</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互    </span>
</code></pre><h4 id="导出镜像到本地文件">导出镜像到本地文件</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker save -o tengine.tar mimosa/tengine
</code></pre><h4 id="从本地文件导入镜像">从本地文件导入镜像</h4>
<pre><code>docker <span class="built_in">load</span> <span class="comment">--input tengine.tar</span>
或者
docker <span class="built_in">load</span> &lt; tengine.tar
</code></pre><h4 id="查看容器状态">查看容器状态</h4>
<pre><code>cbc ~ <span class="comment"># docker ps -a</span>
CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS                      PORTS               NAMES
ca98201350dd        mimosa/tengine:latest   <span class="string">"/bin/bash"</span>         <span class="number">19</span> minutes ago      Up <span class="number">9</span> minutes                <span class="number">443</span>/tcp, <span class="number">80</span>/tcp     grave_albattani
b02c528c3cad        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (<span class="number">127</span>) <span class="number">2</span> hours ago                        furious_einstein
cf769788d09e        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (-<span class="number">1</span>) <span class="number">2</span> hours ago                         agitated_mclean
f706bbb258a1        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">3</span> hours ago         Exited (<span class="number">130</span>) <span class="number">3</span> hours ago                        goofy_yonath
<span class="number">574871</span>d84dc2        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">127</span>) <span class="number">5</span> months ago                       cocky_wilson
<span class="number">47381902</span><span class="built_in">cd</span>50        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         mad_feynman
ee19f69f978c        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         high_bohr
a7e4a6d0c994        ae0c2d0bdc10            <span class="string">"/usr/bin/"</span>         <span class="number">5</span> months ago                                                        drunk_pike
ad418b05441f        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago                                                        sick_colden
dffb9f3f6677        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         determined_shockley
e9297baee616        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         thirsty_pare
</code></pre><h4 id="停止容器">停止容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker stop ca98201350dd 
</code></pre><h4 id="重启容器">重启容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker restart ca98201350dd
ca98201350dd
</code></pre><h4 id="从终止状态启动一个容器">从终止状态启动一个容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker start ca98201350dd
ca98201350dd 
</code></pre><h4 id="进入一个运行状态的容器">进入一个运行状态的容器</h4>
<pre><code>cbc ~ <span class="comment"># docker attach ca98201350dd</span>
[ root<span class="variable">@ca98201350dd</span><span class="symbol">:/etc/nginx</span> ]$
</code></pre><h4 id="删除容器">删除容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker rm 4d72d9a0066d
4d72d9a0066d 
</code></pre><h4 id="导出容器">导出容器</h4>
<pre><code><span class="input"><span class="prompt">docker export ca98201350dd &gt;</span> tengine.dock.tar</span>
</code></pre><h4 id="导入容器快照">导入容器快照</h4>
<pre><code>cbc ~ <span class="comment"># cat tengine.dock.tar | docker import - cbc009/tengine</span>
<span class="number">67e225223716</span>ff791c78bcc546695e530a37358e0c86b72a7a5bff2fbfbb6228

或从<span class="built_in">URL</span>导入

docker import <span class="built_in">URL</span> REPOSITORY

查看一下结果：
cbc ~ <span class="comment"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
cbc009/tengine      latest              <span class="number">67e225223716</span>        <span class="number">2</span> minutes ago       <span class="number">593.5</span> MB
</code></pre><h4 id="外部访问容器，对容器网络端口映射">外部访问容器，对容器网络端口映射</h4>
<pre><code>cbc ~ # docker run -itdP mimosa/tengine /bin/bash
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -P Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口</span>
<span class="preprocessor"># -p 参数小写的p可以手动指定要映射的端口。一个指定端口只可以绑定一个容器，也可以指定端口类型。支持的格式有：ip:hostPort:containerPort[/protocol] | ip::containerPort[/protocol] | hostPort:containerPort[/protocol]</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互</span>

<span class="preprocessor"># 用 docker ps -l查看最后一个被创建的容器，访问49154端口可以看到 tengine 的欢迎页。</span>
<span class="preprocessor"># 现在我可以通过工作电脑访问容器的物理机：http://192.168.11.185:49154/</span>
cbc ~ # docker ps -l
CONTAINER<span class="constant"> ID </span>      <span class="constant"> IMAGE </span>                 <span class="constant"> COMMAND </span>           <span class="constant"> CREATED </span>           <span class="constant"> STATUS </span>            <span class="constant"> PORTS </span>                                          NAMES
<span class="number">1</span>dd4e24df270        mimosa/tengine:latest   <span class="string">"nginx"</span>             <span class="number">7</span> minutes ago       Up <span class="number">7</span> minutes        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49153</span>-&gt;<span class="number">443</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49154</span>-&gt;<span class="number">80</span>/tcp   naughty_hypatia
</code></pre><h4 id="查看网络端口映射情况">查看网络端口映射情况</h4>
<pre><code>docker <span class="keyword">port</span> <span class="number">1</span>dd4e24df270 <span class="number">80</span>
</code></pre><p>至此镜像和容器的基本操作学习完了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(二) 安装与配置]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-二-安装与配置/</id>
    <published>2015-04-30T07:50:46.000Z</published>
    <updated>2015-04-30T08:01:51.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p><a id="more"></a>    </p>
<pre><code><span class="preprocessor">#安装</span>
yum install docker-io
</code></pre><h4 id="CentOS_7_下安装Docker服务">CentOS 7 下安装Docker服务</h4>
<p>Centos 7 开始 CentOS-Extras 库自带 Docker，所以安装会相对更简单.</p>
<pre><code>yum <span class="operator"><span class="keyword">install</span> docker</span>
</code></pre><h4 id="启动_Docker">启动 Docker</h4>
<pre><code><span class="class"><span class="keyword">service</span> <span class="title">docker</span> start</span>
</code></pre><h4 id="开机启动">开机启动</h4>
<pre><code>chkconfig docker <span class="command"><span class="keyword">on</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(一) Docker基础]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%80-Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-一-Docker基础/</id>
    <published>2015-04-30T07:28:12.000Z</published>
    <updated>2015-04-30T08:02:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br><a id="more"></a><br><strong>container,容器</strong>，容器是从镜像创建的运行实例，一台物理机可以运行 成百上千个容器，容器之间是相互隔离的。容器可以通过相关命令启动，开始，停止，删除。</p>
<p><strong>repository,仓库</strong>，分为公共和私有两种。默认是从公共仓库获取 image.</p>
<h5 id="下面有一个表格对比了传统虚拟机和docker的区别：">下面有一个表格对比了传统虚拟机和docker的区别：</h5>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">容器</th>
<th style="text-align:right">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:right">分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td style="text-align:center">通常为MB</td>
<td style="text-align:right">通常为GB</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:right">弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td style="text-align:center">单机支持上千容器</td>
<td style="text-align:right">一般几十个虚拟机</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux开机获取IP发送到指定邮箱]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Linux%E5%BC%80%E6%9C%BA%E8%8E%B7%E5%8F%96IP%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Linux开机获取IP发送到指定邮箱/</id>
    <published>2015-04-30T05:20:19.000Z</published>
    <updated>2015-04-30T05:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br><a id="more"></a><br>2、修改配置文件</p>
<p>vim  /etc/mail.rc</p>
<p>添加如下内容：<br>set from=xxxxxx@163.com smtp=smtp.163.com smtp-auth-user={username} smtp-auth-password={password} smtp-auth=login</p>
<p>3、配置开机发邮件</p>
<p>vim /etc/rc.local</p>
<p>ifconfig | mail -s “重启开机邮件 - 最新 IP” xxxx@xxxx.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br>]]>
    
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 github 放一个spring-boot-jpa DEMO]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/29/%E5%9C%A8-github-%E5%8F%91%E4%B8%80%E4%B8%AAspring-boot-jpa-DEMO/"/>
    <id>http://www.chenbaocheng.com/2015/04/29/在-github-发一个spring-boot-jpa-DEMO/</id>
    <published>2015-04-29T08:58:12.000Z</published>
    <updated>2015-05-19T08:02:06.000Z</updated>
    <content type="html"><![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entity，声明 Dao，在 Service 层包装一下业务, controller 里去做 WEB 页面展示的准备工作就好了。</p>
<p>这个DEMO主要演示基于 spring boot 的项目开发，如何使用 jpa 对数据库 CRUD 操作，如何用 freemarker 展示页面。</p>
<p>项目地址：<a href="https://github.com/cbc009/spring-boot-jpa" target="_blank" rel="external">spring-boot-jpa DEMO</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entit]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java : Unsupported major.minor version 51.0解决方法]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/"/>
    <id>http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/</id>
    <published>2015-04-23T06:44:35.000Z</published>
    <updated>2015-04-28T03:53:43.000Z</updated>
    <content type="html"><![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
<a id="more"></a>

<p>51.0是对应JDK1.7, 看一下当前的 java 版本什么呢？<br>$ java -version<br>java version “1.7.0_79”<br>Java(TM) SE Runtime Environment (build 1.7.0_79-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</p>
<p>看起来JDK没问题。</p>
<p>那会不会是 intellij 默认用1.6启动的呢？<br>$ vim /Applications/IntelliJ\ IDEA\ 14.app/Contents/Info.plist</p>
<p>100、101行：<br>      <key>JVMVersion</key><br>      <string>1.6,1.7<em></em></string><br>看起来像是这里的问题，修改一下，把1.6去掉试试:<br>      <key>JVMVersion</key><br>      <string>1.7</string></p>
<p>保存，重新启动Intellij Idea, 出现提示:您要应用程序“Intellij Idea 14.app”接受传入网络连接吗?这是由于修改应用内文件导致Apple 签名失效了。简单粗暴解决一下，进入系统管理-关闭防火墙即可。</p>
<p>重新启动软件，一切正常了~~~ Intellij idea 为什么不默认使用系统 JDK 版本呢？或者给用户一个修改 JDK 版本的界面？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[oh-my-zsh替代品prezto]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/02/oh-my-zsh%E6%9B%BF%E4%BB%A3%E5%93%81prezto/"/>
    <id>http://www.chenbaocheng.com/2015/04/02/oh-my-zsh替代品prezto/</id>
    <published>2015-04-02T07:46:44.000Z</published>
    <updated>2015-04-02T10:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre><a id="more"></a>

<p><br>3、创建Zsh配置文件</p>
<pre><code>setopt EXTENDED_GLOB
 <span class="keyword">for</span> rcfile <span class="keyword">in</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>"</span>/.zprezto/runcoms/^README.md(.N); <span class="keyword">do</span>
   ln <span class="operator">-s</span> <span class="string">"<span class="variable">$rcfile</span>"</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.<span class="variable">${rcfile:t}</span>"</span>
 <span class="keyword">done</span>
</code></pre><p><br>4、设置 Zsh 为默认shell</p>
<pre><code>chsh <span class="operator">-s</span> /bin/zsh
</code></pre><p><br>5、新开窗口体验~~~</p>
<h6 id="关于更新"><br>关于更新</h6>
<pre><code><span class="keyword">cd</span>  ~/.zprezto
git pull &amp;&amp; git submodule <span class="keyword">update</span> --init --recursive
</code></pre><h6 id="oh-my-zsh的_z_命令替代品_fasd"><br>oh-my-zsh的 z 命令替代品 fasd</h6>
<pre><code>brew install fasd

<span class="keyword">vim</span> ~/.zshrc
<span class="built_in">eval</span> <span class="string">"$(fasd --init auto)"</span>

<span class="keyword">vim</span>  ~/.zpreztorc
zstyle <span class="string">':prezto:load'</span> pmodule \
    <span class="string">'environment'</span> \
    <span class="string">'terminal'</span> \
    <span class="string">'editor'</span> \
    <span class="string">'history'</span> \
    <span class="string">'directory'</span> \
    <span class="string">'spectrum'</span> \
    <span class="string">'utility'</span> \
    <span class="string">'completion'</span> \
    <span class="string">'history'</span> \
    <span class="string">'history-substring-search'</span> \
    <span class="string">'prompt'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre>]]>
    
    </summary>
    
      <category term="效率" scheme="http://www.chenbaocheng.com/categories/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS网络诊断命令]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/26/MacOS%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.chenbaocheng.com/2015/02/26/MacOS网络诊断命令/</id>
    <published>2015-02-26T06:54:18.000Z</published>
    <updated>2015-04-28T03:55:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活动网卡</span>
ifconfig

<span class="preprocessor">#查看所有网卡信息，包括活动、非活动网卡</span>
ifconfig -a

<span class="preprocessor">#查看某个网卡的信息</span>
ifconfig eth0

<span class="preprocessor">#配置某个网卡的ip地址 格式：ifconfig  ethx IP/MASK</span>
ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.20</span>/<span class="number">16</span>
</code></pre><h3 id="路由">路由</h3>
<pre><code><span class="preprocessor">#显示路由表</span>
netstat -nr

<span class="preprocessor">#追踪到达IP目的地的全程路由</span>
traceroute nis.nsf.net
</code></pre><h3 id="网络监听_-_tcpdump">网络监听 - tcpdump</h3>
<pre><code><span class="built_in">sudo</span> tcpdump -i en0

监听en0接口的所有通信

<span class="built_in">sudo</span> tcpdump -A -i en0 

用ASCII显示en0接口的通信内容
<span class="built_in">sudo</span> tcpdump -i en0 <span class="string">'port 8080'</span>

显示en0接口的<span class="number">8080</span>端口的通信

<span class="built_in">sudo</span> tcpdump -i eth1 src <span class="number">192.168</span>.<span class="number">1.200</span>

显示eth1接口，来自<span class="number">192.168</span>.<span class="number">1.200</span>的通信

<span class="built_in">sudo</span> tcpdump -i eth1 dst <span class="number">192.168</span>.<span class="number">1.101</span> and port <span class="number">80</span>

显示eth1接口<span class="number">80</span>端口，目的地为<span class="number">192.168</span>.<span class="number">1.101</span>的通信

<span class="built_in">sudo</span> tcpdump -w record.pcap -i lo0

将lo0接口的通信存入文件record.pcap
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活]]>
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS管理多个JDK版本]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/23/Mac-OS%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAJDK%E7%89%88%E6%9C%AC/"/>
    <id>http://www.chenbaocheng.com/2015/02/23/Mac-OS管理多个JDK版本/</id>
    <published>2015-02-22T18:36:02.000Z</published>
    <updated>2015-02-22T21:01:19.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre><a id="more"></a>

<h5 id="配置">配置</h5>
<pre><code>jenv <span class="keyword">add</span> /System/<span class="keyword">Library</span>/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">7.0</span>_60.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">8.0</span>_05.jdk/Contents/Home/
 jenv enable-plugin export
</code></pre><h5 id="使用">使用</h5>
<pre><code><span class="comment">'显示全部版本</span>
 jenv versions 

 <span class="comment">' 设置默认版本</span>
 jenv <span class="keyword">global</span> oracle64-<span class="number">1.6</span><span class="number">.0</span><span class="number">.65</span>

 <span class="comment">' 设置目录对应的JDK版本。在目录下创建.java-version文件记录版本号</span>
 jenv local <span class="number">1.8</span>

 <span class="comment">' 撤销上一步操作</span>
 jenv local --unset
</code></pre><h5 id="插件">插件</h5>
<pre><code>jenv plugins

 ant
 <span class="keyword">export</span>
 golo
 gradle
 grails
 groovy
 lein
 maven
 sbt
 scala
 springboot
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[50道Java线程面试题]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/22/50%E9%81%93Java%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.chenbaocheng.com/2015/02/22/50道Java线程面试题/</id>
    <published>2015-02-22T14:16:07.000Z</published>
    <updated>2015-02-22T17:35:31.000Z</updated>
    <content type="html"><![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
<a id="more"></a>

<h5 id="4)_用Runnable还是Thread？">4) 用Runnable还是Thread？</h5>
<p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。<a href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="6)_Thread_类中的start()_和_run()_方法有什么区别？">6) Thread 类中的start() 和 run() 方法有什么区别？</h5>
<p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。<a href="http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html" target="_blank" rel="external">更多讨论</a></p>
<h5 id="7)_Java中Runnable和Callable有什么不同？">7) Java中Runnable和Callable有什么不同？</h5>
<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h5 id="8)_Java中CyclicBarrier_和_CountDownLatch有什么不同？">8) Java中CyclicBarrier 和 CountDownLatch有什么不同？</h5>
<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。<a href="http://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html" target="_blank" rel="external">点此查看更多信息和示例代码</a>。</p>
<h5 id="9)_Java内存模型是什么？">9) Java内存模型是什么？</h5>
<p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>可传递性<br>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
<h5 id="10)_Java中的volatile_变量是什么？">10) Java中的volatile 变量是什么？</h5>
<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。<a href="http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html" target="_blank" rel="external">查看更多volatile的相关内容</a>。</p>
<h5 id="11)_什么是线程安全？Vector是一个线程安全类吗？_（详见这里)">11) 什么是线程安全？Vector是一个线程安全类吗？ （详见这里)</h5>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h5 id="12)_Java中什么是竞态条件？_举个例子说明。">12) Java中什么是竞态条件？ 举个例子说明。</h5>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，<a href="http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html" target="_blank" rel="external">详见答案</a>。</p>
<h5 id="13)_Java中如何停止一个线程？">13) Java中如何停止一个线程？</h5>
<p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。<a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="external">查看示例代码</a>。</p>
<h5 id="14)_一个线程运行时发生异常会怎样？">14) 一个线程运行时发生异常会怎样？</h5>
<p>这是我在一次面试中遇到的一个<a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="external">很刁钻的Java面试题</a>, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h5 id="15）_如何在两个线程间共享数据？">15） 如何在两个线程间共享数据？</h5>
<p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《<a href="http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html" target="_blank" rel="external">Java线程间通信</a>》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<h5 id="16)_Java中notify_和_notifyAll有什么区别？">16) Java中notify 和 notifyAll有什么区别？</h5>
<p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。<a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="external">更详细的资料和示例代码</a>。</p>
<h5 id="17)_为什么wait,_notify_和_notifyAll这些方法不在thread类里面？">17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h5>
<p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以<a href="http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html" target="_blank" rel="external">查看这篇文章</a>了解更多。</p>
<h5 id="18)_什么是ThreadLocal变量？">18) 什么是ThreadLocal变量？</h5>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。<a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="external">查看答案</a>了解更多。</p>
<h5 id="19)_什么是FutureTask？">19) 什么是FutureTask？</h5>
<p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h5 id="20)_Java中interrupted_和_isInterruptedd方法的区别？">20) Java中interrupted 和 isInterruptedd方法的区别？</h5>
<p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="external">静态方法</a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h5 id="21)_为什么wait和notify方法要在同步块中调用？">21) 为什么wait和notify方法要在同步块中调用？</h5>
<p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h5 id="22)_为什么你应该在循环中检查等待条件?">22) 为什么你应该在循环中检查等待条件?</h5>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h5 id="23)_Java中的同步集合与并发集合有什么区别？">23) Java中的同步集合与并发集合有什么区别？</h5>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见<a href="http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="24）_Java中堆和栈有什么不同？">24） Java中堆和栈有什么不同？</h5>
<p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。<br>更多内容详见<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="25）_什么是线程池？_为什么要使用它？">25） 什么是线程池？ 为什么要使用它？</h5>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">更多详细内容</a>。</p>
<h5 id="26）_如何写代码来解决生产者消费者问题？">26） 如何写代码来解决生产者消费者问题？</h5>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它<a href="http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="27）_如何避免死锁？">27） 如何避免死锁？</h5>
<p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节<a href="http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="28)_Java中活锁和死锁有什么区别？">28) Java中活锁和死锁有什么区别？</h5>
<p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h5 id="29）_怎么检测一个线程是否拥有锁？">29） 怎么检测一个线程是否拥有锁？</h5>
<p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多，<a href="http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="30)_你如何在Java中获取线程堆栈？">30) 你如何在Java中获取线程堆栈？</h5>
<p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h5 id="31)_JVM中哪个参数是用来控制线程的栈堆栈小的">31) JVM中哪个参数是用来控制线程的栈堆栈小的</h5>
<p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看<a href="http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html" target="_blank" rel="external">JVM配置列表</a>来了解这个参数的更多信息。</p>
<h5 id="32）_Java中synchronized_和_ReentrantLock_有什么不同？">32） Java中synchronized 和 ReentrantLock 有什么不同？</h5>
<p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。<a href="http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html" target="_blank" rel="external">查看这篇文章了解更多</a></p>
<h5 id="33）_有三个线程T1，T2，T3，怎么确保它们按顺序执行？">33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h5>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。<a href="http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html" target="_blank" rel="external">查看这篇文章了解更多</a>。</p>
<h5 id="34)_Thread类中的yield方法有什么作用？">34) Thread类中的yield方法有什么作用？</h5>
<p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。<a href="http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html" target="_blank" rel="external">查看更多yield方法的相关内容</a>。</p>
<h5 id="35）_Java中ConcurrentHashMap的并发度是什么？">35） Java中ConcurrentHashMap的并发度是什么？</h5>
<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章<a href="http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html" target="_blank" rel="external">How ConcurrentHashMap works in Java</a>。</p>
<h5 id="36）_Java中Semaphore是什么？">36） Java中Semaphore是什么？</h5>
<p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。<a href="http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="37）如果你提交任务时，线程池队列已满。会时发会生什么？">37）如果你提交任务时，线程池队列已满。会时发会生什么？</h5>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h5 id="38)_Java线程池中submit()_和_execute()方法有什么区别？">38) Java线程池中submit() 和 execute()方法有什么区别？</h5>
<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。<a href="http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="39)_什么是阻塞式方法？">39) 什么是阻塞式方法？</h5>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。<a href="http://javarevisited.blogspot.sg/2012/02/what-is-blocking-methods-in-java-and.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="40)_Swing是线程安全的吗？_为什么？">40) Swing是线程安全的吗？ 为什么？</h5>
<p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。<a href="http://javarevisited.blogspot.com/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html" target="_blank" rel="external">查看更多swing和线程安全的相关内容</a>。</p>
<h5 id="41）_Java中invokeAndWait_和_invokeLater有什么区别？">41） Java中invokeAndWait 和 invokeLater有什么区别？</h5>
<p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。<a href="http://javarevisited.blogspot.com/2011/09/invokeandwait-invokelater-swing-example.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="42)_Swing_API中那些方法是线程安全的？">42) Swing API中那些方法是线程安全的？</h5>
<p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h5 id="43)_如何在Java中创建Immutable对象？">43) 如何在Java中创建Immutable对象？</h5>
<p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章<a href="http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" target="_blank" rel="external">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p>
<h5 id="44）_Java中的ReadWriteLock是什么？">44） Java中的ReadWriteLock是什么？</h5>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h5 id="45)_多线程中的忙循环是什么?">45) 多线程中的忙循环是什么?</h5>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。<a href="http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html" target="_blank" rel="external">你可以查看这篇文章获得更多信息</a>。</p>
<h5 id="46）volatile_变量和_atomic_变量有什么不同？">46）volatile 变量和 atomic 变量有什么不同？</h5>
<p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h5 id="47)_如果同步块内的线程抛出异常会发生什么？">47) 如果同步块内的线程抛出异常会发生什么？</h5>
<p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="external">finally block</a>里释放锁实现。</p>
<h5 id="48）_单例模式的双检锁是什么？">48） 单例模式的双检锁是什么？</h5>
<p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看<a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">how double checked locking on Singleton works</a>这篇文章获得更多信息。</p>
<h5 id="49）_如何在Java中创建线程安全的Singleton？">49） 如何在Java中创建线程安全的Singleton？</h5>
<p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。<a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="50)_写出3条你遵循的多线程最佳实践">50) 写出3条你遵循的多线程最佳实践</h5>
<p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。<br>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明, <a href="http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="51)_如何强制启动一个线程？">51) 如何强制启动一个线程？</h5>
<p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h5 id="52)_Java中的fork_join框架是什么？">52) Java中的fork join框架是什么？</h5>
<p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。<a href="http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="53）_Java多线程中调用wait()_和_sleep()方法有什么不同？">53） Java多线程中调用wait() 和 sleep()方法有什么不同？</h5>
<p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<a href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<p>以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
</feed>

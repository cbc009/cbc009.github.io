<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CHENBAOCHENG.COM]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.chenbaocheng.com/"/>
  <updated>2015-07-14T06:47:26.922Z</updated>
  <id>http://www.chenbaocheng.com/</id>
  
  <author>
    <name><![CDATA[CBC]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从Centos 6.x 升级Centos7]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/14/%E4%BB%8ECentos-6-x-%E5%8D%87%E7%BA%A7Centos7/"/>
    <id>http://www.chenbaocheng.com/2015/07/14/从Centos-6-x-升级Centos7/</id>
    <published>2015-07-14T06:44:53.000Z</published>
    <updated>2015-07-14T06:47:12.000Z</updated>
    <content type="html"><![CDATA[<p>1、安装升级工具依赖的软件包</p>
<pre><code>yum -<span class="keyword">y</span> install openscap pcre-devel libxml2-devel libxslt-devel m2crypto <span class="keyword">python</span>-simplejson mod_wsgi
</code></pre><p>2、安装以下软件的最新版，可以到这里查找：<a href="http://dev.centos.org/centos/6/upg/x86_64/Packages" target="_blank" rel="external">http://dev.centos.org/centos/6/upg/x86_64/Packages</a></p>
<pre><code>rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-<span class="number">1.0</span>.<span class="number">2</span>-<span class="number">36.0</span>.<span class="number">1</span>.el6.centos.x86_64.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-contents-<span class="number">0</span>.<span class="number">5.14</span>-<span class="number">1</span>.el6.centos.noarch.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-ui-<span class="number">1.0</span>.<span class="number">2</span>-<span class="number">36.0</span>.<span class="number">1</span>.el6.centos.x86_64.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/redhat-upgrade-tool-<span class="number">0</span>.<span class="number">7.22</span>-<span class="number">3</span>.el6.centos.noarch.rpm
</code></pre><a id="more"></a>

<p>3、执行升级</p>
<pre><code><span class="comment">redhat</span><span class="literal">-</span><span class="comment">upgrade</span><span class="literal">-</span><span class="comment">tool</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">network</span> <span class="comment">7</span><span class="string">.</span><span class="comment">0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">instrepo</span> <span class="comment">http://mirrors</span><span class="string">.</span><span class="comment">sohu</span><span class="string">.</span><span class="comment">com/centos/7</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">1406/os/x86_64/</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">force</span>
</code></pre><p>升级成功后会看到消息“Finished. Reboot to start upgrade.”</p>
<p>4、重启服务器</p>
<p>重启主机后，OS将启动一个称为System Upgrade的新的grub对象，支持将所有已经通过upgrade tool下载的软件包更新。</p>
<p>5、检查系统版本， 看到版本 CentOS Linux release 7.0.1406 (Core) 证明升级成功</p>
<pre><code><span class="keyword">cat</span>  /etc/redhat-release
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>1、安装升级工具依赖的软件包</p>
<pre><code>yum -<span class="keyword">y</span> install openscap pcre-devel libxml2-devel libxslt-devel m2crypto <span class="keyword">python</span>-simplejson mod_wsgi
</code></pre><p>2、安装以下软件的最新版，可以到这里查找：<a href="http://dev.centos.org/centos/6/upg/x86_64/Packages" target="_blank" rel="external">http://dev.centos.org/centos/6/upg/x86_64/Packages</a></p>
<pre><code>rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-<span class="number">1.0</span>.<span class="number">2</span>-<span class="number">36.0</span>.<span class="number">1</span>.el6.centos.x86_64.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-contents-<span class="number">0</span>.<span class="number">5.14</span>-<span class="number">1</span>.el6.centos.noarch.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/preupgrade-assistant-ui-<span class="number">1.0</span>.<span class="number">2</span>-<span class="number">36.0</span>.<span class="number">1</span>.el6.centos.x86_64.rpm
rpm -ihv <span class="symbol">http:</span>/<span class="regexp">/dev.centos.org/centos</span><span class="regexp">/6/upg</span><span class="regexp">/x86_64/</span><span class="constant">Packages</span>/redhat-upgrade-tool-<span class="number">0</span>.<span class="number">7.22</span>-<span class="number">3</span>.el6.centos.noarch.rpm
</code></pre>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.chenbaocheng.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带web界面的Docker管理平台shipyard]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/10/Docker%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E5%B8%A6web%E7%95%8C%E9%9D%A2%E7%9A%84Docker%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0shipyard/"/>
    <id>http://www.chenbaocheng.com/2015/07/10/Docker学习-五-带web界面的Docker管理平台shipyard/</id>
    <published>2015-07-10T06:17:29.000Z</published>
    <updated>2015-07-10T09:03:17.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Shipyard</strong> 是一个管理容器、主机等资源的web图形化工具，它建立在docker集群管理工具Citadel之上。有core和extension两个版本：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>把多个Docker host上的 containers 统一管理，支持跨越多个host。</td>
</tr>
<tr>
<td>extension</td>
<td>添加了应用路由和负载均衡、集中化日志、部署等功能。</td>
</tr>
</tbody>
</table>
<a id="more"></a>

<h4 id="engine">engine</h4>
<p>一个shipyard管理的docker集群可以包含一个或多个engine，一个engine就是监听tcp端口的docker daemon。shipyard管理docker daemon、images、containers完全基于Docker API，不需要做其他的修改。另外，shipyard可以对每个engine做资源限制，包括CPU和内存；因为TCP监听相比Unix socket方式会有一定的安全隐患，所以shipyard还支持通过SSL证书与docker后台进程安全通信。</p>
<h4 id="rethinkdb">rethinkdb</h4>
<p>RethinkDB是一个shipyard项目的一个docker镜像，用来存放账号（account）、引擎（engine）、服务密钥（service key）、扩展元数据（extension metadata）等信息，但不会存储任何有关容器或镜像的内容。一般会启动一个shipyard/rethinkdb容器shipyard-rethinkdb-data来使用它的/data作为数据卷供另外rethinkdb一个挂载，专门用于数据存储。</p>
<h4 id="搭建">搭建</h4>
<p><strong> 修改配置文件</strong></p>
<pre><code>vim /etc/sysconfig/docker

<span class="preprocessor">#修改other_args值</span>
other_args=<span class="string">"-H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock"</span>

<span class="preprocessor">#重启docker后查看端口</span>
netstat -plt | grep <span class="number">4243</span>
</code></pre><p><strong>启动rethinkdb</strong></p>
<pre><code>docker pull shipyard/shipyard


docker run -<span class="keyword">it</span> -d <span class="comment">--name shipyard-rethinkdb-data \</span>
<span class="comment">--entrypoint /bin/bash shipyard/rethinkdb -l</span>

docker run -<span class="keyword">it</span> -P -d <span class="comment">--name shipyard-rethinkdb \</span>
<span class="comment">--volumes-from shipyard-rethinkdb-data shipyard/rethinkdb</span>

docker run -<span class="keyword">it</span> -p <span class="number">8080</span>:<span class="number">8080</span> -d <span class="comment">--name shipyard \</span>
<span class="comment">--link shipyard-rethinkdb:rethinkdb shipyard/shipyard</span>

<span class="built_in">URL</span>         <span class="keyword">http</span>://&lt;your-host-ip&gt;:<span class="number">8080</span>
USER        admin
PASSSWORD   shipyard
</code></pre><p><strong>shipyard-cli</strong></p>
<p>图形界面没有提供修改密码的功能，不过可以通过shipyard-cli来修改。</p>
<pre><code>docker run -ti <span class="comment">--rm shipyard/shipyard-cli</span>

docker run -<span class="keyword">it</span> shipyard/shipyard-cli

<span class="comment">#执行shipyard-cli后，通过下面的命令查看更多功能</span>
shipyard cli&gt; shipyard help
NAME:
   shipyard - manage <span class="operator">a</span> shipyard cluster

USAGE:
   shipyard [<span class="built_in">global</span> options] <span class="command"><span class="keyword">command</span> [<span class="title">command</span> <span class="title">options</span>] [<span class="title">arguments</span>...]</span>

VERSION:
   <span class="number">2.0</span><span class="number">.8</span>

COMMANDS:
   login        login <span class="built_in">to</span> <span class="operator">a</span> shipyard cluster
   change-password  update your password
   accounts     show accounts
   <span class="built_in">add</span>-account      <span class="built_in">add</span> account
   <span class="built_in">delete</span>-account   <span class="built_in">delete</span> account
   containers       list containers
   inspect      inspect container
   run          run <span class="operator">a</span> container
   stop         stop <span class="operator">a</span> container
   restart      restart <span class="operator">a</span> container
   scale        scale <span class="operator">a</span> container
   logs         show container logs
   destroy      destroy <span class="operator">a</span> container
   engines      list engines
   <span class="built_in">add</span>-engine       <span class="built_in">add</span> shipyard engine
   remove-engine    removes <span class="operator">an</span> engine
   inspect-engine   inspect <span class="operator">an</span> engine
   service-<span class="built_in">keys</span>     list service <span class="built_in">keys</span>
   <span class="built_in">add</span>-service-key  adds <span class="operator">a</span> service key
   remove-service-key   removes <span class="operator">a</span> service key
   extensions       show extensions
   <span class="built_in">add</span>-extension    <span class="built_in">add</span> extension
   remove-extension remove <span class="operator">an</span> extension
   webhook-<span class="built_in">keys</span>     list webhook <span class="built_in">keys</span>
   <span class="built_in">add</span>-webhook-key  adds <span class="operator">a</span> webhook key
   remove-webhook-key   removes <span class="operator">a</span> webhook key
   info         show cluster info
   events       show cluster events
   help, h      Shows <span class="operator">a</span> list <span class="operator">of</span> commands <span class="operator">or</span> help <span class="keyword">for</span> <span class="constant">one</span> <span class="command"><span class="keyword">command</span></span>

GLOBAL OPTIONS:
   <span class="comment">--help, -h           show help</span>
   <span class="comment">--generate-bash-completion   </span>
   <span class="comment">--version, -v        print the version   </span>
</code></pre><p><strong>修改密码</strong></p>
<pre><code>shipyard <span class="keyword">cli</span>&gt; shipyard login
<span class="label">URL:</span> http://&lt;服务器IP&gt;:<span class="number">8080</span>
<span class="label">Username:</span> admin
<span class="label">Password:</span> shipyard

shipyard <span class="keyword">cli</span>&gt; shipyard change-password
<span class="label">Password:</span> 新密码
<span class="label">Confirm:</span> 验证密码
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Shipyard</strong> 是一个管理容器、主机等资源的web图形化工具，它建立在docker集群管理工具Citadel之上。有core和extension两个版本：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>core</td>
<td>把多个Docker host上的 containers 统一管理，支持跨越多个host。</td>
</tr>
<tr>
<td>extension</td>
<td>添加了应用路由和负载均衡、集中化日志、部署等功能。</td>
</tr>
</tbody>
</table>
]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TOP命令解释]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/09/TOP%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A/"/>
    <id>http://www.chenbaocheng.com/2015/07/09/TOP命令解释/</id>
    <published>2015-07-09T09:36:36.000Z</published>
    <updated>2015-07-09T10:11:07.000Z</updated>
    <content type="html"><![CDATA[<p> top命令是Linux下最常用的性能分析工具，它能够实时显示系统中各个进程的资源占用状况。</p>
<p><strong>top命令参数</strong></p>
<pre><code>-<span class="ruby">b   批处理模式（batch mode），可输出到管道、文件。默认情况下-b会一直输出，可以用-nN指定输出次数。
</span>-<span class="ruby">n <span class="constant">N</span>限制输出次数。
</span>-<span class="ruby">d <span class="constant">N</span>    刷新时间间隔。
</span>-<span class="ruby">p <span class="constant">PID</span>  监控指定进程。
</span>-<span class="ruby"><span class="constant">H</span> -p <span class="constant">PID</span>   监控指定进程和进行内线程信息。</span>
</code></pre><a id="more"></a>

<p><strong>执行top命令按键操作</strong></p>
<pre><code>c       显示完整的命令名。c为Command之意。
d       修改刷新时间。d为Display之意。
u       显示指定用户相关进程。u为User之意。
P       按<span class="built_in">CPU</span>使用排序。P为Processor（处理器）之意。
M       按内存使用排序。M为Momery之意。
F       排序（进入新的界面，并选择排序的目标字段）。
R       顺序或逆序。
H       显示线程
Z       以多色彩显示top。
l/t/m   toggle，load/<span class="built_in">cpu</span>/内存信息
<span class="number">1</span>       显示多<span class="built_in">CPU</span>的信息（多核机器上查看每个<span class="built_in">CPU</span>的使用率）。
W       保存当前top的配置
</code></pre><p><strong>top命令演示</strong></p>
<pre><code>$ top
top - <span class="number">17</span>:<span class="number">38</span>:<span class="number">29</span> up <span class="number">3</span> days, <span class="number">45</span> min,  <span class="number">2</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span>
Tasks: <span class="number">116</span> total,   <span class="number">1</span> running, <span class="number">115</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie
Cpu(s):  <span class="number">0.1</span>%us,  <span class="number">0.1</span>%sy,  <span class="number">0.0</span>%ni, <span class="number">98.9</span>%id,  <span class="number">0.8</span>%wa,  <span class="number">0.0</span>%hi,  <span class="number">0.0</span>%si,  <span class="number">0.0</span>%st
Mem:   7956536k total,  7774476k used,   182060k free,   170028k buffers
Swap:  8093692k total,        0k used,  8093692k free,  6241820k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
   <span class="number">11</span> root      <span class="number">20</span>   <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> S  <span class="number">2.0</span>  <span class="number">0.0</span>   <span class="number">2</span>:<span class="number">55.94</span> events/<span class="number">0</span>
    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">19232</span> <span class="number">1508</span> <span class="number">1216</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.72</span> init
  <span class="keyword">...</span>
  <span class="keyword">...</span> 篇幅太长，已删除
  <span class="keyword">...</span>
</code></pre><p><strong>第 1 行 效果同直行uptime命令</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:38:29</td>
<td>当前时间</td>
</tr>
<tr>
<td>up 3 days, 45 min</td>
<td>系统启动到当前的时间</td>
</tr>
<tr>
<td>2 users</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.00, 0.00, 0.00</td>
<td>系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
</tbody>
</table>
<p><strong>第 2 行 进程</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>116 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行进程数</td>
</tr>
<tr>
<td>115 sleeping</td>
<td>休眠进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数</td>
</tr>
</tbody>
</table>
<p><strong>第 3 行 CPU</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.1%us</td>
<td>用户占用CPU百分比</td>
</tr>
<tr>
<td>0.1%sy</td>
<td>内核占用CPU百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>用户进程改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>98.9%id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.8%wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.0%hi</td>
<td>硬中断（Hardware IRQ）占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%si</td>
<td>软中断（Software Interrupts）占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>丢失时间占用CPU</td>
</tr>
</tbody>
</table>
<p><strong>第 4 行 内存</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>7956536k total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>7774476k used</td>
<td>已使用内存总量</td>
</tr>
<tr>
<td>182060k free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>170028k buffers</td>
<td>缓存的内存量</td>
</tr>
</tbody>
</table>
<p><strong>第 5 行 swap交换分区信息</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>8093692k total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>0k used</td>
<td>已使用交换区总量</td>
</tr>
<tr>
<td>8093692k free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>6241820k cached</td>
<td>缓冲的交换区总量</td>
</tr>
</tbody>
</table>
<p><strong>第 7 行 各进程状态监控</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>USER</td>
<td>进程所有者</td>
</tr>
<tr>
<td>PR</td>
<td>进程优先级</td>
</tr>
<tr>
<td>NI</td>
<td>nice值。负值表示高优先级，正值表示低优先级</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td>
</tr>
<tr>
<td>SHR</td>
<td>共享内存大小，单位kb</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td>
</tr>
<tr>
<td>%CPU</td>
<td>上次更新到现在的CPU时间占用百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程使用的物理内存百分比</td>
</tr>
<tr>
<td>TIME+</td>
<td>进程使用的CPU时间总计，单位1/100秒</td>
</tr>
<tr>
<td>COMMAND</td>
<td>进程名称（命令名/命令行）</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p> top命令是Linux下最常用的性能分析工具，它能够实时显示系统中各个进程的资源占用状况。</p>
<p><strong>top命令参数</strong></p>
<pre><code>-<span class="ruby">b   批处理模式（batch mode），可输出到管道、文件。默认情况下-b会一直输出，可以用-nN指定输出次数。
</span>-<span class="ruby">n <span class="constant">N</span>限制输出次数。
</span>-<span class="ruby">d <span class="constant">N</span>    刷新时间间隔。
</span>-<span class="ruby">p <span class="constant">PID</span>  监控指定进程。
</span>-<span class="ruby"><span class="constant">H</span> -p <span class="constant">PID</span>   监控指定进程和进行内线程信息。</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.chenbaocheng.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux性能监控工具集合(图)]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/09/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88-%E5%9B%BE/"/>
    <id>http://www.chenbaocheng.com/2015/07/09/Linux性能监控工具集合-图/</id>
    <published>2015-07-09T07:12:55.000Z</published>
    <updated>2015-07-09T07:17:26.000Z</updated>
    <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/linux_observability_tools.png"><br><a id="more"></a><br><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/linux_benchmarking_tools.png"><br><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/linux_tuning_tools.png"><br><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/linux_observability_sar.png">]]></content>
    <summary type="html">
    <![CDATA[<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/linux_observability_tools.png"><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.chenbaocheng.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZooKeeper配置与使用]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/03/ZooKeeper%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/07/03/ZooKeeper配置与使用/</id>
    <published>2015-07-03T06:16:00.000Z</published>
    <updated>2015-07-03T07:17:09.000Z</updated>
    <content type="html"><![CDATA[<p>ZooKeeper Server是一个Java语言实现的分布式协调服务框架，因此需要JDK6+的支持。为了确保ZooKeeper服务的稳定与可靠性，通常是搭建成一个ZK集群来对外提供服务。ZK有一个重要的特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的，所以建议集群的机器数量为奇数。</p>
<h4 id="1、安装JDK6+">1、安装JDK6+</h4>
<h4 id="2、去官网选择一个合适的版本下载。">2、去官网选择一个合适的版本下载。</h4>
<pre><code><span class="comment">#官网 http://www.apache.org/dyn/closer.cgi/zookeeper/</span>

wget <span class="symbol">http:</span>/<span class="regexp">/mirrors.cnnic.cn/apache</span><span class="regexp">/zookeeper/zookeeper</span>-<span class="number">3.4</span>.<span class="number">6</span>/zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
tar zxf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
cd zookeeper-<span class="number">3.4</span>.<span class="number">6</span>
</code></pre><a id="more"></a>

<h4 id="3、配置">3、配置</h4>
<pre><code>mv conf/zoo_sample.cfg  conf/zoo.cfg 

<span class="comment">#创建数据存储路径</span>
mkdir -p /ROOT/data/zookeeper/

<span class="comment">#修改dataDir</span>
vi conf/zoo.cfg

修改一下内容：
<span class="variable">tickTime=</span><span class="number">2000</span>
<span class="variable">dataDir=</span>/ROOT/data/zookeeper/ 
<span class="variable">clientPort=</span><span class="number">2181</span>
<span class="variable">initLimit=</span><span class="number">5</span>
<span class="variable">syncLimit=</span><span class="number">2</span>
server.<span class="number">1</span>=zk1:<span class="number">2888</span>:<span class="number">3888</span>
server.<span class="number">2</span>=zk2:<span class="number">2888</span>:<span class="number">3888</span>
server.<span class="number">3</span>=zk3:<span class="number">2888</span>:<span class="number">3888</span>
</code></pre><p><strong>server.id=host:port:port</strong> 关于id，我们称之为Server ID，用来标识该host在集群中的机器序号，id的取值范围是1~255。</p>
<p><strong>注意：集群中所有节点的配置文件必须保持一致</strong></p>
<h4 id="4、启动">4、启动</h4>
<pre><code>bin/zkServer.<span class="keyword">sh</span> start 
</code></pre><h4 id="5、检查是否安装成功">5、检查是否安装成功</h4>
<pre><code>bin/zkCli.<span class="keyword">sh</span> 
或
<span class="keyword">echo</span> stat|nc localhost <span class="number">2181</span>
</code></pre><h4 id="关于带GUI管理工具">关于带GUI管理工具</h4>
<ul>
<li><strong>TaoKeeper</strong></li>
</ul>
<p>淘宝开源的ZK监控与报表系统，看上去很久不更新的样子。如果自己下载源码进行编译，可能会出现依赖，需要手动安装JAR到本地maven库，使用不是特别方便。</p>
<ul>
<li><strong>Node_Zookeeper_Admin</strong></li>
</ul>
<p>用NodeJs开发，没用过，看界面还不错，由于需要安装nodejs环境，还是不试了。</p>
<h4 id="zoo-cfg文件参数详解">zoo.cfg文件参数详解</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>clientPort</td>
<td>客户端连接server的端口，即对外服务端口，一般设置为2181吧。</td>
</tr>
<tr>
<td>dataDir</td>
<td>存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。</td>
</tr>
<tr>
<td>tickTime</td>
<td>ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。</td>
</tr>
<tr>
<td>dataLogDir</td>
<td>事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能。（No Java system property）</td>
</tr>
<tr>
<td>globalOutstandingLimit</td>
<td>最大请求堆积数。默认是1000。ZK运行的时候， 尽管server已经没有空闲来处理更多的客户端请求了，但是还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。(Java system property:zookeeper.globalOutstandingLimit.)</td>
</tr>
<tr>
<td>preAllocSize</td>
<td>预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果ZK的快照频率较大的话，建议适当减小这个参数。(Java system property:zookeeper.preAllocSize)</td>
</tr>
<tr>
<td>snapCount</td>
<td>每进行snapCount次事务日志输出后，触发一次快照(snapshot), 此时，ZK会生成一个snapshot.<em>文件，同时创建一个新的事务日志文件log.</em>。默认是100000.（真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能）(Java system property:zookeeper.snapCount)</td>
</tr>
<tr>
<td>traceFile</td>
<td>用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java system property:?requestTraceFile)</td>
</tr>
<tr>
<td>maxClientCnxns</td>
<td>单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60（3.4.0开始，默认值调整为60，之前的默认值是10），如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台ZK服务器之间的连接数限制，不是针对指定客户端IP，也不是ZK集群的连接数限制，也不是单台ZK对所有客户端的连接数限制。指定客户端IP的限制策略，这里有一个patch，可以尝试一下：<a href="http://rdc.taobao.com/team/jm/archives/1334（No" target="_blank" rel="external">http://rdc.taobao.com/team/jm/archives/1334（No</a> Java system property）</td>
</tr>
<tr>
<td>clientPortAddress</td>
<td>对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听clientPort指定的端口。New in 3.3.0</td>
</tr>
<tr>
<td>minSessionTimeoutmaxSessionTimeout</td>
<td>Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2 <em> tickTime ~ 20 </em> tickTime这个范围 New in 3.3.0</td>
</tr>
<tr>
<td>fsync.warningthresholdms</td>
<td>事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。(Java system property:fsync.warningthresholdms) New in 3.3.4</td>
</tr>
<tr>
<td>autopurge.purgeInterval</td>
<td>在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>autopurge.snapRetainCount</td>
<td>这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>electionAlg</td>
<td>在之前的版本中， 这个参数配置是允许我们选择leader选举算法，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property)</td>
</tr>
<tr>
<td>initLimit</td>
<td>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在initLimit时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property)</td>
</tr>
<tr>
<td>syncLimit</td>
<td>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property)</td>
</tr>
<tr>
<td>leaderServes</td>
<td>默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper.leaderServes)。</td>
</tr>
<tr>
<td>server.x=[hostname]:nnnnn[:nnnnn]</td>
<td>这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。(No Java system property)</td>
</tr>
<tr>
<td>group.x=nnnnn[:nnnnn]weight.x=nnnnn</td>
<td>对机器分组和权重设置，可以 <a href="http://zookeeper.apache.org/doc/r3.4.3/zookeeperHierarchicalQuorums.html" target="_blank" rel="external">参见这里</a>(No Java system property)</td>
</tr>
<tr>
<td>cnxTimeout</td>
<td>Leader选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper.cnxTimeout)</td>
</tr>
<tr>
<td>zookeeper.DigestAuthenticationProvider.superDigest</td>
<td>ZK权限设置相关，具体参见<a href="http://nileader.blog.51cto.com/1381108/930635" target="_blank" rel="external">《使用super身份对有权限的节点进行操作》</a> 和 <a href="http://nileader.blog.51cto.com/1381108/795525" target="_blank" rel="external">《ZooKeeper权限控制》</a></td>
</tr>
<tr>
<td>skipACL</td>
<td>对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property:zookeeper.skipACL)</td>
</tr>
<tr>
<td>forceSync</td>
<td>这个参数确定了是否需要在事务日志提交的时候调用FileChannel.force来保证数据完全同步到磁盘。(Java system property:zookeeper.forceSync)</td>
</tr>
<tr>
<td>jute.maxbuffer</td>
<td>每个节点最大数据量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property:jute.maxbuffer)</td>
</tr>
</tbody>
</table>
<h4 id="常用命令">常用命令</h4>
<p><strong>conf</strong></p>
<pre><code><span class="comment"># 输出server的详细配置信息</span>
$ <span class="built_in">echo</span> conf|nc localhost <span class="number">2181</span>
</code></pre><p><strong>cons</strong> </p>
<pre><code><span class="comment">#输出指定server上所有客户端连接的详细信息，包括客户端IP，会话ID等</span>
$ <span class="built_in">echo</span> cons|nc localhost <span class="number">2181</span>
</code></pre><p><strong>crst</strong></p>
<pre><code><span class="preprocessor">#功能性命令。重置所有连接的统计信息。</span>
</code></pre><p><strong>dump</strong></p>
<pre><code><span class="preprocessor">#这个命令针对Leader执行，用于输出所有等待队列中的会话和临时节点的信息。 </span>
</code></pre><p><strong>envi</strong></p>
<pre><code><span class="preprocessor">#用于输出server的环境变量。包括操作系统环境和Java环境。</span>
</code></pre><p><strong>ruok</strong></p>
<pre><code><span class="preprocessor">#用于测试server是否处于无错状态。如果正常，则返回“imok”,否则没有任何响应。</span>

注意：
ruok不是一个特别有用的命令，它不能反映一个server是否处于正常工作。“stat”命令更靠谱。
</code></pre><p><strong>stat</strong></p>
<pre><code><span class="preprocessor">#输出server简要状态和连接的客户端信息。</span>
</code></pre><p><strong>srvr</strong></p>
<pre><code><span class="comment">#和stat类似</span>

$ <span class="built_in">echo</span> stat|nc localhost <span class="number">2181</span>

$ <span class="built_in">echo</span> srvr|nc localhost <span class="number">2181</span>
</code></pre><p><strong>srst</strong></p>
<pre><code><span class="preprocessor">#重置server的统计信息。</span>
</code></pre><p><strong>wchs</strong></p>
<pre><code><span class="preprocessor">#列出所有watcher信息概要信息，数量等。</span>
</code></pre><p><strong>wchc</strong></p>
<pre><code><span class="comment">#列出所有watcher信息，以watcher的session为归组单元排列，列出该会话订阅了哪些path</span>

$ <span class="built_in">echo</span> wchc|nc localhost <span class="number">2181</span>
</code></pre><p><strong>wchp</strong></p>
<pre><code><span class="comment">#列出所有watcher信息，以watcher的path为归组单元排列，列出该path被哪些会话订阅着</span>

$ <span class="built_in">echo</span> wchp|nc localhost <span class="number">2181</span>
</code></pre><p><strong>mntr</strong></p>
<pre><code><span class="comment">#输出一些ZK运行时信息，通过对这些返回结果的解析，可以达到监控的效果。</span>

$ <span class="built_in">echo</span> mntr | nc localhost <span class="number">2185</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>ZooKeeper Server是一个Java语言实现的分布式协调服务框架，因此需要JDK6+的支持。为了确保ZooKeeper服务的稳定与可靠性，通常是搭建成一个ZK集群来对外提供服务。ZK有一个重要的特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的，所以建议集群的机器数量为奇数。</p>
<h4 id="1、安装JDK6+">1、安装JDK6+</h4>
<h4 id="2、去官网选择一个合适的版本下载。">2、去官网选择一个合适的版本下载。</h4>
<pre><code><span class="comment">#官网 http://www.apache.org/dyn/closer.cgi/zookeeper/</span>

wget <span class="symbol">http:</span>/<span class="regexp">/mirrors.cnnic.cn/apache</span><span class="regexp">/zookeeper/zookeeper</span>-<span class="number">3.4</span>.<span class="number">6</span>/zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
tar zxf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz
cd zookeeper-<span class="number">3.4</span>.<span class="number">6</span>
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM G1垃圾回收器]]></title>
    <link href="http://www.chenbaocheng.com/2015/07/02/JVM%20G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.chenbaocheng.com/2015/07/02/JVM G1垃圾回收器/</id>
    <published>2015-07-02T02:35:59.000Z</published>
    <updated>2015-07-02T06:33:17.000Z</updated>
    <content type="html"><![CDATA[<p>回顾一下主流的(HotSpot JVM)JAVA垃圾回收器，堆被内存分解为三个区域，具体分为：新生代、老年代、持久代。</p>
<p><strong>Java 7 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java7-jvm-space.png">

<p><strong>Java 8 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java8-jvm-space.png">

<a id="more"></a>

<p>1、绝大部分新生成的对象都放在Eden区，当Eden区将满，JVM会因申请不到内存，而触发Young GC ,进行Eden区+有对象的Survivor区(设为S0区)垃圾回收，把存活的对象用复制算法拷贝到一个空的Survivor(S1)中，此时Eden区被清空，另外一个Survivor S0也为空。下次触发Young GC回收Eden+S0，将存活对象拷贝到S1中。新生代垃圾回收简单、粗暴、高效。</p>
<p>2、若发现Survivor区满了，则将这些对象拷贝到old区或者Survivor没满但某些对象足够Old,也拷贝到Old区(每次Young GC都会使Survivor区存活对象值+1，直到阈值)。 </p>
<p>3、Old区也会进行垃圾收集(Young GC),发生一次 Major GC 至少伴随一次Young GC，一般比Young GC慢十倍以上。<br>JVM在Old区申请不到内存，会进行Full GC。Old区使用一般采用Concurrent-Mark–Sweep策略回收内存。</p>
<p><strong>总结</strong>：</p>
<p>Java垃圾回收器是一种“自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>GC过程中会出现STW(Stop-The-World)，若Old区对象太多，STW耗费大量时间。</li>
<li>CMS收集器对CPU资源很敏感。</li>
<li>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</li>
<li>CMS导致内存碎片问题。</li>
</ul>
<h4 id="G1收集器">G1收集器</h4>
<p>在G1中，堆被划分成 许多个连续的区域(region)。每个区域大小相等，在1M~32M之间。JVM最多支持2000个区域，可推算G1能支持的最大内存为2000*32M=62.5G。区域(region)的大小在JVM初始化的时候决定，也可以用-XX:G1HeapReginSize设置。</p>
<p>在G1中没有物理上的Yong(Eden/Survivor)/Old Generation，它们是逻辑的，使用一些非连续的区域(Region)组成的。</p>
<p><strong>新生代收集</strong></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-young-1.png">

<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-young-2.png">

<p>被圈起的绿色部分为新生代的区域(region)，经过Young GC后存活的对象被复制到一个或者多个区域空闲中，这些被填充的区域将是新的新生代；当新生代对象的年龄(逃逸过一次Young GC年龄增加１)已经达到某个阈值(ParNew默认15)，被复制到老年代的区域中。</p>
<p>回收过程是停顿的(STW,Stop-The-Word);回收完成之后根据Young GC的统计信息调整Eden和Survivor的大小，有助于合理利用内存，提高回收效率。</p>
<p>回收的过程多个回收线程并发收集。</p>
<p><strong>老年代收集</strong></p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-1.jpg">

<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-2.jpg">

<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-g1-old-3.jpg">

<p><strong>关于Remembered Set概念</strong>：G1收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用是使用Remembered Set来避免扫描全堆。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序对Reference类型数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之间(在分代中例子中就是检查是否老年代中的对象引用了新生代的对象)，如果是便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当内存回收时，在GC根节点的枚举范围加入Remembered Set即可保证不对全局堆扫描也不会有遗漏。</p>
<p>G1虽然保留了CMS关于代的概念，但是代已经不是物理上连续区域，而是一个逻辑的概念。在标记过程中，每个区域的对象活性都被计算，在回收时候，就可以根据用户设置的停顿时间，选择活性较低的区域收集，这样既能保证垃圾回收，又能保证停顿时间，而且也不会降低太多的吞吐量。Remark阶段新算法的运用，以及收集过程中的压缩，都弥补了CMS不足。引用Oracle官网的一句话：“G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS)”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>回顾一下主流的(HotSpot JVM)JAVA垃圾回收器，堆被内存分解为三个区域，具体分为：新生代、老年代、持久代。</p>
<p><strong>Java 7 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java7-jvm-space.png">

<p><strong>Java 8 HotSpotVM</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/java8-jvm-space.png">

]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 8元空间(Metaspace)]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/30/Java%208%E5%85%83%E7%A9%BA%E9%97%B4(Metaspace)/"/>
    <id>http://www.chenbaocheng.com/2015/06/30/Java 8元空间(Metaspace)/</id>
    <published>2015-06-30T07:30:29.000Z</published>
    <updated>2015-06-30T09:35:47.000Z</updated>
    <content type="html"><![CDATA[<h4 id="元空间（Metaspace）：">元空间（Metaspace）：</h4>
<p>相信许多Java开发者都见过“java.lang.OutOfMemoryError: PermGen space”问题，这通常是类加载器相关的内存泄漏以及新类加载器的创建导致的，一般出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，通常“问题”是默认值太低了, 常用的解决方法是将其设置为256MB或更高。</p>
<p>PermGen space的全称是Permanent Generation space,是指JVM永久保存区域，这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。JVM 种类有很多(如Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM）。Oracle-Sun Hotspot才有PermGen space，JRockit以及J9没有这个区域。</p>
<p>随着JAVA8时代的来临,新增一种使用本地内存来存储类元数据信息称之为元空间(Metaspace)，JVM永久区被元空间(Metaspace)替换(JEP 122), 与Oracle JRockit 和IBM JVM’s很相似。JVM参数 -XX:PermSize 和 -XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替，如果使用了-XX:PermSize 和 -XX:MaxPermSize启动时会发出警告。。 这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用。</p>
<a id="more"></a>

<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-8-metaspace.jpg">

<h4 id="Metaspace_内存分配模型">Metaspace 内存分配模型</h4>
<ul>
<li>大部分类元数据都在本地内存中分配。</li>
<li>用于描述类元数据的“klasses”已经被移除。</li>
</ul>
<h4 id="Metaspace_容量">Metaspace 容量</h4>
<ul>
<li>默认情况下，类元数据只受可用的本地内存限制（容量取决于是32位或是64位操作系统的可用虚拟内存大小）。</li>
<li>新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。</li>
</ul>
<h4 id="Metaspace_垃圾回收">Metaspace 垃圾回收</h4>
<ul>
<li>对于僵死的类及类加载器的垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行。</li>
<li>适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。</li>
</ul>
<h4 id="Java_堆内存的影响">Java 堆内存的影响</h4>
<p>一些杂项数据已经移到Java堆空间中。升级到JDK8之后，会发现Java堆 空间有所增长。</p>
<h4 id="Metaspace_监控">Metaspace 监控</h4>
<p>元空间的使用情况可以从HotSpot1.8的详细GC日志输出中看到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="元空间（Metaspace）：">元空间（Metaspace）：</h4>
<p>相信许多Java开发者都见过“java.lang.OutOfMemoryError: PermGen space”问题，这通常是类加载器相关的内存泄漏以及新类加载器的创建导致的，一般出现于代码热部署时。相对于正式产品，该问题在开发机上出现的频率更高，通常“问题”是默认值太低了, 常用的解决方法是将其设置为256MB或更高。</p>
<p>PermGen space的全称是Permanent Generation space,是指JVM永久保存区域，这一部分用于存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域，它和和存放Instance的Heap区域不同,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行pre compile的时候。JVM 种类有很多(如Oralce-Sun Hotspot, Oralce JRockit, IBM J9, Taobao JVM）。Oracle-Sun Hotspot才有PermGen space，JRockit以及J9没有这个区域。</p>
<p>随着JAVA8时代的来临,新增一种使用本地内存来存储类元数据信息称之为元空间(Metaspace)，JVM永久区被元空间(Metaspace)替换(JEP 122), 与Oracle JRockit 和IBM JVM’s很相似。JVM参数 -XX:PermSize 和 -XX:MaxPermSize被XX:MetaSpaceSize 和 -XX:MaxMetaspaceSize代替，如果使用了-XX:PermSize 和 -XX:MaxPermSize启动时会发出警告。。 这意味着不会再有java.lang.OutOfMemoryError: PermGen问题，也不再需要你进行调优及监控内存空间的使用。</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM内存管理与垃圾回收]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/26/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.chenbaocheng.com/2015/06/26/JVM内存管理与垃圾回收/</id>
    <published>2015-06-26T03:53:26.000Z</published>
    <updated>2015-06-29T04:14:46.000Z</updated>
    <content type="html"><![CDATA[<p>Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

<a id="more"></a>

<h4 id="JVM_运行时数据区域">JVM 运行时数据区域</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm_memory_structure.png">

<p>Java 虚拟机在执行Java 程序过程中会把它所管理的内存划分为几个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p>这几个区域如下：</p>
<ul>
<li>方法区（Method Area）</li>
<li>虚拟机栈（VM Stack）</li>
<li>本地方法栈（Natvie Method Stack）</li>
<li>堆（Heap）</li>
<li>程序计数器（Program Counter Register）</li>
</ul>
<h4 id="JVM中Stack和Heap的关系">JVM中Stack和Heap的关系</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们经常会把 Java 内存分为堆内存（Heap）和栈内存（Stack），这是一种比较粗糙区分方式。我们平时所关注的也主要是这两个区域。栈指的是上图中的Java虚拟机栈。Java 虚拟机栈是线程私有的，其生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息，<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-thread-stack.gif">

<p>&nbsp;&nbsp;&nbsp;&nbsp;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和 returnAddress（指向一条字节码指令的地址）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果线程请求的栈深度大于虚拟机允许的深度，会抛出 StackOverflowException 异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存时会抛出 OutOfMemoryError 异常。递归调用时如果深度过深，很容易出现栈溢出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用程序来说，堆(Heap)是Java虚拟机管理的内存中最大的一块。 堆是所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在Java体系中，即便是最简单的对象访问，也会涉及栈、堆、方法区这三个最重要的内存区域。例如下面这行代码：</p>
<ul>
<li>Object obj = new Object();</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;假如这段代码出现在方法体中，Object obj 这部分的语意会反映到Java虚拟机栈的本地变量表中，做为一个reference 类型数据出现。new Object()这部分语意会反映在Java堆中，形成一块存储了 Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存。不同虚拟机的对象访问方式有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>
<h4 id="堆内存">堆内存</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Java中堆是JVM 管理的最大一块内存空间，主要用于存放各种类的实例对象。堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。堆的内存模型大致为：</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-memory-heap.png">

<ul>
<li>堆大小 = 新生代 + 老年代</li>
</ul>
<h4 id="常用的内存区域调节参数">常用的内存区域调节参数</h4>
<ul>
<li><p>-Xms：初始堆大小，默认为物理内存的1/64(&lt;1GB)；默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</p>
</li>
<li><p>-Xmx：最大堆大小，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</p>
</li>
<li><p>-Xmn：新生代的内存空间大小，注意：此处的大小是（eden+ 2 survivor space)。与jmap -heap中显示的New gen是不同的。整个堆大小=新生代大小 + 老生代大小 + 永久代大小。 在保证堆大小不变的情况下，增大新生代后,将会减小老生代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8。</p>
</li>
<li><p>-XX:SurvivorRatio：新生代中Eden区域与Survivor区域的容量比值，默认值为8。两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10。</p>
</li>
<li><p>-Xss：每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。应根据应用的线程所需内存大小进行适当调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。一般小的应用， 如果栈不是很深， 应该是128k够用的，大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</p>
</li>
<li><p>-XX:PermSize：设置永久代(perm gen)初始值。默认值为物理内存的1/64。</p>
</li>
<li><p>-XX:MaxPermSize：设置持久代最大值。物理内存的1/4。</p>
</li>
</ul>
<h4 id="GC_堆">GC 堆</h4>
<p>&nbsp;&nbsp;Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。<br>当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。<br>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳<br>( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。<br>但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。<br>现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。<br>另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。</p>
<h4 id="GC_日志">GC 日志</h4>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    Object obj = <span class="keyword">new</span> Object();
    System.gc();
    System.<span class="keyword">out</span>.println();
    obj = <span class="keyword">new</span> Object();
    obj = <span class="keyword">new</span> Object();
    System.gc();
    System.<span class="keyword">out</span>.println();
}
</code></pre><p>设置 JVM 参数为 -XX:+PrintGCDetails，使得控制台能够显示 GC 相关的日志信息，执行上面代码，下面是其中一次执行的结果。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-log-1.png"><br><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-log-2.png">

<p>&nbsp;&nbsp;从 Full GC 信息可知，新生代可用的内存大小约为 18M，则新生代实际分配得到的内存空间约为 20M(为什么是 20M? 请继续看下面…)。老年代分得的内存大小约为 42M，堆的可用内存的大小约为 60M。可以计算出： 18432K ( 新生代可用空间 ) + 42112K ( 老年代空间 ) = 60544K ( 堆的可用空间 )<br>新生代约占堆大小的 1/3，老年代约占堆大小的 2/3。也可以看出，GC 对新生代的回收比较乐观，而对老年代以及方法区的回收并不明显或者说不及新生代。<br>并且在这里 Full GC 耗时是 Minor GC 的 22.89 倍。</p>
<h4 id="JVM_参数选项">JVM 参数选项</h4>
<p>jvm 可配置的参数选项可以参考 Oracle 官方网站给出的相关信息：<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td> -Xms</td>
<td>初始堆大小。如：-Xms256m</td>
</tr>
<tr>
<td> -Xmx</td>
<td>最大堆大小。如：-Xmx512m</td>
</tr>
<tr>
<td> -Xmn</td>
<td>新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</td>
</tr>
<tr>
<td> -Xss</td>
<td>JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</td>
</tr>
<tr>
<td> -XX:NewRatio</td>
<td>新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</td>
</tr>
<tr>
<td> -XX:SurvivorRatio</td>
<td>新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</td>
</tr>
<tr>
<td> -XX:PermSize</td>
<td>永久代(方法区)的初始大小</td>
</tr>
<tr>
<td> -XX:MaxPermSize</td>
<td>永久代(方法区)的最大值</td>
</tr>
<tr>
<td> -XX:+PrintGCDetails</td>
<td>打印 GC 信息</td>
</tr>
<tr>
<td> -XX:+HeapDumpOnOutOfMemoryError</td>
<td>让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用</td>
</tr>
</tbody>
</table>
<pre><code><span class="javadoc">/**
    -Xms60m
    -Xmx60m
    -Xmn20m
    -XX:NewRatio=2 ( 若 Xms = Xmx, 并且设定了 Xmn, 那么该项配置就不需要配置了 )
    -XX:SurvivorRatio=8
    -XX:PermSize=30m
    -XX:MaxPermSize=30m
    -XX:+PrintGCDetails
*/</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
    <span class="keyword">new</span> Test().doTest();
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span>(){
    Integer M = <span class="keyword">new</span> Integer(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);  <span class="comment">//单位, 兆(M)</span>
    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M]; <span class="comment">//申请 1M 大小的内存空间</span>
    bytes = <span class="keyword">null</span>;  <span class="comment">//断开引用链</span>
    System.gc();   <span class="comment">//通知 GC 收集垃圾</span>
    System.out.println();
    bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M];  <span class="comment">//重新申请 1M 大小的内存空间</span>
    bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * M];  <span class="comment">//再次申请 1M 大小的内存空间</span>
    System.gc();
    System.out.println();
}
</code></pre><p>按上面代码中注释的信息设定 jvm 相关的参数项，并执行程序，下面是一次执行完成控制台打印的结果：</p>
<pre><code>[ GC [ PSYoungGen:  <span class="number">1351</span><span class="keyword">K</span> -&gt; <span class="number">288</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  <span class="number">1351</span><span class="keyword">K</span> -&gt; <span class="number">288</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>), <span class="number">0.0012389</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs ] 
[ <span class="keyword">Full</span> GC (System)  [ PSYoungGen:  <span class="number">288</span><span class="keyword">K</span> -&gt; <span class="number">0</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  [ PSOldGen:  <span class="number">0</span><span class="keyword">K</span> -&gt; <span class="number">160</span><span class="keyword">K</span> (<span class="number">40960</span><span class="keyword">K</span>) ]  <span class="number">288</span><span class="keyword">K</span> -&gt; <span class="number">160</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>)  [ PSPermGen:  <span class="number">2942</span><span class="keyword">K</span> -&gt; <span class="number">2942</span><span class="keyword">K</span> (<span class="number">30720</span><span class="keyword">K</span>) ],  <span class="number">0.0057649</span> secs ] [ <span class="keyword">Times</span>:  user=<span class="number">0.00</span>  sys=<span class="number">0.00</span>,  real=<span class="number">0.01</span> secs ] 

[ GC [ PSYoungGen:  <span class="number">2703</span><span class="keyword">K</span> -&gt; <span class="number">1056</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  <span class="number">2863</span><span class="keyword">K</span> -&gt; <span class="number">1216</span><span class="keyword">K</span>(<span class="number">59392</span><span class="keyword">K</span>),  <span class="number">0.0008206</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs ] 
[ <span class="keyword">Full</span> GC (System)  [ PSYoungGen:  <span class="number">1056</span><span class="keyword">K</span> -&gt; <span class="number">0</span><span class="keyword">K</span> (<span class="number">18432</span><span class="keyword">K</span>) ]  [ PSOldGen:  <span class="number">160</span><span class="keyword">K</span> -&gt; <span class="number">1184</span><span class="keyword">K</span> (<span class="number">40960</span><span class="keyword">K</span>) ]  <span class="number">1216</span><span class="keyword">K</span> -&gt; <span class="number">1184</span><span class="keyword">K</span> (<span class="number">59392</span><span class="keyword">K</span>)  [ PSPermGen:  <span class="number">2951</span><span class="keyword">K</span> -&gt; <span class="number">2951</span><span class="keyword">K</span> (<span class="number">30720</span><span class="keyword">K</span>) ], <span class="number">0.0052445</span> secs ]  [ <span class="keyword">Times</span>: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs ] 

Heap
PSYoungGen      total <span class="number">18432</span><span class="keyword">K</span>, used <span class="number">327</span><span class="keyword">K</span> [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)
eden space <span class="number">16384</span><span class="keyword">K</span>, <span class="number">2</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fec51f58</span>,<span class="number">0x00000000ffc00000</span>)
from space <span class="number">2048</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x0000000100000000</span>)
to   space <span class="number">2048</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffe00000</span>)
PSOldGen        total <span class="number">40960</span><span class="keyword">K</span>, used <span class="number">1184</span><span class="keyword">K</span> [<span class="number">0x00000000fc400000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)
object space <span class="number">40960</span><span class="keyword">K</span>, <span class="number">2</span>% used [<span class="number">0x00000000fc400000</span>,<span class="number">0x00000000fc5281f8</span>,<span class="number">0x00000000fec00000</span>)
PSPermGen       total <span class="number">30720</span><span class="keyword">K</span>, used <span class="number">2959</span><span class="keyword">K</span> [<span class="number">0x00000000fa600000</span>, <span class="number">0x00000000fc400000</span>, <span class="number">0x00000000fc400000</span>)
object space <span class="number">30720</span><span class="keyword">K</span>, <span class="number">9</span>% used [<span class="number">0x00000000fa600000</span>,<span class="number">0x00000000fa8e3ce0</span>,<span class="number">0x00000000fc400000</span>)
</code></pre><p>从打印结果可以看出，堆中新生代的内存空间为 18432K ( 约 18M )，eden 的内存空间为 16384K ( 约 16M)，from / to survivor 的内存空间为 2048K ( 约 2M)。<br>这里所配置的 Xmn 为 20M，也就是指定了新生代的内存空间为 20M，可是从打印的堆信息来看，新生代怎么就只有 18M 呢? 另外的 2M 哪里去了?<br>别急，是这样的。新生代 = eden + from + to = 16 + 2 + 2 = 20M，可见新生代的内存空间确实是按 Xmn 参数分配得到的。<br>而且这里指定了 SurvivorRatio = 8，因此，eden = 8/10 的新生代空间 = 8/10 <em> 20 = 16M。from = to = 1/10 的新生代空间 = 1/10 </em> 20 = 2M。<br>堆信息中新生代的 total 18432K 是这样来的： eden + 1 个 survivor = 16384K + 2048K = 18432K，即约为 18M。<br>因为 jvm 每次只是用新生代中的 eden 和 一个 survivor，因此新生代实际的可用内存空间大小为所指定的 90%。<br>因此可以知道，这里新生代的内存空间指的是新生代可用的总的内存空间，而不是指整个新生代的空间大小。<br>另外，可以看出老年代的内存空间为 40960K ( 约 40M )，堆大小 = 新生代 + 老年代。因此在这里，老年代 = 堆大小 – 新生代 = 60 – 20 = 40M。<br>最后，这里还指定了 PermSize = 30m，PermGen 即永久代 ( 方法区 )，它还有一个名字，叫非堆，主要用来存储由 jvm 加载的类文件信息、常量、静态变量等。</p>
<p>打个盹，回到 doTest() 方法中，可以看到代码在第 17、21、22 这三行中分别申请了一块 1M 大小的内存空间，并在 19 和 23 这两行中分别显式的调用了 System.gc()。从控制台打印的信息来看，每次调 System.gc()，是先进行 Minor GC，然后再进行 Full GC。<br>第 19 行触发的 Minor GC 收集分析：<br>从信息 PSYoungGen :  1351K -&gt; 288K，可以知道，在第 17 行为 bytes 分配的内存空间已经被回收完成。<br>引起 GC 回收这 1M 内存空间的因素是第 18 行的 bytes = null;   bytes 为 null 表明之前申请的那 1M 大小的内存空间现在已经没有任何引用变量在使用它了，<br>并且在内存中它处于一种不可到达状态 ( 即没有任何引用链与 GC Roots 相连 )。那么，当 Minor GC 发生的时候，GC 就会来回收掉这部分的内存空间。<br>第 19 行触发的 Full GC 收集分析：<br>在 Minor GC 的时候，信息显示 PSYoungGen :  1351K -&gt; 288K，再看看 Full GC 中显示的 PSYoungGen :  288K -&gt; 0K，可以看出，Full GC 后，新生代的内存使用变成<br>0K 了 ( 0K，零 K，有没有人看成是英文的 OK 的 ? 好吧。我承认我第一次看的时候以为是英文的 OK，当时还特意在控制台打印 0K 和 OK 来确认。最后发现英文的 O 长得比阿拉伯数字的 0 要丰满和胖一些。现在印象还是比较深刻的。好像。。我跑题了 ~~ )<br>刚刚说到 Full GC 后，新生代的内存使用从 288K 变成 0K 了，那么这 288K 到底哪去了 ? 难道都被 GC 当成垃圾回收掉了 ? 当然不是了。我还特意在 main 方法中 new 了一个 Test 类的实例，这里的 Test 类的实例属于小对象，它应该被分配到新生代内存当中，现在还在调用这个实例的 doTest 方法呢，GC 不可能在这个时候来回收它的。<br>接着往下看 Full GC 的信息，会发现一个很有趣的现象，PSOldGen:  0K  -&gt; 160K，可以看到，Full GC 后，老年代的内存使用从 0K 变成了 160K，想必你已经猜到大概是怎么回事了。当 Full GC 进行的时候，默认的方式是尽量清空新生代 ( YoungGen )，因此在调 System.gc() 时，新生代 ( YoungGen ) 中存活的对象会提前进入老年代。<br>第 23 行触发的 Minor GC 收集分析：<br>从信息 PSYoungGen :  2703K -&gt; 1056K，可以知道，在第 21 行创建的，大小为 1M 的数组被 GC 回收了。在第 22 行创建的，大小也为 1M 的数组由于 bytes 引用变量还在引用它，因此，它暂时未被 GC 回收。<br>第 23 行触发的 Full GC 收集分析：<br>在 Minor GC 的时候，信息显示 PSYoungGen :  2703K -&gt; 1056K，Full GC 中显示的 PSYoungGen :  1056K -&gt; 0K，以及 PSOldGen:  160K -&gt; 1184K，可以知道，新生代 ( YoungGen ) 中存活的对象又提前进入老年代了。</p>
<h4 id="GC算法">GC算法</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm.png">

<h5 id="新生代可用GC">新生代可用GC</h5>
<p><strong>1）串行GC(Serial Copying)：</strong></p>
<p>client模式下默认GC方式，也可通过-XX:+UseSerialGC来强制指定；默认情况下 eden、s0、s1的大小通过-XX:SurvivorRatio来控制，默认为8，含义<br>为eden:s0的比例，启动后可通过jmap –heap [pid]来查看。</p>
<p>默认情况下，仅在TLAB或eden上分配，只有两种情况下会在老生代分配： </p>
<p>1、需要分配的内存大小超过eden space大小；<br>2、在配置了PretenureSizeThreshold的情况下，对象大小大于此值。</p>
<p>默认情况下，触发Minor GC时：<br>之前Minor GC晋级到old的平均大小 &lt; 老生代的剩余空间 &lt; eden+from Survivor的使用空间。当HandlePromotionFailure为true，则仅触发minor gc；如为false，则触发full GC。</p>
<p>默认情况下，新生代对象晋升到老生代的规则：</p>
<p>1、经历多次minor gc仍存活的对象，可通过以下参数来控制：以MaxTenuringThreshold值为准，默认为15。<br>2、to space放不下的，直接放入老生代；</p>
<p>**2）并行GC（ParNew）：</p>
<p>GC时默认采用，也可采用-XX:+UseParNewGC强制指定；垃圾回收的时候采用多线程的方式。</p>
<p><strong>3）并行回收GC(Parallel Scavenge)：</strong></p>
<p>server模式下默认的GC方式，也可采用-XX:+UseParallelGC强制指定；eden、s0、s1的大小可通过-XX:SurvivorRatio来控制，但默认情况下<br>以-XX:InitialSurivivorRatio为准，此值默认为8，代表的为新生代大小 : s0，这点要特别注意。</p>
<p>默认情况下，当TLAB、eden上分配都失败时，判断需要分配的内存大小是否 &gt;= eden space的一半大小，如是就直接在老生代上分配；</p>
<p><strong>默认情况下的垃圾回收规则：</strong></p>
<ol>
<li>在回收前PS GC会先检测之前每次PS GC时，晋升到老生代的平均大小是否大于老生代的剩余空间，如大于则直接触发full GC；</li>
<li>在回收后，也会按照上面的规则进行检测。</li>
</ol>
<p><strong>默认情况下的新生代对象晋升到老生代的规则：</strong></p>
<ol>
<li><p>经历多次minor gc仍存活的对象，可通过以下参数来控制：AlwaysTenure，默认false，表示只要minor GC时存活，就晋升到老生代；NeverTenure，默认false，表示永不晋升到老生代；上面两个都没设置的情冴下，如UseAdaptiveSizePolicy，启动时以InitialTenuringThreshold值作为存活次数的阈值，在每次ps gc后会动态调整，如不使用UseAdaptiveSizePolicy，则以MaxTenuringThreshold为准。</p>
</li>
<li><p>to space放不下的，直接放入老生代。在回收后，如UseAdaptiveSizePolicy，PS GC会根据运行状态动态调整eden、to以及TenuringThreshold的大小。如果不希望动态调整可设置-XX:-UseAdaptiveSizePolicy。如希望跟踪每次的变化情况，可在启劢参数上增加： PrintAdaptiveSizePolicy。</p>
</li>
</ol>
<h5 id="二、老生代可用GC">二、老生代可用GC</h5>
<p><strong>1、串行GC(Serial Copying)：</strong><br>client方式下默认GC方式，可通过-XX:+UseSerialGC强制指定。</p>
<p>触发机制：</p>
<ol>
<li>old gen空间不足；</li>
<li>perm gen空间不足；</li>
<li>minor gc时的悲观策略；</li>
<li>minor GC后在eden上分配内存仍然失败；</li>
<li>执行heap dump时；</li>
<li>外部调用System.gc，可通过-XX:+DisableExplicitGC来禁止。</li>
</ol>
<p><strong>2、并行回收GC(Parallel Scavenge)：</strong> server模式下默认GC方式，可通过-XX:+UseParallelGC强制指定； 并行的线程数为当cpu core&lt;=8 ? cpu core : 3+(cpu core*5)/8或通过-XX:ParallelGCThreads=x来强制指定。如ScavengeBeforeFullGC为true（默认值），则先执行minor GC。</p>
<p><strong>3、并行Compacting：</strong><br>可通过-XX:+UseParallelOldGC强制指定。</p>
<p><strong>4、并发CMS：</strong><br>可通过-XX:+UseConcMarkSweepGC来强制指定。并发的线程数默认为:( 并行GC线程数+3)/4，也可通过ParallelCMSThreads指定。</p>
<p>触发机制：</p>
<ol>
<li><p>当老生代空间的使用到达一定比率时触发；<br>Hotspot V 1.6中默认为65%，可通过PrintCMSInitiationStatistics（此参数在V 1.5中不能用）来查看这个值到底是多少；可通过CMSInitiatingOccupancyFraction来强制指定，默认值并不是赋值在了这个值上，是根据如下公式计算出来的： ((100 - MinHeapFreeRatio) +(double)(CMSTriggerRatio * MinHeapFreeRatio) / 100.0)/ 100.0; 其中,MinHeapFreeRatio默认值： 40   CMSTriggerRatio默认值： 80。</p>
</li>
<li><p>当perm gen采用CMS收集且空间使用到一定比率时触发；<br>perm gen采用CMS收集需设置：-XX:+CMSClassUnloadingEnabled   Hotspot V 1.6中默认为65%；可通过CMSInitiatingPermOccupancyFraction来强制指定，同样，它是根据如下公式计算出来的：((100 - MinHeapFreeRatio) +(double)(CMSTriggerPermRatio* MinHeapFreeRatio) / 100.0)/ 100.0; 其中，MinHeapFreeRatio默认值： 40    CMSTriggerPermRatio默认值： 80。</p>
</li>
<li><p>Hotspot根据成本计算决定是否需要执行CMS GC；可通过-XX:+UseCMSInitiatingOccupancyOnly来去掉这个动态执行的策略。</p>
</li>
<li>外部调用了System.gc，且设置了ExplicitGCInvokesConcurrent；需要注意，在hotspot 6中，在这种情况下如应用同时使用了NIO，可能会出现bug。</li>
</ol>
<p><strong>WEB SERVER 选择并行GC + CMS即可</strong></p>
<p><strong>默认GC组合</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm-default.png">

<p><strong>可选的GC组合</strong></p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-gc-algorithm-option-combination.png">


<h4 id="GC监测">GC监测</h4>
<p>命令行工具</p>
<pre><code>jstat –gcutil [pid] [intervel] [count]
-<span class="ruby"><span class="symbol">verbose:</span>gc /<span class="regexp">/ 可以辅助输出一些详细的GC信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDetails</span> /<span class="regexp">/ 输出GC详细信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCApplicationStoppedTime</span> /<span class="regexp">/ 输出GC造成应用暂停的时间
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDateStamps</span> /<span class="regexp">/ GC发生的时间信息；
</span></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintHeapAtGC</span> /<span class="regexp">/ 在GC前后输出堆中各个区域的大小；
</span></span>-<span class="ruby"><span class="constant">Xloggc</span><span class="symbol">:</span>[file] /<span class="regexp">/ 将GC信息输出到单独的文件中，建议都加上，这个消耗不大，而且对查问题和调优有很大的帮助。gc的日志拿下来后可使用GCLogViewer或gchisto进行分析。</span></span>
</code></pre><p>也可以用图形化工具jvisualvm进行分析</p>
<h4 id="系统调优方法">系统调优方法</h4>
<p>调优步骤：</p>
<ol>
<li>评估现状 </li>
<li>设定目标 </li>
<li>尝试调优 </li>
<li>衡量调优</li>
<li>细微调整</li>
</ol>
<p><strong>设定目标：</strong></p>
<ol>
<li>降低Full GC的执行频率？</li>
<li>降低Full GC的消耗时间？</li>
<li>降低Full GC所造成的应用停顿时间？</li>
<li>降低Minor GC执行频率？</li>
<li>降低Minor GC消耗时间？<br>例如某系统的GC调优目标：降低Full GC执行频率的同时，尽可能降低minor GC的执行频率、消耗时间以及GC对应用造成的停顿时间。</li>
</ol>
<p><strong>衡量调优：</strong></p>
<p>1、衡量工具<br>    1）打印GC日志信息：-XX:+PrintGCDetails –XX:+PrintGCApplicationStoppedTime     -Xloggc: {文件名}  -XX:+PrintGCTimeStamps</p>
<pre><code><span class="number">2</span>）jmap：（由于每个版本<span class="keyword">jvm</span>的默认值可能会有改变，建议还是用jmap首先观察下目前每个代的内存大小、<span class="type">GC</span>方式） 

<span class="number">3</span>）运行状况监测工具：jstat、jvisualvm、sar 、gclogviewer
</code></pre><p>2、应收集的信息<br>    1）minor gc的执行频率；full gc的执行频率，每次GC耗时多少？</p>
<pre><code><span class="number">2</span>）高峰期什么状况？

<span class="number">3</span>）minor gc回收的效果如何？survivor的消耗状况如何，每次有多少对象会进入老生代？

<span class="number">4</span>）full gc回收的效果如何？（简单的memory leak判断方法）

<span class="number">5</span>）系统的<span class="built_in">load</span>、cpu消耗、qps <span class="keyword">or</span> tps、响应时间
</code></pre><p>QPS每秒查询率：是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。在因特网上，作为域名服务器的机器性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。<br>TPS(Transaction Per Second)：每秒钟系统能够处理的交易或事务的数量。</p>
<p><strong>尝试调优：</strong></p>
<p>注意Java RMI的定时GC触发机制，可通过：-XX:+DisableExplicitGC来禁止或通过 -Dsun.rmi.dgc.server.gcInterval=3600000来控制触发的时间。</p>
<p>1）降低Full GC执行频率 – 通常瓶颈<br>老生代本身占用的内存空间就一直偏高，所以只要稍微放点对象到老生代，就full GC了；<br>通常原因：系统缓存的东西太多；<br>例如：使用oracle 10g驱动时preparedstatement cache太大；<br>查找办法：现执行Dump然后再进行MAT分析；</p>
<p>（1）Minor GC后总是有对象不断的进入老生代，导致老生代不断的满<br>通常原因：Survivor太小了<br>系统表现：系统响应太慢、请求量太大、每次请求分配的内存太多、分配的对象太大…<br>查找办法：分析两次minor GC之间到底哪些地方分配了内存；<br>利用jstat观察Survivor的消耗状况，-XX:PrintHeapAtGC，输出GC前后的详细信息；<br>对于系统响应慢可以采用系统优化，不是GC优化的内容；</p>
<p>（2）老生代的内存占用一直偏高<br>调优方法：① 扩大老生代的大小（减少新生代的大小或调大heap的 大小）；<br>减少new注意对minor gc的影响并且同时有可能造成full gc还是严重；<br>调大heap注意full gc的时间的延长，cpu够强悍嘛，os是32 bit的吗？<br>② 程序优化（去掉一些不必要的缓存）</p>
<p>（3）Minor GC后总是有对象不断的进入老生代<br>前提：这些进入老生代的对象在full GC时大部分都会被回收<br>调优方法：<br>① 降低Minor GC的执行频率；<br>② 让对象尽量在Minor GC中就被回收掉：增大Eden区、增大survivor、增大TenuringThreshold；注意这些可能会造成minor gc执行频繁；<br>③ 切换成CMS GC：老生代还没有满就回收掉，从而降低Full GC触发的可能性；<br>④ 程序优化：提升响应速度、降低每次请求分配的内存、</p>
<p>（4）降低单次Full GC的执行时间<br>通常原因：老生代太大了…<br>调优方法：1）是并行GC吗？   2）升级CPU  3）减小Heap或老生代</p>
<p>（5）降低Minor GC执行频率<br>通常原因：每次请求分配的内存多、请求量大<br>通常办法：1）扩大heap、扩大新生代、扩大eden。注意点：降低每次请求分配的内存；横向增加机器的数量分担请求的数量。</p>
<p>（6）降低Minor GC执行时间<br>通常原因：新生代太大了，响应速度太慢了，导致每次Minor GC时存活的对象多<br>通常办法：1）减小点新生代吧；2）增加CPU的数量、升级CPU的配置；加快系统的响应速度</p>
<p>细微调整：</p>
<p>首先需要了解以下情况：</p>
<p>① 当响应速度下降到多少或请求量上涨到多少时，系统会宕掉？</p>
<p>② 参数调整后系统多久会执行一次Minor GC，多久会执行一次Full GC，高峰期会如何？</p>
<p>需要计算的量：</p>
<p>①每次请求平均需要分配多少内存？系统的平均响应时间是多少呢？请求量是多少、多常时间执行一次Minor GC、Full GC？</p>
<p>②现有参数下，应该是多久一次Minor GC、Full GC，对比真实状况，做一定的调整；</p>
<p>必杀技：提升响应速度、降低每次请求分配的内存？</p>
<h4 id="垃圾回收的实现原理">垃圾回收的实现原理</h4>
<p> 内存回收的实现方法：1）引用计数：不适合复杂对象的引用关系，尤其是循环依赖的场景。2）有向图Tracing：适合于复杂对象的引用关系场景，Hotspot采用这种。常用算法：Copying、Mark-Sweep、Mark-Compact。</p>
<p>Hotspot从root set开始扫描有引用的对象并对Reference类型的对象进行特殊处理。以下是Root Set的列表：<br>1）当前正在执行的线程；<br>2）全局/静态变量；<br>3）JVM Handles；<br>4）JNI 【 Java Native Interface 】Handles；</p>
<p>另外：minor GC只扫描新生代，当老生代的对象引用了新生代的对象时，会采用如下的处理方式：在给对象赋引用时，会经过一个write barrier的过程，以便检查是否有老生代引用新生代对象的情况，如有则记录到remember set中。并在minor gc时，remember set指向的新生代对象也作为root set。</p>
<p><strong>新生代串行GC(Serial Copying)：</strong></p>
<p>新生代串行GC(Serial Copying)完整内存的分配策略：</p>
<p>1）首先在TLAB（本地线程分配缓冲区）上尝试分配；</p>
<p>2）检查是否需要在新生代上分配，如需要分配的大小小于PretenureSizeThreshold，则在eden区上进行分配，分配成功则返回；分配失败则继续；</p>
<p>3）检查是否需要尝试在老生代上分配，如需要，则遍历所有代并检查是否可在该代上分配，如可以则进行分配；如不需要在老生代上尝试分配，则继续；</p>
<p>4）根据策略决定执行新生代GC或Full GC，执行full gc时不清除soft Ref；</p>
<p>5）如需要分配的大小大于PretenureSizeThreshold，尝试在老生代上分配，否则尝试在新生代上分配；</p>
<p>6）尝试扩大堆并分配；</p>
<p>7）执行full gc，并清除所有soft Ref，按步骤5继续尝试分配。  </p>
<p>新生代串行GC(Serial Copying)完整内存回收策略<br>1）检查to是否为空，不为空返回false；</p>
<p>2）检查老生代剩余空间是否大于当前eden+from已用的大小，如大于则返回true，如小于且HandlePromotionFailure为true，则检查剩余空间是否大于之前每次minor gc晋级到老生代的平均大小，如大于返回true，如小于返回false。</p>
<p>3）如上面的结果为false，则执行full gc；如上面的结果为true，执行下面的步骤；</p>
<p>4）扫描引用关系，将活的对象copy到to space，如对象在minor gc中的存活次数超过tenuring_threshold或分配失败，则往老生代复制，如仍然复制失败，则取决于HandlePromotionFailure，如不需要处理，直接抛出OOM，并退出vm，如需处理，则保持这些新生代对象不动；</p>
<p><strong>新生代可用GC-PS</strong></p>
<p>完整内存分配策略<br>1）先在TLAB上分配，分配失败则直接在eden上分配；</p>
<p>2）当eden上分配失败时，检查需要分配的大小是否 &gt;= eden space的一半，如是，则直接在老生代分配；</p>
<p>3）如分配仍然失败，且gc已超过频率，则抛出OOM；</p>
<p>4）进入基本分配策略失败的模式；</p>
<p>5）执行PS GC，在eden上分配；</p>
<p>6）执行非最大压缩的full gc，在eden上分配；</p>
<p>7）在旧生代上分配；</p>
<p>8）执行最大压缩full gc，在eden上分配；</p>
<p>9）在旧生代上分配；</p>
<p>10）如还失败，回到2。</p>
<p>最悲惨的情况，分配触发多次PS GC和多次Full GC，直到OOM。</p>
<p>完整内存回收策略<br>1）如gc所执行的时间超过，直接结束；</p>
<p>2）先调用invoke_nopolicy<br>    2.1 先检查是不是要尝试scavenge；<br>    2.1.1 to space必须为空，如不为空，则返回false；<br>    2.1.2 获取之前所有minor gc晋级到old的平均大小，并对比目前eden+from已使用的大小，取更小的一个值，如老生代剩余空间小于此值，则返回false，如大于则返回true；<br>    2.2 如不需要尝试scavenge，则返回false，否则继续；<br>    2.3 多线程扫描活的对象，并基亍copying算法回收，回收时相应的晋升对象到旧生代；<br>    2.4 如UseAdaptiveSizePolicy，那么重新计算to space和tenuringThreshold的值，并调整。</p>
<p>3）如invoke_nopolicy返回的是false，或之前所有minor gc晋级到老生代的平均大小 &gt; 旧生代的剩余空间，那么继续下面的步骤，否则结束；</p>
<p>4）如UseParallelOldGC，则执行PSParallelCompact，如不是UseParallelOldGC，则执行PSMarkSweep。</p>
<p><strong>老生代并行CMS GC：</strong></p>
<p>优缺点：</p>
<ol>
<li>大部分时候和应用并发进行，因此只会造成很短的暂停时间；</li>
<li>浮动垃圾，没办法，所以内存空间要稍微大一点；</li>
<li>内存碎片，-XX:+UseCMSCompactAtFullCollection 来解决；</li>
<li>争抢CPU，这GC方式就这样；</li>
<li>多次remark，所以总的gc时间会比并行的长；</li>
<li>内存分配，free list方式，so性能稍差，对minor GC会有一点影响；</li>
<li>和应用并发，有可能分配和回收同时，产生竞争，引入了锁，JVM分配优先。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java设计模式(一)]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/24/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/"/>
    <id>http://www.chenbaocheng.com/2015/06/24/Java设计模式(一)/</id>
    <published>2015-06-24T07:13:11.000Z</published>
    <updated>2015-06-24T08:09:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre><a id="more"></a>

<h4 id="设计模式的六大原则">设计模式的六大原则</h4>
<h5 id="1、开闭原则（Open_Close_Principle）">1、开闭原则（Open Close Principle）</h5>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h5 id="2、里氏代换原则（Liskov_Substitution_Principle）">2、里氏代换原则（Liskov Substitution Principle）</h5>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<h5 id="3、依赖倒转原则（Dependence_Inversion_Principle）">3、依赖倒转原则（Dependence Inversion Principle）</h5>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<h5 id="4、接口隔离原则（Interface_Segregation_Principle）">4、接口隔离原则（Interface Segregation Principle）</h5>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<h5 id="5、迪米特法则（最少知道原则）（Demeter_Principle）">5、迪米特法则（最少知道原则）（Demeter Principle）</h5>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h5 id="6、合成复用原则（Composite_Reuse_Principle）">6、合成复用原则（Composite Reuse Principle）</h5>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RabbitMQ基本应用]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/16/RabbitMQ%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/06/16/RabbitMQ基本应用/</id>
    <published>2015-06-16T08:05:42.000Z</published>
    <updated>2015-06-17T04:32:11.000Z</updated>
    <content type="html"><![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br><a id="more"></a></p>
<h4 id="基本概念">基本概念</h4>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>消息队列服务器的实体</td>
</tr>
<tr>
<td>Exchange</td>
<td>消息交换机，它指定消息按什么规则，路由到哪个队列。如果没有队列绑定在exchange上面，那么发送到exchange上面的消息会丢失，一个exchange可以绑定多个队列，一个队列也可以被多个exchange绑定。声明一个已经存在的exchange，只是赋予不同的类型，则会出现创建错误，客户端需要删除已经存在的exchange，然后重新创建新类型的exchange。 exchange的属性，如果启用持久性，则exchange在服务重启前都有效，如果启用自动删除，则exchange在其绑定的queue都被删除后会自动删除掉自身。<br><strong>常用类型的exchange</strong>：<br><strong>direct</strong>：转发消息到routingkey指定的队列，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。<br><strong>topic</strong>：按照规则转发消息，对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”<em>”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.</em>”只匹配”abc.def”。<br><strong>fanout</strong>：转发消息到所有绑定的队列，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列载体，每个消息都会被投入到一个或多个队列。</td>
</tr>
<tr>
<td>Binding</td>
<td>绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</td>
</tr>
<tr>
<td>Routing Key</td>
<td>路由关键字，exchange根据这个关键字进行消息投递。</td>
</tr>
<tr>
<td>vhost</td>
<td>虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</td>
</tr>
<tr>
<td>producer</td>
<td>消息生产者，就是投递消息的程序。</td>
</tr>
<tr>
<td>consumer</td>
<td>消息消费者，就是接受消息的程序。</td>
</tr>
<tr>
<td>channel</td>
<td>消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</td>
</tr>
</tbody>
</table>
<h4 id="客户端消息投递流程">客户端消息投递流程</h4>
<ol>
<li>连接到消息队列服务器，打开一个channel</li>
<li>声明一个exchange，并设置相关属性</li>
<li>声明一个queue，并设置相关属性</li>
<li>使用routing key，在exchange和queue之间建立好绑定关系</li>
<li>投递消息到exchange,exchange接收到消息后，根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里</li>
</ol>
<h4 id="rabbitmqctl">rabbitmqctl</h4>
<pre><code>rabbitmqctl [-<span class="keyword">n</span> &lt;node&gt;] [-<span class="keyword">q</span>] &lt;<span class="keyword">command</span>&gt; [&lt;<span class="keyword">command</span> <span class="keyword">options</span>&gt;] 
-<span class="keyword">n</span> node 默认node名称是<span class="string">"rabbit@server"</span>，如果你的主机明是<span class="string">'server.example.com'</span>，那么node名称是<span class="string">'rabbit@server'</span>。
-<span class="keyword">q</span> 安静输出模式，信息会被禁止输出
</code></pre><h4 id="[_command_]">[ command ]</h4>
<p><strong>基本的管理功能</strong></p>
<pre><code>stop [&lt;pid_file&gt;]
<span class="preprocessor">#停止在erlang node上运行的rabbitmq，会使rabbitmq停止</span>

stop_app 
<span class="preprocessor">#停止erlang node上的rabbitmq的应用，但是erlang node还是会继续运行</span>

start_app
<span class="preprocessor">#启动erlan node上的rabbitmq的应用</span>

wait &lt;pid_file&gt;
<span class="preprocessor">#等待rabbitmq服务启动</span>

reset
<span class="preprocessor">#初始化node状态，会从集群中删除该节点，从管理数据库中删除所有数据，例如vhosts等等。在初始化之前rabbitmq的应用必须先停止</span>

force_reset
<span class="preprocessor">#无条件的初始化node状态</span>

rotate_logs &lt;suffix&gt;
<span class="preprocessor">#轮转日志文</span>
</code></pre><p><strong>cluster管理</strong></p>
<pre><code>join_cluster &lt;clusternode&gt; [--ram]  
<span class="preprocessor">#clusternode表示node名称，--ram表示node以ram node加入集群中。默认node以disc node加入集群，在一个node加入cluster之前，必须先停止该node的rabbitmq应用，即先执行stop_app。</span>

cluster_status  
<span class="preprocessor">#显示cluster中的所有node</span>

change_cluster_node_type disc | ram  
<span class="preprocessor">#改变一个cluster中node的模式，该节点在转换前必须先停止，不能把一个集群中唯一的disk node转化为ram node</span>

forget_cluster_node [--offline]  
<span class="preprocessor">#远程移除cluster中的一个node，前提是该node必须处于offline状态，如果是online状态，则需要加--offline参数。</span>

update_cluster_nodes clusternode   

sync_queue queue  
<span class="preprocessor">#同步镜像队列</span>

cancel_sync_queue queue    
</code></pre><p><strong>用户管理</strong></p>
<pre><code>add_user <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;password&gt;</span>  
<span class="comment">#在rabbitmq的内部数据库添加用户</span>

delete_user <span class="variable">&lt;username&gt;</span>  
<span class="comment">#删除一个用户</span>

change_password <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;newpassword&gt;</span>  
<span class="comment">#改变用户密码  \\改变web管理登陆密码</span>

clear_password <span class="variable">&lt;username&gt;</span> 
<span class="comment">#清除用户密码，禁止用户登录</span>

set_user_tags <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;tag&gt;</span> ...
<span class="comment">#设置用户tags</span>

list_users  
<span class="comment">#列出用户</span>

add_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#创建一个vhosts</span>

delete_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#删除一个vhosts</span>

list_vhosts [<span class="variable">&lt;vhostinfoitem&gt;</span> ...]  
<span class="comment">#列出vhosts</span>

set_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;user&gt;</span> <span class="variable">&lt;conf&gt;</span> <span class="variable">&lt;write&gt;</span> <span class="variable">&lt;read&gt;</span>  
<span class="comment">#针对一个vhosts 给用户赋予相关权限</span>

clear_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;username&gt;</span>  
<span class="comment">#清除一个用户对vhosts的权限</span>

list_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>]   
<span class="comment">#列出哪些用户可以访问该vhosts</span>

list_user_permissions <span class="variable">&lt;username&gt;</span>  
<span class="comment">#列出该用户的访问权限</span>

set_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;name&gt;</span> <span class="variable">&lt;value&gt;</span>
<span class="comment">#</span>

clear_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;key&gt;</span>
<span class="comment">#</span>

list_parameters [-p <span class="variable">&lt;vhostpath&gt;</span>]
<span class="comment">#</span>
</code></pre><p><strong>policy管理，策略用来控制和修改queues和exchange在集群中的行为，策略可以应用到vhost</strong></p>
<pre><code>set_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] [--priority <span class="variable">&lt;priority&gt;</span>] [--apply-to <span class="variable">&lt;apply-to&gt;</span>]  
<span class="variable">&lt;name&gt;</span> <span class="variable">&lt;pattern&gt;</span> <span class="variable">&lt;definition&gt;</span>    
<span class="comment">#name 策略名称，pattern  正则表达式，用来匹配资源，符合的就会应用设置的策略，apply-to 表示策略应用到什么类型的地方，一般有queues、exchange和all，默认是all。priority 是个整数优先级，definition 是json格式设置的策略。</span>

clear_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;name&gt;</span>  
<span class="comment">#清除一个策略</span>

list_policies [-p <span class="variable">&lt;vhostpath&gt;</span>]  
<span class="comment">#列出已有的策略</span>
</code></pre><p><strong>queues &amp;&amp; exchange状态信息</strong></p>
<pre><code>list_queues [-p &lt;vhostpath&gt;] [&lt;queueinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回queue的信息，如果省略了-p参数，则默认显示的是"/"vhosts的信息。</span>

list_exchanges [-p &lt;vhostpath&gt;] [&lt;exchangeinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回exchange的信息。</span>

list_bindings [-p &lt;vhostpath&gt;] [&lt;bindinginfoitem&gt; <span class="keyword">...</span>] 
<span class="comment">#返回绑定信息。</span>

list_connections [&lt;connectioninfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回链接信息。</span>

list_channels [&lt;channelinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回目前所有的channels。</span>

list_consumers [-p &lt;vhostpath&gt;]  
<span class="comment">#返回consumers，</span>

status  
<span class="comment">#显示broker的状态</span>

environment  
<span class="comment">#显示环境参数的信息</span>

report  
<span class="comment">#返回一个服务状态report，</span>

eval &lt;expr&gt;
</code></pre><h4 id="rabbitmq-plugins_插件的开启和关闭">rabbitmq-plugins 插件的开启和关闭</h4>
<pre><code>rabbitmq-plugins &lt;command&gt; [&lt;command options&gt;]
Commands:
list [-v] [-m] [-E] [-e] [&lt;pattern&gt;]  显示所有的的插件。-v 显示版本 -m 显示名称 -E 显示明确已经开启的 -e显示明确的和暗中开启的
enable &lt;plugin&gt; <span class="keyword">...</span>   开启一个插件
disable &lt;plugin&gt; <span class="keyword">...</span>  关闭一个插件
</code></pre><h4 id="开启rabbitmq_management,_插件在安装目录的/plugins下面">开启rabbitmq_management, 插件在安装目录的/plugins下面</h4>
<pre><code>rabbitmq-plugins enable rabbitmq_management
abbitmq_management提供一个基于HTTP的API接口，来管理和监控你的rabbitmq。他有web方式和<span class="keyword">CLI</span>方式，其实web方式是在后端调用HTTP api
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM性能监控工具]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/JVM性能监控工具/</id>
    <published>2015-06-15T07:50:07.000Z</published>
    <updated>2015-06-15T08:10:36.000Z</updated>
    <content type="html"><![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<a id="more"></a>

<hr>
<h4 id="jps_虚拟机进程状况工具">jps 虚拟机进程状况工具</h4>
<pre><code>命令格式：
<span class="tag">jps</span> <span class="attr_selector">[options]</span> <span class="attr_selector">[hostid]</span>

<span class="tag">jps</span> 可以查看通过 <span class="tag">rmi</span> 协议查询开启了 <span class="tag">rmi</span> 服务的原创虚拟机进程状态，<span class="tag">hostid</span> 是 <span class="tag">rmi</span> 注册表中注册的主机。
</code></pre><h6 id="options">options</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>只输出 LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机启动时候传递给 main 方法的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出类的全名</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时 JVM 参数</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="jstack_分析_java_堆栈">jstack 分析 java 堆栈</h4>
<p>jstack 用来生成当前时刻线程快照。</p>
<pre><code>命令格式：
jstack [ <span class="preprocessor">option</span> ] pid
jstack [ <span class="preprocessor">option</span> ] executable core
jstack [ <span class="preprocessor">option</span> ] [server-id@]remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jstat_虚拟机统计信息监视工具">jstat 虚拟机统计信息监视工具</h4>
<p>jstat 可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、 JIT 编译等运行数据。</p>
<pre><code>命令格式：
<span class="tag">jstat</span> <span class="attr_selector">[option vmid [interval]</span> <span class="attr_selector">[count]</span>]
</code></pre><h6 id="option">option</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总看见以及类装载消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视 java 堆状况，包括 eden 区、两个 survivor 区、年老代、永久代等的容量、已用空间、gc 时间合计等</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>内容与 -gc 基本相同，输出主要关注 java 堆各个区使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>内容与 -gc 基本相同，关注已使用区域占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>内容与 -gcutil 一样，并且多输出导致上一次 gc 产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>与 -gcnew 相同，主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出 JIT 编译器编译过的方法、耗时等信息</td>
</tr>
</tbody>
</table>
<h6 id="-gcutil_所产生的内容：">-gcutil 所产生的内容：</h6>
<pre><code>S0、S1 分别代表了 Survivor0 和 Survivor1;
<span class="keyword">E</span> 代表 Eden 区;
<span class="keyword">O</span> 代表老年区;
P 代表永久代;
YGC 代表 Young GC 的次数;
YGCT 代表时间
</code></pre><hr>
<h4 id="jinfo_查看_java_配置信息工具">jinfo 查看 java 配置信息工具</h4>
<pre><code>命令格式：
jinfo [ <span class="preprocessor">option</span> ] pid
jinfo [ <span class="preprocessor">option</span> ] executable core
jinfo [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jmap_生产_java_内存_dump">jmap 生产 java 内存 dump</h4>
<p>jmap 除了可以生成 dump 文件外，还可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率和当前用的是哪种收集器等。</p>
<pre><code>命令格式：
jmap [ <span class="preprocessor">option</span> ] pid
jmap [ <span class="preprocessor">option</span> ] executable core
jmap [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><h6 id="option-1">option</h6>
<pre><code>-<span class="ruby">heap
</span>-<span class="ruby">permstat</span>
</code></pre><hr>
<h4 id="jhat_虚拟机堆快照分析工具">jhat 虚拟机堆快照分析工具</h4>
<p>我们可以使用 jhat 来分析 jmap 生成的 dump 文件。默认会开 7000 端口进行 web 访问。一般不使用这个命令来分析，会使用专业的工具来分析 dump 文件，如 eclipse memory analyzer 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X下使用 Charles 进行抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/Mac-OS-X%E4%B8%8B%E4%BD%BF%E7%94%A8-Charles-%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/Mac-OS-X下使用-Charles-进行抓包/</id>
    <published>2015-06-15T07:14:12.000Z</published>
    <updated>2015-06-15T07:40:25.000Z</updated>
    <content type="html"><![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">http://www.charlesproxy.com/</a></p>
<h4 id="2、启动_Charles，支持正版，如需破解请自行搜索">2、启动 Charles，支持正版，如需破解请自行搜索</h4>
<h4 id="3、手机设置代理,_以_iPhone_为例">3、手机设置代理, 以 iPhone 为例</h4>
<p>设置-无线局域网-选择已连接的局域网-HTTP代理-手动，服务器：你电脑的 IP，端口：8888</p>
<p>第一次用手机请求网络时，Charles会提示是否允许接入，选择Allow就可以了。</p>
<p>如果是 HTTPS 抓包，需要安装证书，证书地址：<a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" t]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS环境使用wireshark抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/07/MacOS%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8wireshark%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/05/07/MacOS环境使用wireshark抓包/</id>
    <published>2015-05-07T04:17:31.000Z</published>
    <updated>2015-05-07T04:47:46.000Z</updated>
    <content type="html"><![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p><a id="more"></a></p>
<h5 id="端口过滤">端口过滤</h5>
<pre><code><span class="comment">#tcp</span>
tcp.<span class="variable">port =</span>= <span class="number">80</span>
tcp.<span class="variable">dstport =</span>= <span class="number">80</span>
tcp.<span class="variable">srcport =</span>= <span class="number">80</span>
<span class="comment">#udp</span>
udp.<span class="variable">port =</span>= <span class="number">80</span>
udp.<span class="variable">dstport =</span>= <span class="number">80</span>
udp.<span class="variable">srcport =</span>= <span class="number">80</span>
</code></pre><h5 id="协议过滤">协议过滤</h5>
<pre><code><span class="preprocessor">#支持的协议</span>
udp
arp
icmp
http
smtp
ftp
dns
msnms
ip
ssl
<span class="preprocessor">#例如过滤协议为不是 UDP 的请求</span>
!udp
</code></pre><h5 id="包长度过滤：">包长度过滤：</h5>
<pre><code><span class="preprocessor">#30 = udp本身固定长度8 + 数据包长度22</span>
udp.length == <span class="number">30</span>
<span class="preprocessor">#指ip数据包长度,不包括tcp本身长度</span>
tcp.len &gt;= <span class="number">10</span> 
<span class="preprocessor">#除以太网头固定长度14,其它都算是ip.len,即从ip本身到最后</span>
ip.len == <span class="number">94</span> 
<span class="preprocessor">#整个数据包长度,从eth开始到最后</span>
frame.len == <span class="number">119</span> 
</code></pre><h5 id="HTTP模式过滤">HTTP模式过滤</h5>
<pre><code><span class="comment">#请求类型过滤</span>
http.request.<span class="keyword">method</span> == “[<span class="type">GET</span>|<span class="type">POST</span>|<span class="type">DELETE</span>|<span class="type">PUT</span>]”
<span class="comment">#请求地址过滤</span>
http.request.uri == “/resume/index”
<span class="comment">#包含 GET 字符串的</span>
http contains “<span class="type">GET</span>”
</code></pre><h5 id="多过滤条件">多过滤条件</h5>
<pre><code>#多过滤条件用  <span class="built_in">and</span> | <span class="built_in">or</span> 链接
</code></pre><h5 id="正则过滤">正则过滤</h5>
<pre><code><span class="operator">matches</span>
<span class="comment">#举个例子</span>
http <span class="operator">matches</span> “/corp/\d+/*”
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(四) Dockerfile]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/05/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-Dockerfile/"/>
    <id>http://www.chenbaocheng.com/2015/05/05/Docker学习-四-Dockerfile/</id>
    <published>2015-05-05T07:37:57.000Z</published>
    <updated>2015-05-05T08:47:33.000Z</updated>
    <content type="html"><![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p><a id="more"></a></p>
<h5 id="RUN命令">RUN命令</h5>
<pre><code><span class="comment"># RUN命令会在上面FROM指定的镜像里执行任何命令，然后提交(commit)结果。RUN是在building image时会运行的指令, 在Dockerfile中可以写多条RUN指令.</span>

RUN &lt;command&gt; (the command is run <span class="keyword">in</span> a shell - `/bin/sh -c`)
或
RUN [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span> <span class="keyword">...</span> ]  (exec form)

<span class="comment">#RUN命令等价于:</span>
docker run image command
docker commit container_id
</code></pre><h5 id="ENTRYPOINT命令">ENTRYPOINT命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>

ENTRYPOINT [<span class="string">"cmd"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span><span class="keyword">...</span>]
或
ENTRYPOINT cmd param1 param2 <span class="keyword">...</span>

<span class="comment">#举个例子</span>
cbc ~ <span class="comment"># cat Dockerfile</span>
FROM tomcat
ENTRYPOINT echo <span class="string">"Hello world!"</span>

cbc ~ <span class="comment"># docker run 62fda5e450d5</span>
Hello world!
</code></pre><h5 id="CMD命令">CMD命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>
CMD [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>] (like <span class="operator">an</span> exec, preferred form)
或
CMD [<span class="string">"param1"</span>,<span class="string">"param2"</span>] (<span class="keyword">as</span> default parameters <span class="built_in">to</span> ENTRYPOINT)
或
CMD <span class="command"><span class="keyword">command</span> <span class="title">param1</span> <span class="title">param2</span> (<span class="title">as</span> <span class="title">a</span> <span class="title">shell</span>)</span>
</code></pre><h6 id="#CMD和ENTRYPOINT是在运行container时会运行的指令,_都只能写一条,_如果写多条,_只有最后一条生效。CMD在运行时会被command覆盖,_ENTRYPOINT不会被运行时的command覆盖,_如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image,_例如apache,_mysql等-_在使用这种image启动container时,_自动启动相关服务-下面的示例_psql_会覆盖_Dockerfile_里的_CMD">#CMD和ENTRYPOINT是在运行container时会运行的指令, 都只能写一条, 如果写多条, 只有最后一条生效。CMD在运行时会被command覆盖, ENTRYPOINT不会被运行时的command覆盖, 如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image, 例如apache, mysql等. 在使用这种image启动container时, 自动启动相关服务.下面的示例 psql 会覆盖 Dockerfile 里的 CMD</h6>
<pre><code>docker run postgre<span class="variable">s:9</span>.<span class="number">3.5</span> psql 
</code></pre><h5 id="USER命令">USER命令</h5>
<pre><code><span class="preprocessor">#指定 ENTRYPOINT 执行命令时的运行用户,下面的例子是指开机启动 NGINX 时用 www 用户身份启动。</span>

ENTRYPOINT [<span class="string">"nginx"</span>]
USER www
</code></pre><h5 id="EXPOSE命令">EXPOSE命令</h5>
<pre><code><span class="comment">#设置镜像运行时对外暴露的端口</span>
EXPOSE &lt;port&gt; [&lt;port&gt;<span class="keyword">...</span>]
</code></pre><h5 id="ENV命令">ENV命令</h5>
<pre><code><span class="input"><span class="prompt">#设置环境变量，设置后，后续的RUN命令都可以使用该环境变量
ENV &lt;key&gt;</span> &lt;value&gt;</span>
</code></pre><h5 id="ADD命令">ADD命令</h5>
<pre><code><span class="input"><span class="prompt">#从src复制文件到容器的dest路径。src可以是文件、目录或一个远程url。
ADD &lt;src&gt;</span> &lt;dest&gt;</span>
</code></pre><h5 id="VOLUME命令">VOLUME命令</h5>
<pre><code><span class="preprocessor">#创建一个挂载点用于共享目录</span>
VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]
</code></pre><h5 id="WORKDIR命令">WORKDIR命令</h5>
<pre><code><span class="preprocessor">#为RUN, CMD, ENTRYPOINT命令设置当前工作路径</span>
WORKDIR /path/to/workdir
</code></pre><h5 id="ONBUILD命令">ONBUILD命令</h5>
<pre><code><span class="preprocessor">#ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(三) Docker镜像和容器的常用操作]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%89-Docker%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/</id>
    <published>2015-04-30T08:06:29.000Z</published>
    <updated>2015-07-10T03:54:26.000Z</updated>
    <content type="html"><![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre><a id="more"></a>

<h5 id="查找镜像">查找镜像</h5>
<pre><code>这里我们是找一个名为tengine的镜像，tengine是淘宝版的nginx

cbc ~ <span class="comment"># docker search tengine</span>
NAME                           DESCRIPTION   STARS     OFFICIAL   AUTOMATED
mimosa/tengine                               <span class="number">1</span>                    [OK]
netengine/renderer-nginx                     <span class="number">1</span>                    [OK]
utgard/tengine                               <span class="number">0</span>                    [OK]
sugamele/tengine               Tengine       <span class="number">0</span>
vpanton/docker-tengine-dyups                 <span class="number">0</span>                    [OK]
hyperboloide/tengine                         <span class="number">0</span>
guilhem30/updatengine                        <span class="number">0</span>                    [OK]
</code></pre><h5 id="获取镜像">获取镜像</h5>
<pre><code>cbc ~ <span class="comment"># docker pull mimosa/tengine</span>
<span class="constant">Pulling</span> repository mimosa/tengine
<span class="symbol">f614dc8befa6:</span> <span class="constant">Pulling</span> dependent layers
<span class="number">511136</span><span class="symbol">ea3c5a:</span> <span class="constant">Download</span> complete
<span class="number">5</span><span class="symbol">e66087f3ffe:</span> <span class="constant">Downloading</span> <span class="number">17.96</span> <span class="constant">MB</span>

<span class="comment"># 下载过程中，会输出获取镜像的每一层信息。</span>
<span class="comment"># 你可以按照下面的格式从指定注册服务器的仓库下载相应标记的镜像：</span>
docker pull 注册服务器地址[<span class="symbol">:</span>端口号]/仓库名<span class="symbol">:TAG</span>名称
</code></pre><h4 id="删除镜像">删除镜像</h4>
<pre><code>docker rmi ae0c2d0bdc10
<span class="preprocessor"># 移除镜像前，先移除依赖该镜像的容器</span>
</code></pre><h4 id="使用镜像创建一个容器">使用镜像创建一个容器</h4>
<pre><code>格式 : docker run [OPTIONS]<span class="constant"> IMAGE </span>[COMMAND] [ARG...]

cbc ~ # docker run -itd --name tengine01 mimosa/tengine /bin/bash -v /tmp:/mnt
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -t 让docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入</span>
<span class="preprocessor"># -i 让容器的标准输入保持打开</span>
<span class="preprocessor"># -d 让容器在后台以守护进程（Daemonized）形式运行</span>
<span class="preprocessor"># --name 给容器起个名儿</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互    </span>
<span class="preprocessor"># -v 把一个本地主机的目录当做数据卷挂载在容器上, 格式 : [host-dir]:[container-dir]:[rw|ro],</span>
</code></pre><h4 id="导出镜像到本地文件">导出镜像到本地文件</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker save -o tengine.tar mimosa/tengine
</code></pre><h4 id="从本地文件导入镜像">从本地文件导入镜像</h4>
<pre><code>docker <span class="built_in">load</span> <span class="comment">--input tengine.tar</span>
或者
docker <span class="built_in">load</span> &lt; tengine.tar
</code></pre><h4 id="查看容器状态">查看容器状态</h4>
<pre><code>cbc ~ <span class="comment"># docker ps -a</span>
CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS                      PORTS               NAMES
ca98201350dd        mimosa/tengine:latest   <span class="string">"/bin/bash"</span>         <span class="number">19</span> minutes ago      Up <span class="number">9</span> minutes                <span class="number">443</span>/tcp, <span class="number">80</span>/tcp     grave_albattani
b02c528c3cad        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (<span class="number">127</span>) <span class="number">2</span> hours ago                        furious_einstein
cf769788d09e        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (-<span class="number">1</span>) <span class="number">2</span> hours ago                         agitated_mclean
f706bbb258a1        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">3</span> hours ago         Exited (<span class="number">130</span>) <span class="number">3</span> hours ago                        goofy_yonath
<span class="number">574871</span>d84dc2        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">127</span>) <span class="number">5</span> months ago                       cocky_wilson
<span class="number">47381902</span><span class="built_in">cd</span>50        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         mad_feynman
ee19f69f978c        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         high_bohr
a7e4a6d0c994        ae0c2d0bdc10            <span class="string">"/usr/bin/"</span>         <span class="number">5</span> months ago                                                        drunk_pike
ad418b05441f        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago                                                        sick_colden
dffb9f3f6677        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         determined_shockley
e9297baee616        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         thirsty_pare
</code></pre><h4 id="从终止状态启动一个容器">从终止状态启动一个容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker start ca98201350dd
ca98201350dd 
</code></pre><h4 id="停止容器">停止容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker stop ca98201350dd 
</code></pre><h4 id="重启容器">重启容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker restart ca98201350dd
ca98201350dd
</code></pre><h4 id="进入一个运行状态的容器">进入一个运行状态的容器</h4>
<pre><code>cbc ~ <span class="comment"># docker attach ca98201350dd</span>
[ root<span class="variable">@ca98201350dd</span><span class="symbol">:/etc/nginx</span> ]$
</code></pre><h4 id="删除容器">删除容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker rm 4d72d9a0066d
4d72d9a0066d 
</code></pre><h4 id="导出容器">导出容器</h4>
<pre><code><span class="input"><span class="prompt">docker export ca98201350dd &gt;</span> tengine.dock.tar</span>
</code></pre><h4 id="导入容器快照">导入容器快照</h4>
<pre><code>cbc ~ <span class="comment"># cat tengine.dock.tar | docker import - cbc009/tengine</span>
<span class="number">67e225223716</span>ff791c78bcc546695e530a37358e0c86b72a7a5bff2fbfbb6228

或从<span class="built_in">URL</span>导入

docker import <span class="built_in">URL</span> REPOSITORY

查看一下结果：
cbc ~ <span class="comment"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
cbc009/tengine      latest              <span class="number">67e225223716</span>        <span class="number">2</span> minutes ago       <span class="number">593.5</span> MB
</code></pre><h4 id="外部访问容器，对容器网络端口映射">外部访问容器，对容器网络端口映射</h4>
<pre><code>cbc ~ # docker run -itdP mimosa/tengine /bin/bash
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -P Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口</span>
<span class="preprocessor"># -p 参数小写的p可以手动指定要映射的端口。一个指定端口只可以绑定一个容器，也可以指定端口类型。支持的格式有：ip:hostPort:containerPort[/protocol] | ip::containerPort[/protocol] | hostPort:containerPort[/protocol]</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互</span>

<span class="preprocessor"># 用 docker ps -l查看最后一个被创建的容器，访问49154端口可以看到 tengine 的欢迎页。</span>
<span class="preprocessor"># 现在我可以通过工作电脑访问容器的物理机：http://192.168.11.185:49154/</span>
cbc ~ # docker ps -l
CONTAINER<span class="constant"> ID </span>      <span class="constant"> IMAGE </span>                 <span class="constant"> COMMAND </span>           <span class="constant"> CREATED </span>           <span class="constant"> STATUS </span>            <span class="constant"> PORTS </span>                                          NAMES
<span class="number">1</span>dd4e24df270        mimosa/tengine:latest   <span class="string">"nginx"</span>             <span class="number">7</span> minutes ago       Up <span class="number">7</span> minutes        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49153</span>-&gt;<span class="number">443</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49154</span>-&gt;<span class="number">80</span>/tcp   naughty_hypatia
</code></pre><h4 id="查看网络端口映射情况">查看网络端口映射情况</h4>
<pre><code>docker <span class="keyword">port</span> <span class="number">1</span>dd4e24df270 <span class="number">80</span>
</code></pre><p>至此镜像和容器的基本操作学习完了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(二) 安装与配置]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-二-安装与配置/</id>
    <published>2015-04-30T07:50:46.000Z</published>
    <updated>2015-07-10T10:56:00.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p><a id="more"></a>    </p>
<pre><code><span class="preprocessor">#安装</span>
yum install docker-io
</code></pre><h4 id="CentOS_7_下安装Docker服务">CentOS 7 下安装Docker服务</h4>
<p>Centos 7 开始 CentOS-Extras 库自带 Docker，所以安装会相对更简单.</p>
<pre><code>yum <span class="operator"><span class="keyword">install</span> docker</span>
</code></pre><h4 id="启动_Docker">启动 Docker</h4>
<pre><code><span class="class"><span class="keyword">service</span> <span class="title">docker</span> start</span>
</code></pre><h4 id="开机启动">开机启动</h4>
<pre><code>chkconfig docker <span class="command"><span class="keyword">on</span></span>
</code></pre><h4 id="安装Compose">安装Compose</h4>
<pre><code>curl -<span class="constant">L </span><span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/compose/releases</span><span class="regexp">/download/</span><span class="number">1.3</span>.<span class="number">1</span>/docker-compose-`uname -s`-`uname -m` &gt; <span class="regexp">/usr/local</span><span class="regexp">/bin/docker</span>-compose
<span class="comment">#如果这一步不成功，手动下载，scp不过去吧。。。</span>
chmod +x /usr/local/bin/docker-compose
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(一) Docker基础]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%80-Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-一-Docker基础/</id>
    <published>2015-04-30T07:28:12.000Z</published>
    <updated>2015-04-30T08:02:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br><a id="more"></a><br><strong>container,容器</strong>，容器是从镜像创建的运行实例，一台物理机可以运行 成百上千个容器，容器之间是相互隔离的。容器可以通过相关命令启动，开始，停止，删除。</p>
<p><strong>repository,仓库</strong>，分为公共和私有两种。默认是从公共仓库获取 image.</p>
<h5 id="下面有一个表格对比了传统虚拟机和docker的区别：">下面有一个表格对比了传统虚拟机和docker的区别：</h5>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">容器</th>
<th style="text-align:right">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:right">分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td style="text-align:center">通常为MB</td>
<td style="text-align:right">通常为GB</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:right">弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td style="text-align:center">单机支持上千容器</td>
<td style="text-align:right">一般几十个虚拟机</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux开机获取IP发送到指定邮箱]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Linux%E5%BC%80%E6%9C%BA%E8%8E%B7%E5%8F%96IP%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Linux开机获取IP发送到指定邮箱/</id>
    <published>2015-04-30T05:20:19.000Z</published>
    <updated>2015-07-09T07:14:03.000Z</updated>
    <content type="html"><![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br><a id="more"></a><br>2、修改配置文件</p>
<p>vim  /etc/mail.rc</p>
<p>添加如下内容：<br>set from=xxxxxx@163.com smtp=smtp.163.com smtp-auth-user={username} smtp-auth-password={password} smtp-auth=login</p>
<p>3、配置开机发邮件</p>
<p>vim /etc/rc.local</p>
<p>ifconfig | mail -s “重启开机邮件 - 最新 IP” xxxx@xxxx.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://www.chenbaocheng.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 github 放一个spring-boot-jpa DEMO]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/29/%E5%9C%A8-github-%E5%8F%91%E4%B8%80%E4%B8%AAspring-boot-jpa-DEMO/"/>
    <id>http://www.chenbaocheng.com/2015/04/29/在-github-发一个spring-boot-jpa-DEMO/</id>
    <published>2015-04-29T08:58:12.000Z</published>
    <updated>2015-05-19T08:02:06.000Z</updated>
    <content type="html"><![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entity，声明 Dao，在 Service 层包装一下业务, controller 里去做 WEB 页面展示的准备工作就好了。</p>
<p>这个DEMO主要演示基于 spring boot 的项目开发，如何使用 jpa 对数据库 CRUD 操作，如何用 freemarker 展示页面。</p>
<p>项目地址：<a href="https://github.com/cbc009/spring-boot-jpa" target="_blank" rel="external">spring-boot-jpa DEMO</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entit]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java : Unsupported major.minor version 51.0解决方法]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/"/>
    <id>http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/</id>
    <published>2015-04-23T06:44:35.000Z</published>
    <updated>2015-04-28T03:53:43.000Z</updated>
    <content type="html"><![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
<a id="more"></a>

<p>51.0是对应JDK1.7, 看一下当前的 java 版本什么呢？<br>$ java -version<br>java version “1.7.0_79”<br>Java(TM) SE Runtime Environment (build 1.7.0_79-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</p>
<p>看起来JDK没问题。</p>
<p>那会不会是 intellij 默认用1.6启动的呢？<br>$ vim /Applications/IntelliJ\ IDEA\ 14.app/Contents/Info.plist</p>
<p>100、101行：<br>      <key>JVMVersion</key><br>      <string>1.6,1.7<em></em></string><br>看起来像是这里的问题，修改一下，把1.6去掉试试:<br>      <key>JVMVersion</key><br>      <string>1.7</string></p>
<p>保存，重新启动Intellij Idea, 出现提示:您要应用程序“Intellij Idea 14.app”接受传入网络连接吗?这是由于修改应用内文件导致Apple 签名失效了。简单粗暴解决一下，进入系统管理-关闭防火墙即可。</p>
<p>重新启动软件，一切正常了~~~ Intellij idea 为什么不默认使用系统 JDK 版本呢？或者给用户一个修改 JDK 版本的界面？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
</feed>

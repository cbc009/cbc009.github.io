<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CHENBAOCHENG.COM]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.chenbaocheng.com/"/>
  <updated>2015-06-26T09:45:26.491Z</updated>
  <id>http://www.chenbaocheng.com/</id>
  
  <author>
    <name><![CDATA[CBC]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JVM内存管理与垃圾回收]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/26/Java%E5%A0%86%E5%86%85%E5%AD%98/"/>
    <id>http://www.chenbaocheng.com/2015/06/26/Java堆内存/</id>
    <published>2015-06-26T03:53:26.000Z</published>
    <updated>2015-06-26T09:35:13.000Z</updated>
    <content type="html"><![CDATA[<p>因为Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

<a id="more"></a>

<h4 id="JVM_运行时数据区域">JVM 运行时数据区域</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm_memory_structure.png">

<p>Java 虚拟机在执行Java 程序过程中会把它所管理的内存划分为几个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p>这几个区域如下：</p>
<pre><code>方法区（<span class="function"><span class="keyword">Method</span> <span class="title">Area</span>）
虚拟机栈（<span class="title">VM</span> <span class="title">Stack</span>）
本地方法栈（<span class="title">Natvie</span> <span class="title">Method</span> <span class="title">Stack</span>）
堆（<span class="title">Heap</span>）
程序计数器（<span class="title">Program</span> <span class="title">Counter</span> <span class="title">Register</span>）</span>
</code></pre><h4 id="JVM中Stack和Heap的关系">JVM中Stack和Heap的关系</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们经常会把 Java 内存分为堆内存（Heap）和栈内存（Stack），这是一种比较粗糙区分方式。我们平时所关注的也主要是这两个区域。栈指的是上图中的Java虚拟机栈。Java 虚拟机栈是线程私有的，其生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息，<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-thread-stack.gif">

<p>&nbsp;&nbsp;&nbsp;&nbsp;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和 returnAddress（指向一条字节码指令的地址）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果线程请求的栈深度大于虚拟机允许的深度，会抛出 StackOverflowException 异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够内存时会抛出 OutOfMemoryError 异常。递归调用时如果深度过深，很容易出现栈溢出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用程序来说，堆(Heap)是Java虚拟机管理的内存中最大的一块。 堆是所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在Java体系中，即便是最简单的对象访问，也会涉及栈、堆、方法区这三个最重要的内存区域。例如下面这行代码：</p>
<pre><code><span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;假如这段代码出现在方法体中，Object obj 这部分的语意会反映到Java虚拟机栈的本地变量表中，做为一个reference 类型数据出现。new Object()这部分语意会反映在Java堆中，形成一块存储了 Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存。不同虚拟机的对象访问方式有所不同，主流的访问方式有两种：使用句柄和直接指针。</p>
<h4 id="堆内存">堆内存</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Java中堆是JVM 管理的最大一块内存空间，主要用于存放各种类的实例对象。堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。堆的内存模型大致为：</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-memory-heap.png">

<pre><code><span class="attribute">堆大小 </span>=<span class="string"> 新生代 + 老年代</span>
</code></pre><h4 id="常用的内存区域调节参数">常用的内存区域调节参数</h4>
<pre><code>-<span class="ruby"><span class="constant">Xms</span>：初始堆大小，默认为物理内存的<span class="number">1</span>/<span class="number">64</span>(&lt;<span class="number">1</span>GB)；默认(<span class="constant">MinHeapFreeRatio</span>参数可以调整)空余堆内存小于<span class="number">40</span>%时，<span class="constant">JVM</span>就会增大堆直到-<span class="constant">Xmx</span>的最大限制
</span>
-<span class="ruby"><span class="constant">Xmx</span>：最大堆大小，默认(<span class="constant">MaxHeapFreeRatio</span>参数可以调整)空余堆内存大于<span class="number">70</span>%时，<span class="constant">JVM</span>会减少堆直到 -<span class="constant">Xms</span>的最小限制
</span>
-<span class="ruby"><span class="constant">Xmn</span>：新生代的内存空间大小，注意：此处的大小是（eden+ <span class="number">2</span> survivor space)。与jmap -heap中显示的<span class="constant">New</span> gen是不同的。整个堆大小=新生代大小 + 老生代大小 + 永久代大小。 在保证堆大小不变的情况下，增大新生代后,将会减小老生代大小。此值对系统性能影响较大,<span class="constant">Sun</span>官方推荐配置为整个堆的<span class="number">3</span>/<span class="number">8</span>。
</span>
-<span class="ruby"><span class="constant">XX</span><span class="symbol">:SurvivorRatio</span>：新生代中<span class="constant">Eden</span>区域与<span class="constant">Survivor</span>区域的容量比值，默认值为<span class="number">8</span>。两个<span class="constant">Survivor</span>区与一个<span class="constant">Eden</span>区的比值为<span class="number">2</span><span class="symbol">:</span><span class="number">8</span>,一个<span class="constant">Survivor</span>区占整个年轻代的<span class="number">1</span>/<span class="number">10</span>。
</span>
-<span class="ruby"><span class="constant">Xss</span>：每个线程的堆栈大小。<span class="constant">JDK5</span>.<span class="number">0</span>以后每个线程堆栈大小为<span class="number">1</span>M,以前每个线程堆栈大小为<span class="number">256</span>K。应根据应用的线程所需内存大小进行适当调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在<span class="number">3000</span>~<span class="number">5000</span>左右。一般小的应用， 如果栈不是很深， 应该是<span class="number">128</span>k够用的，大的应用建议使用<span class="number">256</span>k。这个选项对性能影响比较大，需要严格的测试。和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话<span class="symbol">:<span class="string">"-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。
</span></span></span>
-<span class="ruby"><span class="constant">XX</span><span class="symbol">:PermSize</span>：设置永久代(perm gen)初始值。默认值为物理内存的<span class="number">1</span>/<span class="number">64</span>。
</span>
-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxPermSize</span>：设置持久代最大值。物理内存的<span class="number">1</span>/<span class="number">4</span>。</span>
</code></pre><p>这里有一张图片简单明了的说明一下相关参数对各个区域的影响：</p>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-heap-optimize.png">

]]></content>
    <summary type="html">
    <![CDATA[<p>因为Java虚拟机拥有自动管理内存机制，所以Java 程序员不需要像C/C++一样去关注内存的分配和释放，也不容易出现内存泄露和内存溢出的问题。但是如果一旦出现此类问题，如果我们对虚拟机的内存管理机制不了解，那么解决这类问题还是比较困难的，所以我们要深入学习JVM的内存管理。</p>
<h4 id="Java代码是如何执行的？">Java代码是如何执行的？</h4>
<img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/jvm-arch.png">

]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java设计模式(一)]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/24/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)/"/>
    <id>http://www.chenbaocheng.com/2015/06/24/Java设计模式(一)/</id>
    <published>2015-06-24T07:13:11.000Z</published>
    <updated>2015-06-24T08:09:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre><a id="more"></a>

<h4 id="设计模式的六大原则">设计模式的六大原则</h4>
<h5 id="1、开闭原则（Open_Close_Principle）">1、开闭原则（Open Close Principle）</h5>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h5 id="2、里氏代换原则（Liskov_Substitution_Principle）">2、里氏代换原则（Liskov Substitution Principle）</h5>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<h5 id="3、依赖倒转原则（Dependence_Inversion_Principle）">3、依赖倒转原则（Dependence Inversion Principle）</h5>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<h5 id="4、接口隔离原则（Interface_Segregation_Principle）">4、接口隔离原则（Interface Segregation Principle）</h5>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<h5 id="5、迪米特法则（最少知道原则）（Demeter_Principle）">5、迪米特法则（最少知道原则）（Demeter Principle）</h5>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h5 id="6、合成复用原则（Composite_Reuse_Principle）">6、合成复用原则（Composite Reuse Principle）</h5>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="设计模式的分类">设计模式的分类</h4>
<p>创建型模式，共5种</p>
<pre><code><span class="bullet">1. </span>工厂方法模式
<span class="bullet">2. </span>抽象工厂模式
<span class="bullet">3. </span>单例模式
<span class="bullet">4. </span>建造者模式
<span class="bullet">5. </span>原型模式
</code></pre><p>结构型模式，共7种</p>
<pre><code><span class="bullet">1. </span>适配器模式
<span class="bullet">2. </span>装饰器模式
<span class="bullet">3. </span>代理模式
<span class="bullet">4. </span>外观模式
<span class="bullet">5. </span>桥接模式
<span class="bullet">6. </span>组合模式
<span class="bullet">7. </span>享元模式。
</code></pre><p>行为型模式，共11种：</p>
<pre><code><span class="bullet">1. </span>策略模式
<span class="bullet">2. </span>模板方法模式
<span class="bullet">3. </span>观察者模式
<span class="bullet">4. </span>迭代子模式
<span class="bullet">5. </span>责任链模式
<span class="bullet">6. </span>命令模式
<span class="bullet">7. </span>备忘录模式
<span class="bullet">8. </span>状态模式
<span class="bullet">9. </span>访问者模式
<span class="bullet">10. </span>中介者模式
<span class="bullet">11. </span>解释器模式
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RabbitMQ基本应用]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/16/RabbitMQ%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/06/16/RabbitMQ基本应用/</id>
    <published>2015-06-16T08:05:42.000Z</published>
    <updated>2015-06-17T04:32:11.000Z</updated>
    <content type="html"><![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br><a id="more"></a></p>
<h4 id="基本概念">基本概念</h4>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>消息队列服务器的实体</td>
</tr>
<tr>
<td>Exchange</td>
<td>消息交换机，它指定消息按什么规则，路由到哪个队列。如果没有队列绑定在exchange上面，那么发送到exchange上面的消息会丢失，一个exchange可以绑定多个队列，一个队列也可以被多个exchange绑定。声明一个已经存在的exchange，只是赋予不同的类型，则会出现创建错误，客户端需要删除已经存在的exchange，然后重新创建新类型的exchange。 exchange的属性，如果启用持久性，则exchange在服务重启前都有效，如果启用自动删除，则exchange在其绑定的queue都被删除后会自动删除掉自身。<br><strong>常用类型的exchange</strong>：<br><strong>direct</strong>：转发消息到routingkey指定的队列，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。<br><strong>topic</strong>：按照规则转发消息，对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”<em>”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.</em>”只匹配”abc.def”。<br><strong>fanout</strong>：转发消息到所有绑定的队列，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列载体，每个消息都会被投入到一个或多个队列。</td>
</tr>
<tr>
<td>Binding</td>
<td>绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</td>
</tr>
<tr>
<td>Routing Key</td>
<td>路由关键字，exchange根据这个关键字进行消息投递。</td>
</tr>
<tr>
<td>vhost</td>
<td>虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</td>
</tr>
<tr>
<td>producer</td>
<td>消息生产者，就是投递消息的程序。</td>
</tr>
<tr>
<td>consumer</td>
<td>消息消费者，就是接受消息的程序。</td>
</tr>
<tr>
<td>channel</td>
<td>消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</td>
</tr>
</tbody>
</table>
<h4 id="客户端消息投递流程">客户端消息投递流程</h4>
<ol>
<li>连接到消息队列服务器，打开一个channel</li>
<li>声明一个exchange，并设置相关属性</li>
<li>声明一个queue，并设置相关属性</li>
<li>使用routing key，在exchange和queue之间建立好绑定关系</li>
<li>投递消息到exchange,exchange接收到消息后，根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里</li>
</ol>
<h4 id="rabbitmqctl">rabbitmqctl</h4>
<pre><code>rabbitmqctl [-<span class="keyword">n</span> &lt;node&gt;] [-<span class="keyword">q</span>] &lt;<span class="keyword">command</span>&gt; [&lt;<span class="keyword">command</span> <span class="keyword">options</span>&gt;] 
-<span class="keyword">n</span> node 默认node名称是<span class="string">"rabbit@server"</span>，如果你的主机明是<span class="string">'server.example.com'</span>，那么node名称是<span class="string">'rabbit@server'</span>。
-<span class="keyword">q</span> 安静输出模式，信息会被禁止输出
</code></pre><h4 id="[_command_]">[ command ]</h4>
<p><strong>基本的管理功能</strong></p>
<pre><code>stop [&lt;pid_file&gt;]
<span class="preprocessor">#停止在erlang node上运行的rabbitmq，会使rabbitmq停止</span>

stop_app 
<span class="preprocessor">#停止erlang node上的rabbitmq的应用，但是erlang node还是会继续运行</span>

start_app
<span class="preprocessor">#启动erlan node上的rabbitmq的应用</span>

wait &lt;pid_file&gt;
<span class="preprocessor">#等待rabbitmq服务启动</span>

reset
<span class="preprocessor">#初始化node状态，会从集群中删除该节点，从管理数据库中删除所有数据，例如vhosts等等。在初始化之前rabbitmq的应用必须先停止</span>

force_reset
<span class="preprocessor">#无条件的初始化node状态</span>

rotate_logs &lt;suffix&gt;
<span class="preprocessor">#轮转日志文</span>
</code></pre><p><strong>cluster管理</strong></p>
<pre><code>join_cluster &lt;clusternode&gt; [--ram]  
<span class="preprocessor">#clusternode表示node名称，--ram表示node以ram node加入集群中。默认node以disc node加入集群，在一个node加入cluster之前，必须先停止该node的rabbitmq应用，即先执行stop_app。</span>

cluster_status  
<span class="preprocessor">#显示cluster中的所有node</span>

change_cluster_node_type disc | ram  
<span class="preprocessor">#改变一个cluster中node的模式，该节点在转换前必须先停止，不能把一个集群中唯一的disk node转化为ram node</span>

forget_cluster_node [--offline]  
<span class="preprocessor">#远程移除cluster中的一个node，前提是该node必须处于offline状态，如果是online状态，则需要加--offline参数。</span>

update_cluster_nodes clusternode   

sync_queue queue  
<span class="preprocessor">#同步镜像队列</span>

cancel_sync_queue queue    
</code></pre><p><strong>用户管理</strong></p>
<pre><code>add_user <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;password&gt;</span>  
<span class="comment">#在rabbitmq的内部数据库添加用户</span>

delete_user <span class="variable">&lt;username&gt;</span>  
<span class="comment">#删除一个用户</span>

change_password <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;newpassword&gt;</span>  
<span class="comment">#改变用户密码  \\改变web管理登陆密码</span>

clear_password <span class="variable">&lt;username&gt;</span> 
<span class="comment">#清除用户密码，禁止用户登录</span>

set_user_tags <span class="variable">&lt;username&gt;</span> <span class="variable">&lt;tag&gt;</span> ...
<span class="comment">#设置用户tags</span>

list_users  
<span class="comment">#列出用户</span>

add_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#创建一个vhosts</span>

delete_vhost <span class="variable">&lt;vhostpath&gt;</span>  
<span class="comment">#删除一个vhosts</span>

list_vhosts [<span class="variable">&lt;vhostinfoitem&gt;</span> ...]  
<span class="comment">#列出vhosts</span>

set_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;user&gt;</span> <span class="variable">&lt;conf&gt;</span> <span class="variable">&lt;write&gt;</span> <span class="variable">&lt;read&gt;</span>  
<span class="comment">#针对一个vhosts 给用户赋予相关权限</span>

clear_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;username&gt;</span>  
<span class="comment">#清除一个用户对vhosts的权限</span>

list_permissions [-p <span class="variable">&lt;vhostpath&gt;</span>]   
<span class="comment">#列出哪些用户可以访问该vhosts</span>

list_user_permissions <span class="variable">&lt;username&gt;</span>  
<span class="comment">#列出该用户的访问权限</span>

set_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;name&gt;</span> <span class="variable">&lt;value&gt;</span>
<span class="comment">#</span>

clear_parameter [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;component_name&gt;</span> <span class="variable">&lt;key&gt;</span>
<span class="comment">#</span>

list_parameters [-p <span class="variable">&lt;vhostpath&gt;</span>]
<span class="comment">#</span>
</code></pre><p><strong>policy管理，策略用来控制和修改queues和exchange在集群中的行为，策略可以应用到vhost</strong></p>
<pre><code>set_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] [--priority <span class="variable">&lt;priority&gt;</span>] [--apply-to <span class="variable">&lt;apply-to&gt;</span>]  
<span class="variable">&lt;name&gt;</span> <span class="variable">&lt;pattern&gt;</span> <span class="variable">&lt;definition&gt;</span>    
<span class="comment">#name 策略名称，pattern  正则表达式，用来匹配资源，符合的就会应用设置的策略，apply-to 表示策略应用到什么类型的地方，一般有queues、exchange和all，默认是all。priority 是个整数优先级，definition 是json格式设置的策略。</span>

clear_policy [-p <span class="variable">&lt;vhostpath&gt;</span>] <span class="variable">&lt;name&gt;</span>  
<span class="comment">#清除一个策略</span>

list_policies [-p <span class="variable">&lt;vhostpath&gt;</span>]  
<span class="comment">#列出已有的策略</span>
</code></pre><p><strong>queues &amp;&amp; exchange状态信息</strong></p>
<pre><code>list_queues [-p &lt;vhostpath&gt;] [&lt;queueinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回queue的信息，如果省略了-p参数，则默认显示的是"/"vhosts的信息。</span>

list_exchanges [-p &lt;vhostpath&gt;] [&lt;exchangeinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回exchange的信息。</span>

list_bindings [-p &lt;vhostpath&gt;] [&lt;bindinginfoitem&gt; <span class="keyword">...</span>] 
<span class="comment">#返回绑定信息。</span>

list_connections [&lt;connectioninfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回链接信息。</span>

list_channels [&lt;channelinfoitem&gt; <span class="keyword">...</span>]  
<span class="comment">#返回目前所有的channels。</span>

list_consumers [-p &lt;vhostpath&gt;]  
<span class="comment">#返回consumers，</span>

status  
<span class="comment">#显示broker的状态</span>

environment  
<span class="comment">#显示环境参数的信息</span>

report  
<span class="comment">#返回一个服务状态report，</span>

eval &lt;expr&gt;
</code></pre><h4 id="rabbitmq-plugins_插件的开启和关闭">rabbitmq-plugins 插件的开启和关闭</h4>
<pre><code>rabbitmq-plugins &lt;command&gt; [&lt;command options&gt;]
Commands:
list [-v] [-m] [-E] [-e] [&lt;pattern&gt;]  显示所有的的插件。-v 显示版本 -m 显示名称 -E 显示明确已经开启的 -e显示明确的和暗中开启的
enable &lt;plugin&gt; <span class="keyword">...</span>   开启一个插件
disable &lt;plugin&gt; <span class="keyword">...</span>  关闭一个插件
</code></pre><h4 id="开启rabbitmq_management,_插件在安装目录的/plugins下面">开启rabbitmq_management, 插件在安装目录的/plugins下面</h4>
<pre><code>rabbitmq-plugins enable rabbitmq_management
abbitmq_management提供一个基于HTTP的API接口，来管理和监控你的rabbitmq。他有web方式和<span class="keyword">CLI</span>方式，其实web方式是在后端调用HTTP api
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。</p>
<p><img src="https://raw.githubusercontent.com/cbc009/cbc009.github.io/master/images/n2gyg2.png"><br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM性能监控工具]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/JVM性能监控工具/</id>
    <published>2015-06-15T07:50:07.000Z</published>
    <updated>2015-06-15T08:10:36.000Z</updated>
    <content type="html"><![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<a id="more"></a>

<hr>
<h4 id="jps_虚拟机进程状况工具">jps 虚拟机进程状况工具</h4>
<pre><code>命令格式：
<span class="tag">jps</span> <span class="attr_selector">[options]</span> <span class="attr_selector">[hostid]</span>

<span class="tag">jps</span> 可以查看通过 <span class="tag">rmi</span> 协议查询开启了 <span class="tag">rmi</span> 服务的原创虚拟机进程状态，<span class="tag">hostid</span> 是 <span class="tag">rmi</span> 注册表中注册的主机。
</code></pre><h6 id="options">options</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>只输出 LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机启动时候传递给 main 方法的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出类的全名</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时 JVM 参数</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="jstack_分析_java_堆栈">jstack 分析 java 堆栈</h4>
<p>jstack 用来生成当前时刻线程快照。</p>
<pre><code>命令格式：
jstack [ <span class="preprocessor">option</span> ] pid
jstack [ <span class="preprocessor">option</span> ] executable core
jstack [ <span class="preprocessor">option</span> ] [server-id@]remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jstat_虚拟机统计信息监视工具">jstat 虚拟机统计信息监视工具</h4>
<p>jstat 可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、 JIT 编译等运行数据。</p>
<pre><code>命令格式：
<span class="tag">jstat</span> <span class="attr_selector">[option vmid [interval]</span> <span class="attr_selector">[count]</span>]
</code></pre><h6 id="option">option</h6>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总看见以及类装载消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视 java 堆状况，包括 eden 区、两个 survivor 区、年老代、永久代等的容量、已用空间、gc 时间合计等</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>内容与 -gc 基本相同，输出主要关注 java 堆各个区使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>内容与 -gc 基本相同，关注已使用区域占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>内容与 -gcutil 一样，并且多输出导致上一次 gc 产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>与 -gcnew 相同，主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出 JIT 编译器编译过的方法、耗时等信息</td>
</tr>
</tbody>
</table>
<h6 id="-gcutil_所产生的内容：">-gcutil 所产生的内容：</h6>
<pre><code>S0、S1 分别代表了 Survivor0 和 Survivor1;
<span class="keyword">E</span> 代表 Eden 区;
<span class="keyword">O</span> 代表老年区;
P 代表永久代;
YGC 代表 Young GC 的次数;
YGCT 代表时间
</code></pre><hr>
<h4 id="jinfo_查看_java_配置信息工具">jinfo 查看 java 配置信息工具</h4>
<pre><code>命令格式：
jinfo [ <span class="preprocessor">option</span> ] pid
jinfo [ <span class="preprocessor">option</span> ] executable core
jinfo [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><hr>
<h4 id="jmap_生产_java_内存_dump">jmap 生产 java 内存 dump</h4>
<p>jmap 除了可以生成 dump 文件外，还可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率和当前用的是哪种收集器等。</p>
<pre><code>命令格式：
jmap [ <span class="preprocessor">option</span> ] pid
jmap [ <span class="preprocessor">option</span> ] executable core
jmap [ <span class="preprocessor">option</span> ] [ server-id@ ] remote-hostname-<span class="keyword">or</span>-<span class="literal">IP</span>
</code></pre><h6 id="option-1">option</h6>
<pre><code>-<span class="ruby">heap
</span>-<span class="ruby">permstat</span>
</code></pre><hr>
<h4 id="jhat_虚拟机堆快照分析工具">jhat 虚拟机堆快照分析工具</h4>
<p>我们可以使用 jhat 来分析 jmap 生成的 dump 文件。默认会开 7000 端口进行 web 访问。一般不使用这个命令来分析，会使用专业的工具来分析 dump 文件，如 eclipse memory analyzer 等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM process status tool，显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM statistics monitoring tool，用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>生产虚拟机的内存快照 dump 文件</td>
</tr>
<tr>
<td>jhat</td>
<td>分析 dump 文件</td>
</tr>
<tr>
<td>jstack</td>
<td>显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X下使用 Charles 进行抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/06/15/Mac-OS-X%E4%B8%8B%E4%BD%BF%E7%94%A8-Charles-%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/06/15/Mac-OS-X下使用-Charles-进行抓包/</id>
    <published>2015-06-15T07:14:12.000Z</published>
    <updated>2015-06-15T07:40:25.000Z</updated>
    <content type="html"><![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">http://www.charlesproxy.com/</a></p>
<h4 id="2、启动_Charles，支持正版，如需破解请自行搜索">2、启动 Charles，支持正版，如需破解请自行搜索</h4>
<h4 id="3、手机设置代理,_以_iPhone_为例">3、手机设置代理, 以 iPhone 为例</h4>
<p>设置-无线局域网-选择已连接的局域网-HTTP代理-手动，服务器：你电脑的 IP，端口：8888</p>
<p>第一次用手机请求网络时，Charles会提示是否允许接入，选择Allow就可以了。</p>
<p>如果是 HTTPS 抓包，需要安装证书，证书地址：<a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Charles 是一个网络抓包工具，可以在电脑起一个代理，手机配置代理 IP 后，就可以用 Charles 看到手机的网络请求了。</p>
<h4 id="1、下载">1、下载</h4>
<p><a href="http://www.charlesproxy.com/" t]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS环境使用wireshark抓包]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/07/MacOS%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8wireshark%E6%8A%93%E5%8C%85/"/>
    <id>http://www.chenbaocheng.com/2015/05/07/MacOS环境使用wireshark抓包/</id>
    <published>2015-05-07T04:17:31.000Z</published>
    <updated>2015-05-07T04:47:46.000Z</updated>
    <content type="html"><![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p><a id="more"></a></p>
<h5 id="端口过滤">端口过滤</h5>
<pre><code><span class="comment">#tcp</span>
tcp.<span class="variable">port =</span>= <span class="number">80</span>
tcp.<span class="variable">dstport =</span>= <span class="number">80</span>
tcp.<span class="variable">srcport =</span>= <span class="number">80</span>
<span class="comment">#udp</span>
udp.<span class="variable">port =</span>= <span class="number">80</span>
udp.<span class="variable">dstport =</span>= <span class="number">80</span>
udp.<span class="variable">srcport =</span>= <span class="number">80</span>
</code></pre><h5 id="协议过滤">协议过滤</h5>
<pre><code><span class="preprocessor">#支持的协议</span>
udp
arp
icmp
http
smtp
ftp
dns
msnms
ip
ssl
<span class="preprocessor">#例如过滤协议为不是 UDP 的请求</span>
!udp
</code></pre><h5 id="包长度过滤：">包长度过滤：</h5>
<pre><code><span class="preprocessor">#30 = udp本身固定长度8 + 数据包长度22</span>
udp.length == <span class="number">30</span>
<span class="preprocessor">#指ip数据包长度,不包括tcp本身长度</span>
tcp.len &gt;= <span class="number">10</span> 
<span class="preprocessor">#除以太网头固定长度14,其它都算是ip.len,即从ip本身到最后</span>
ip.len == <span class="number">94</span> 
<span class="preprocessor">#整个数据包长度,从eth开始到最后</span>
frame.len == <span class="number">119</span> 
</code></pre><h5 id="HTTP模式过滤">HTTP模式过滤</h5>
<pre><code><span class="comment">#请求类型过滤</span>
http.request.<span class="keyword">method</span> == “[<span class="type">GET</span>|<span class="type">POST</span>|<span class="type">DELETE</span>|<span class="type">PUT</span>]”
<span class="comment">#请求地址过滤</span>
http.request.uri == “/resume/index”
<span class="comment">#包含 GET 字符串的</span>
http contains “<span class="type">GET</span>”
</code></pre><h5 id="多过滤条件">多过滤条件</h5>
<pre><code>#多过滤条件用  <span class="built_in">and</span> | <span class="built_in">or</span> 链接
</code></pre><h5 id="正则过滤">正则过滤</h5>
<pre><code><span class="operator">matches</span>
<span class="comment">#举个例子</span>
http <span class="operator">matches</span> “/corp/\d+/*”
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h5 id="安装">安装</h5>
<pre><code>brew <span class="operator"><span class="keyword">install</span> wireshark —<span class="keyword">with</span>-qt5</span>
</code></pre><h5 id="启动应用">启动应用</h5>
<pre><code><span class="comment">#如果不是管理员身份启动，则获取不到网卡信息。</span>
<span class="built_in">sudo</span> wireshark-qt
</code></pre><h5 id="IP过滤">IP过滤</h5>
<pre><code><span class="comment">#来源IP</span>
ip.<span class="variable">src =</span>= 
<span class="comment">#目标IP</span>
ip.<span class="variable">dst =</span>=
<span class="comment">#例如过滤来源192.168.1.10的请求</span>
ip.<span class="variable">src=</span>=<span class="number">192.168</span>.<span class="number">1.10</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(四) Dockerfile]]></title>
    <link href="http://www.chenbaocheng.com/2015/05/05/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-Dockerfile/"/>
    <id>http://www.chenbaocheng.com/2015/05/05/Docker学习-四-Dockerfile/</id>
    <published>2015-05-05T07:37:57.000Z</published>
    <updated>2015-05-05T08:47:33.000Z</updated>
    <content type="html"><![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p><a id="more"></a></p>
<h5 id="RUN命令">RUN命令</h5>
<pre><code><span class="comment"># RUN命令会在上面FROM指定的镜像里执行任何命令，然后提交(commit)结果。RUN是在building image时会运行的指令, 在Dockerfile中可以写多条RUN指令.</span>

RUN &lt;command&gt; (the command is run <span class="keyword">in</span> a shell - `/bin/sh -c`)
或
RUN [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span> <span class="keyword">...</span> ]  (exec form)

<span class="comment">#RUN命令等价于:</span>
docker run image command
docker commit container_id
</code></pre><h5 id="ENTRYPOINT命令">ENTRYPOINT命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>

ENTRYPOINT [<span class="string">"cmd"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span><span class="keyword">...</span>]
或
ENTRYPOINT cmd param1 param2 <span class="keyword">...</span>

<span class="comment">#举个例子</span>
cbc ~ <span class="comment"># cat Dockerfile</span>
FROM tomcat
ENTRYPOINT echo <span class="string">"Hello world!"</span>

cbc ~ <span class="comment"># docker run 62fda5e450d5</span>
Hello world!
</code></pre><h5 id="CMD命令">CMD命令</h5>
<pre><code><span class="comment">#容器启动时执行的命令，如果写多条, 只有最后一条生效。</span>
CMD [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>] (like <span class="operator">an</span> exec, preferred form)
或
CMD [<span class="string">"param1"</span>,<span class="string">"param2"</span>] (<span class="keyword">as</span> default parameters <span class="built_in">to</span> ENTRYPOINT)
或
CMD <span class="command"><span class="keyword">command</span> <span class="title">param1</span> <span class="title">param2</span> (<span class="title">as</span> <span class="title">a</span> <span class="title">shell</span>)</span>
</code></pre><h6 id="#CMD和ENTRYPOINT是在运行container时会运行的指令,_都只能写一条,_如果写多条,_只有最后一条生效。CMD在运行时会被command覆盖,_ENTRYPOINT不会被运行时的command覆盖,_如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image,_例如apache,_mysql等-_在使用这种image启动container时,_自动启动相关服务-下面的示例_psql_会覆盖_Dockerfile_里的_CMD">#CMD和ENTRYPOINT是在运行container时会运行的指令, 都只能写一条, 如果写多条, 只有最后一条生效。CMD在运行时会被command覆盖, ENTRYPOINT不会被运行时的command覆盖, 如需要覆盖ENTRYPOINT使用参数—entrypoint=。CMD和ENTRYPOINT一般用于制作具备后台服务的image, 例如apache, mysql等. 在使用这种image启动container时, 自动启动相关服务.下面的示例 psql 会覆盖 Dockerfile 里的 CMD</h6>
<pre><code>docker run postgre<span class="variable">s:9</span>.<span class="number">3.5</span> psql 
</code></pre><h5 id="USER命令">USER命令</h5>
<pre><code><span class="preprocessor">#指定 ENTRYPOINT 执行命令时的运行用户,下面的例子是指开机启动 NGINX 时用 www 用户身份启动。</span>

ENTRYPOINT [<span class="string">"nginx"</span>]
USER www
</code></pre><h5 id="EXPOSE命令">EXPOSE命令</h5>
<pre><code><span class="comment">#设置镜像运行时对外暴露的端口</span>
EXPOSE &lt;port&gt; [&lt;port&gt;<span class="keyword">...</span>]
</code></pre><h5 id="ENV命令">ENV命令</h5>
<pre><code><span class="input"><span class="prompt">#设置环境变量，设置后，后续的RUN命令都可以使用该环境变量
ENV &lt;key&gt;</span> &lt;value&gt;</span>
</code></pre><h5 id="ADD命令">ADD命令</h5>
<pre><code><span class="input"><span class="prompt">#从src复制文件到容器的dest路径。src可以是文件、目录或一个远程url。
ADD &lt;src&gt;</span> &lt;dest&gt;</span>
</code></pre><h5 id="VOLUME命令">VOLUME命令</h5>
<pre><code><span class="preprocessor">#创建一个挂载点用于共享目录</span>
VOLUME [<span class="string">"&lt;mountpoint&gt;"</span>]
</code></pre><h5 id="WORKDIR命令">WORKDIR命令</h5>
<pre><code><span class="preprocessor">#为RUN, CMD, ENTRYPOINT命令设置当前工作路径</span>
WORKDIR /path/to/workdir
</code></pre><h5 id="ONBUILD命令">ONBUILD命令</h5>
<pre><code><span class="preprocessor">#ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Dockerfile 由一系列Dockerfile指令构成，用于创建一个自定义image, 可以通过Dockerfile来描述构建镜像的步骤，并自动构建一个容器。Dockerfile指令忽略大小写，但是建议使用大写。</p>
<p>Dockerfile 命令格式：<br>    INSTRUCTION arguments</p>
<h5 id="MAINTAINER命令">MAINTAINER命令</h5>
<pre><code><span class="comment">#用于指定维护者的姓名和联系方式</span>
<span class="title">MAINTAINER</span> cbc, cbc<span class="variable">@chenbaocheng</span>.com
</code></pre><h5 id="FROM命令">FROM命令</h5>
<pre><code><span class="comment"># 设置基于哪个image创建新的image，所以 FROM 应是 Dockerfile 里的第一条指令。如果没有指定tag, 默认tag是latest。</span>

<span class="constant">FROM</span> &lt;image&gt;
或
<span class="constant">FROM</span> &lt;image&gt;<span class="symbol">:&lt;tag&gt;</span>
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(三) Docker镜像和容器的常用操作]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%89-Docker%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-三-Docker镜像和容器的常用操作/</id>
    <published>2015-04-30T08:06:29.000Z</published>
    <updated>2015-04-30T10:07:26.000Z</updated>
    <content type="html"><![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre><a id="more"></a>

<h5 id="查找镜像">查找镜像</h5>
<pre><code>这里我们是找一个名为tengine的镜像，tengine是淘宝版的nginx

cbc ~ <span class="comment"># docker search tengine</span>
NAME                           DESCRIPTION   STARS     OFFICIAL   AUTOMATED
mimosa/tengine                               <span class="number">1</span>                    [OK]
netengine/renderer-nginx                     <span class="number">1</span>                    [OK]
utgard/tengine                               <span class="number">0</span>                    [OK]
sugamele/tengine               Tengine       <span class="number">0</span>
vpanton/docker-tengine-dyups                 <span class="number">0</span>                    [OK]
hyperboloide/tengine                         <span class="number">0</span>
guilhem30/updatengine                        <span class="number">0</span>                    [OK]
</code></pre><h5 id="获取镜像">获取镜像</h5>
<pre><code>cbc ~ <span class="comment"># docker pull mimosa/tengine</span>
<span class="constant">Pulling</span> repository mimosa/tengine
<span class="symbol">f614dc8befa6:</span> <span class="constant">Pulling</span> dependent layers
<span class="number">511136</span><span class="symbol">ea3c5a:</span> <span class="constant">Download</span> complete
<span class="number">5</span><span class="symbol">e66087f3ffe:</span> <span class="constant">Downloading</span> <span class="number">17.96</span> <span class="constant">MB</span>

<span class="comment"># 下载过程中，会输出获取镜像的每一层信息。</span>
<span class="comment"># 你可以按照下面的格式从指定注册服务器的仓库下载相应标记的镜像：</span>
docker pull 注册服务器地址[<span class="symbol">:</span>端口号]/仓库名<span class="symbol">:TAG</span>名称
</code></pre><h4 id="删除镜像">删除镜像</h4>
<pre><code>docker rmi ae0c2d0bdc10
<span class="preprocessor"># 移除镜像前，先移除依赖该镜像的容器</span>
</code></pre><h4 id="使用镜像创建一个容器">使用镜像创建一个容器</h4>
<pre><code>cbc ~ # docker run -itd --name tengine01 mimosa/tengine /bin/bash
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -t 让docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入</span>
<span class="preprocessor"># -i 让容器的标准输入保持打开</span>
<span class="preprocessor"># -d 让容器在后台以守护进程（Daemonized）形式运行</span>
<span class="preprocessor"># --name 给容器起个名儿</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互    </span>
</code></pre><h4 id="导出镜像到本地文件">导出镜像到本地文件</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker save -o tengine.tar mimosa/tengine
</code></pre><h4 id="从本地文件导入镜像">从本地文件导入镜像</h4>
<pre><code>docker <span class="built_in">load</span> <span class="comment">--input tengine.tar</span>
或者
docker <span class="built_in">load</span> &lt; tengine.tar
</code></pre><h4 id="查看容器状态">查看容器状态</h4>
<pre><code>cbc ~ <span class="comment"># docker ps -a</span>
CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS                      PORTS               NAMES
ca98201350dd        mimosa/tengine:latest   <span class="string">"/bin/bash"</span>         <span class="number">19</span> minutes ago      Up <span class="number">9</span> minutes                <span class="number">443</span>/tcp, <span class="number">80</span>/tcp     grave_albattani
b02c528c3cad        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (<span class="number">127</span>) <span class="number">2</span> hours ago                        furious_einstein
cf769788d09e        centos:<span class="number">7</span>                <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Exited (-<span class="number">1</span>) <span class="number">2</span> hours ago                         agitated_mclean
f706bbb258a1        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">3</span> hours ago         Exited (<span class="number">130</span>) <span class="number">3</span> hours ago                        goofy_yonath
<span class="number">574871</span>d84dc2        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">127</span>) <span class="number">5</span> months ago                       cocky_wilson
<span class="number">47381902</span><span class="built_in">cd</span>50        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         mad_feynman
ee19f69f978c        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         high_bohr
a7e4a6d0c994        ae0c2d0bdc10            <span class="string">"/usr/bin/"</span>         <span class="number">5</span> months ago                                                        drunk_pike
ad418b05441f        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago                                                        sick_colden
dffb9f3f6677        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         determined_shockley
e9297baee616        ae0c2d0bdc10            <span class="string">"/bin/bash"</span>         <span class="number">5</span> months ago        Exited (<span class="number">0</span>) <span class="number">5</span> months ago                         thirsty_pare
</code></pre><h4 id="停止容器">停止容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker stop ca98201350dd 
</code></pre><h4 id="重启容器">重启容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker restart ca98201350dd
ca98201350dd
</code></pre><h4 id="从终止状态启动一个容器">从终止状态启动一个容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker start ca98201350dd
ca98201350dd 
</code></pre><h4 id="进入一个运行状态的容器">进入一个运行状态的容器</h4>
<pre><code>cbc ~ <span class="comment"># docker attach ca98201350dd</span>
[ root<span class="variable">@ca98201350dd</span><span class="symbol">:/etc/nginx</span> ]$
</code></pre><h4 id="删除容器">删除容器</h4>
<pre><code><span class="title">cbc</span> <span class="regexp">~ #</span> docker rm 4d72d9a0066d
4d72d9a0066d 
</code></pre><h4 id="导出容器">导出容器</h4>
<pre><code><span class="input"><span class="prompt">docker export ca98201350dd &gt;</span> tengine.dock.tar</span>
</code></pre><h4 id="导入容器快照">导入容器快照</h4>
<pre><code>cbc ~ <span class="comment"># cat tengine.dock.tar | docker import - cbc009/tengine</span>
<span class="number">67e225223716</span>ff791c78bcc546695e530a37358e0c86b72a7a5bff2fbfbb6228

或从<span class="built_in">URL</span>导入

docker import <span class="built_in">URL</span> REPOSITORY

查看一下结果：
cbc ~ <span class="comment"># docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
cbc009/tengine      latest              <span class="number">67e225223716</span>        <span class="number">2</span> minutes ago       <span class="number">593.5</span> MB
</code></pre><h4 id="外部访问容器，对容器网络端口映射">外部访问容器，对容器网络端口映射</h4>
<pre><code>cbc ~ # docker run -itdP mimosa/tengine /bin/bash
ca98201350dd0c30bc4f37992b22d70594ae0fabe1992457776e5cc5b113c9e7

<span class="preprocessor"># -P Docker会随机映射一个49000~49900的端口到内部容器开放的网络端口</span>
<span class="preprocessor"># -p 参数小写的p可以手动指定要映射的端口。一个指定端口只可以绑定一个容器，也可以指定端口类型。支持的格式有：ip:hostPort:containerPort[/protocol] | ip::containerPort[/protocol] | hostPort:containerPort[/protocol]</span>
<span class="preprocessor"># /bin/bash 启动一个bash终端，允许用户进行交互</span>

<span class="preprocessor"># 用 docker ps -l查看最后一个被创建的容器，访问49154端口可以看到 tengine 的欢迎页。</span>
<span class="preprocessor"># 现在我可以通过工作电脑访问容器的物理机：http://192.168.11.185:49154/</span>
cbc ~ # docker ps -l
CONTAINER<span class="constant"> ID </span>      <span class="constant"> IMAGE </span>                 <span class="constant"> COMMAND </span>           <span class="constant"> CREATED </span>           <span class="constant"> STATUS </span>            <span class="constant"> PORTS </span>                                          NAMES
<span class="number">1</span>dd4e24df270        mimosa/tengine:latest   <span class="string">"nginx"</span>             <span class="number">7</span> minutes ago       Up <span class="number">7</span> minutes        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49153</span>-&gt;<span class="number">443</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">49154</span>-&gt;<span class="number">80</span>/tcp   naughty_hypatia
</code></pre><h4 id="查看网络端口映射情况">查看网络端口映射情况</h4>
<pre><code>docker <span class="keyword">port</span> <span class="number">1</span>dd4e24df270 <span class="number">80</span>
</code></pre><p>至此镜像和容器的基本操作学习完了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="列出镜像">列出镜像</h5>
<pre><code>cbc ~ # docker images
REPOSITORY         <span class="constant"> TAG </span>               <span class="constant"> IMAGE </span>ID           <span class="constant"> CREATED </span>           <span class="constant"> VIRTUAL </span>SIZE
centos              <span class="number">7</span>                   fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              centos7             fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
centos              latest              fd44297e2ddb        <span class="number">8</span> days ago          <span class="number">229.6</span> MB
&lt;none&gt;              &lt;none&gt;              ae0c2d0bdc10        <span class="number">5</span> months ago        <span class="number">224</span> MB

<span class="preprocessor">#REPOSITORY 镜像来源仓库</span>
<span class="preprocessor">#TAG 镜像标记</span>
<span class="preprocessor">#IMAGE ID 镜像唯一 ID</span>
<span class="preprocessor">#CREATED 镜像创建时间</span>
<span class="preprocessor">#VIRTUAL SIZE 镜像大小</span>
</code></pre>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(二) 安装与配置]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-二-安装与配置/</id>
    <published>2015-04-30T07:50:46.000Z</published>
    <updated>2015-04-30T08:01:51.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p><a id="more"></a>    </p>
<pre><code><span class="preprocessor">#安装</span>
yum install docker-io
</code></pre><h4 id="CentOS_7_下安装Docker服务">CentOS 7 下安装Docker服务</h4>
<p>Centos 7 开始 CentOS-Extras 库自带 Docker，所以安装会相对更简单.</p>
<pre><code>yum <span class="operator"><span class="keyword">install</span> docker</span>
</code></pre><h4 id="启动_Docker">启动 Docker</h4>
<pre><code><span class="class"><span class="keyword">service</span> <span class="title">docker</span> start</span>
</code></pre><h4 id="开机启动">开机启动</h4>
<pre><code>chkconfig docker <span class="command"><span class="keyword">on</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Docker_的安装与配置">Docker 的安装与配置</h4>
<p>Docker 支持 CentOS 6 及后续版本。</p>
<h4 id="CentOS_6_下安装Docker服务">CentOS 6 下安装Docker服务</h4>
<pre><code><span class="preprocessor">#禁用SELINUX</span>
vim /etc/selinux/config
SELINUX=disabled

<span class="preprocessor">#配置Fedora EPEL 源</span>
rpm -ivh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span>
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-<span class="number">6</span>
yum -y install yum-priorities
</code></pre><p>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习(一) Docker基础]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%80-Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Docker学习-一-Docker基础/</id>
    <published>2015-04-30T07:28:12.000Z</published>
    <updated>2015-04-30T08:02:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br><a id="more"></a><br><strong>container,容器</strong>，容器是从镜像创建的运行实例，一台物理机可以运行 成百上千个容器，容器之间是相互隔离的。容器可以通过相关命令启动，开始，停止，删除。</p>
<p><strong>repository,仓库</strong>，分为公共和私有两种。默认是从公共仓库获取 image.</p>
<h5 id="下面有一个表格对比了传统虚拟机和docker的区别：">下面有一个表格对比了传统虚拟机和docker的区别：</h5>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">容器</th>
<th style="text-align:right">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:right">分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td style="text-align:center">通常为MB</td>
<td style="text-align:right">通常为GB</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:right">弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td style="text-align:center">单机支持上千容器</td>
<td style="text-align:right">一般几十个虚拟机</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="使用_Docker_的目的">使用 Docker 的目的</h4>
<p><strong>交付和部署更快速</strong>，一次创建，随处运行，创建容器的全过程可见，对所有人都是透明的；</p>
<p><strong>虚拟化更高效</strong>，少了一层虚拟化当然更高效，接近于物理机的性能；我的理解是 Docker 对物理资源做了隔离，所以更轻量。</p>
<p><strong>迁移和扩展更轻松</strong>，可以从私有仓库，共有仓库拉取image, 用过 maven 的同学应该会有类似的体验；</p>
<h4 id="常用概念">常用概念</h4>
<p><strong>image,镜像</strong>，用户可以通过相关命令轻松创建一个image，也可以通过命令轻松仓库里下载一个 image。image 是只读的、静止的。我们通过命令可以启动一个image，从而创建一个 Docker 容器。<br>]]>
    
    </summary>
    
      <category term="docker" scheme="http://www.chenbaocheng.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux开机获取IP发送到指定邮箱]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/30/Linux%E5%BC%80%E6%9C%BA%E8%8E%B7%E5%8F%96IP%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/"/>
    <id>http://www.chenbaocheng.com/2015/04/30/Linux开机获取IP发送到指定邮箱/</id>
    <published>2015-04-30T05:20:19.000Z</published>
    <updated>2015-04-30T05:30:19.000Z</updated>
    <content type="html"><![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br><a id="more"></a><br>2、修改配置文件</p>
<p>vim  /etc/mail.rc</p>
<p>添加如下内容：<br>set from=xxxxxx@163.com smtp=smtp.163.com smtp-auth-user={username} smtp-auth-password={password} smtp-auth=login</p>
<p>3、配置开机发邮件</p>
<p>vim /etc/rc.local</p>
<p>ifconfig | mail -s “重启开机邮件 - 最新 IP” xxxx@xxxx.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以有这样的需求，是因为平日主力是用自己的笔记本，公司给配的台式机（主机、显示器）扔工位下面，装了 Centos 玩儿，公司是DHCP 分配IP，每次重启开机都得到台式机登录一下，才能获取最新IP，有点小麻烦，重启后给自己邮箱发个邮件，这样省事儿，看看邮件里的IP，远程 SSH 登录就可以了~</p>
<p>我的台式机系统是 CENTOS，邮箱是163的，安装配置如下:</p>
<p>1、安装mailx</p>
<p>yum install mailx<br>]]>
    
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 github 放一个spring-boot-jpa DEMO]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/29/%E5%9C%A8-github-%E5%8F%91%E4%B8%80%E4%B8%AAspring-boot-jpa-DEMO/"/>
    <id>http://www.chenbaocheng.com/2015/04/29/在-github-发一个spring-boot-jpa-DEMO/</id>
    <published>2015-04-29T08:58:12.000Z</published>
    <updated>2015-05-19T08:02:06.000Z</updated>
    <content type="html"><![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entity，声明 Dao，在 Service 层包装一下业务, controller 里去做 WEB 页面展示的准备工作就好了。</p>
<p>这个DEMO主要演示基于 spring boot 的项目开发，如何使用 jpa 对数据库 CRUD 操作，如何用 freemarker 展示页面。</p>
<p>项目地址：<a href="https://github.com/cbc009/spring-boot-jpa" target="_blank" rel="external">spring-boot-jpa DEMO</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 github 放一个spring-boot-jpa DEMO。</p>
<p>Spring Boot 的出现极大提高了生产效率, 尤其是做一些规模不太大的项目，它非常好用了，你不必再为繁杂的配置文件而烦恼，只需在 pom 里增加想依赖的组件就可以了，然后定义 Entit]]>
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java : Unsupported major.minor version 51.0解决方法]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/"/>
    <id>http://www.chenbaocheng.com/2015/04/23/Java-Unsupported-major-minor-version-51-0/</id>
    <published>2015-04-23T06:44:35.000Z</published>
    <updated>2015-04-28T03:53:43.000Z</updated>
    <content type="html"><![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
<a id="more"></a>

<p>51.0是对应JDK1.7, 看一下当前的 java 版本什么呢？<br>$ java -version<br>java version “1.7.0_79”<br>Java(TM) SE Runtime Environment (build 1.7.0_79-b15)<br>Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</p>
<p>看起来JDK没问题。</p>
<p>那会不会是 intellij 默认用1.6启动的呢？<br>$ vim /Applications/IntelliJ\ IDEA\ 14.app/Contents/Info.plist</p>
<p>100、101行：<br>      <key>JVMVersion</key><br>      <string>1.6,1.7<em></em></string><br>看起来像是这里的问题，修改一下，把1.6去掉试试:<br>      <key>JVMVersion</key><br>      <string>1.7</string></p>
<p>保存，重新启动Intellij Idea, 出现提示:您要应用程序“Intellij Idea 14.app”接受传入网络连接吗?这是由于修改应用内文件导致Apple 签名失效了。简单粗暴解决一下，进入系统管理-关闭防火墙即可。</p>
<p>重新启动软件，一切正常了~~~ Intellij idea 为什么不默认使用系统 JDK 版本呢？或者给用户一个修改 JDK 版本的界面？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用 intellij idea  插件 QAPlug - FindBugs 时报错：</p>
<p>======Cannot Load Project======<br>Cannot load project:<br>com.intellij.ide.plugins.PluginMananger:$StartupAboortedException:<br>com.intellij.diagnostic.PluginException:<br>com/soldevelo/findbugs/FindBugsComponent:Unsupported major.minor version 51.0[Plugin:QAPlug - FindBugs][Plugin:QAPlug - FindBugs]</p>
<p>经过一番搜索，找到如下 JDK 版本对应关系 ：<br>J2SE 8 = 52 (0x34 hex)<br>J2SE 7 = 51 (0x33 hex)<br>J2SE 6.0 = 50 (0x32 hex)<br>J2SE 5.0 = 49 (0x31 hex)<br>JDK 1.4 = 48 (0x30 hex)<br>JDK 1.3 = 47 (0x2F hex)<br>JDK 1.2 = 46 (0x2E hex)<br>JDK 1.1 = 45 (0x2D hex)</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[oh-my-zsh替代品prezto]]></title>
    <link href="http://www.chenbaocheng.com/2015/04/02/oh-my-zsh%E6%9B%BF%E4%BB%A3%E5%93%81prezto/"/>
    <id>http://www.chenbaocheng.com/2015/04/02/oh-my-zsh替代品prezto/</id>
    <published>2015-04-02T07:46:44.000Z</published>
    <updated>2015-04-02T10:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre><a id="more"></a>

<p><br>3、创建Zsh配置文件</p>
<pre><code>setopt EXTENDED_GLOB
 <span class="keyword">for</span> rcfile <span class="keyword">in</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>"</span>/.zprezto/runcoms/^README.md(.N); <span class="keyword">do</span>
   ln <span class="operator">-s</span> <span class="string">"<span class="variable">$rcfile</span>"</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.<span class="variable">${rcfile:t}</span>"</span>
 <span class="keyword">done</span>
</code></pre><p><br>4、设置 Zsh 为默认shell</p>
<pre><code>chsh <span class="operator">-s</span> /bin/zsh
</code></pre><p><br>5、新开窗口体验~~~</p>
<h6 id="关于更新"><br>关于更新</h6>
<pre><code><span class="keyword">cd</span>  ~/.zprezto
git pull &amp;&amp; git submodule <span class="keyword">update</span> --init --recursive
</code></pre><h6 id="oh-my-zsh的_z_命令替代品_fasd"><br>oh-my-zsh的 z 命令替代品 fasd</h6>
<pre><code>brew install fasd

<span class="keyword">vim</span> ~/.zshrc
<span class="built_in">eval</span> <span class="string">"$(fasd --init auto)"</span>

<span class="keyword">vim</span>  ~/.zpreztorc
zstyle <span class="string">':prezto:load'</span> pmodule \
    <span class="string">'environment'</span> \
    <span class="string">'terminal'</span> \
    <span class="string">'editor'</span> \
    <span class="string">'history'</span> \
    <span class="string">'directory'</span> \
    <span class="string">'spectrum'</span> \
    <span class="string">'utility'</span> \
    <span class="string">'completion'</span> \
    <span class="string">'history'</span> \
    <span class="string">'history-substring-search'</span> \
    <span class="string">'prompt'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>每次启动terminal都很慢，实在无法忍受oh-my-zsh的龟速，发现一个替代品prezto，建议使用，oh-my-zsh 有的功能他都有了，最重要的是启动速度快！</p>
<p>废话不多说，prezto项目地址：<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a></p>
<h6 id="安装：">安装：</h6>
<p>1、启动zsh</p>
<pre><code>zsh
</code></pre><p><br>2、克隆项目到本地</p>
<pre><code><span class="title">git</span> clone --recursive <span class="url">https://github.com/sorin-ionescu/prezto.git</span> <span class="string">"<span class="variable">${ZDOTDIR:-$HOME}</span>/.zprezto"</span>
</code></pre>]]>
    
    </summary>
    
      <category term="效率" scheme="http://www.chenbaocheng.com/categories/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS网络诊断命令]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/26/MacOS%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.chenbaocheng.com/2015/02/26/MacOS网络诊断命令/</id>
    <published>2015-02-26T06:54:18.000Z</published>
    <updated>2015-04-28T03:55:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活动网卡</span>
ifconfig

<span class="preprocessor">#查看所有网卡信息，包括活动、非活动网卡</span>
ifconfig -a

<span class="preprocessor">#查看某个网卡的信息</span>
ifconfig eth0

<span class="preprocessor">#配置某个网卡的ip地址 格式：ifconfig  ethx IP/MASK</span>
ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.20</span>/<span class="number">16</span>
</code></pre><h3 id="路由">路由</h3>
<pre><code><span class="preprocessor">#显示路由表</span>
netstat -nr

<span class="preprocessor">#追踪到达IP目的地的全程路由</span>
traceroute nis.nsf.net
</code></pre><h3 id="网络监听_-_tcpdump">网络监听 - tcpdump</h3>
<pre><code><span class="built_in">sudo</span> tcpdump -i en0

监听en0接口的所有通信

<span class="built_in">sudo</span> tcpdump -A -i en0 

用ASCII显示en0接口的通信内容
<span class="built_in">sudo</span> tcpdump -i en0 <span class="string">'port 8080'</span>

显示en0接口的<span class="number">8080</span>端口的通信

<span class="built_in">sudo</span> tcpdump -i eth1 src <span class="number">192.168</span>.<span class="number">1.200</span>

显示eth1接口，来自<span class="number">192.168</span>.<span class="number">1.200</span>的通信

<span class="built_in">sudo</span> tcpdump -i eth1 dst <span class="number">192.168</span>.<span class="number">1.101</span> and port <span class="number">80</span>

显示eth1接口<span class="number">80</span>端口，目的地为<span class="number">192.168</span>.<span class="number">1.101</span>的通信

<span class="built_in">sudo</span> tcpdump -w record.pcap -i lo0

将lo0接口的通信存入文件record.pcap
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ifconfig">ifconfig</h3>
<p>显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。</p>
<pre><code><span class="preprocessor">#查看活动网卡信息，仅限活]]>
    </summary>
    
      <category term="系统维护" scheme="http://www.chenbaocheng.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS管理多个JDK版本]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/23/Mac-OS%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAJDK%E7%89%88%E6%9C%AC/"/>
    <id>http://www.chenbaocheng.com/2015/02/23/Mac-OS管理多个JDK版本/</id>
    <published>2015-02-22T18:36:02.000Z</published>
    <updated>2015-02-22T21:01:19.000Z</updated>
    <content type="html"><![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre><a id="more"></a>

<h5 id="配置">配置</h5>
<pre><code>jenv <span class="keyword">add</span> /System/<span class="keyword">Library</span>/Java/JavaVirtualMachines/<span class="number">1.6</span>.<span class="number">0</span>.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">7.0</span>_60.jdk/Contents/Home/
 jenv <span class="keyword">add</span> /<span class="keyword">Library</span>/Java/JavaVirtualMachines/jdk1.<span class="number">8.0</span>_05.jdk/Contents/Home/
 jenv enable-plugin export
</code></pre><h5 id="使用">使用</h5>
<pre><code><span class="comment">'显示全部版本</span>
 jenv versions 

 <span class="comment">' 设置默认版本</span>
 jenv <span class="keyword">global</span> oracle64-<span class="number">1.6</span><span class="number">.0</span><span class="number">.65</span>

 <span class="comment">' 设置目录对应的JDK版本。在目录下创建.java-version文件记录版本号</span>
 jenv local <span class="number">1.8</span>

 <span class="comment">' 撤销上一步操作</span>
 jenv local --unset
</code></pre><h5 id="插件">插件</h5>
<pre><code>jenv plugins

 ant
 <span class="keyword">export</span>
 golo
 gradle
 grails
 groovy
 lein
 maven
 sbt
 scala
 springboot
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>作为一个Java程序员，同一台工作机上可能会安装多个Java版本，工作时可能是用1.6版本，而工作之余1.7或1.8版本用于学习一下，版本间的手动切换也是麻烦事儿。有次同事问在Mac下是如何管理多个版本的JDK， 当时没有答案，直到偶然见发现jEnv。jEnv的安装、使用都很简单。</p>
<h5 id="什么是jEnv?">什么是jEnv?</h5>
<pre><code><span class="title">jEnv</span> 是一个帮助你管理 <span class="variable">$JAVA_HOME</span> 环境变量的命令行工具。
</code></pre><h5 id="安装">安装</h5>
<pre><code><span class="title">brew</span> install jenv
 echo <span class="string">'export PATH="<span class="variable">$HOME</span>/.jenv/bin:<span class="variable">$PATH</span>"'</span> &gt;&gt; ~/.zshrc
 echo <span class="string">'eval "$(jenv init -)"'</span> &gt;&gt; ~/.zshrc
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[50道Java线程面试题]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/22/50%E9%81%93Java%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.chenbaocheng.com/2015/02/22/50道Java线程面试题/</id>
    <published>2015-02-22T14:16:07.000Z</published>
    <updated>2015-02-22T17:35:31.000Z</updated>
    <content type="html"><![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
<a id="more"></a>

<h5 id="4)_用Runnable还是Thread？">4) 用Runnable还是Thread？</h5>
<p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。<a href="http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="6)_Thread_类中的start()_和_run()_方法有什么区别？">6) Thread 类中的start() 和 run() 方法有什么区别？</h5>
<p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。<a href="http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html" target="_blank" rel="external">更多讨论</a></p>
<h5 id="7)_Java中Runnable和Callable有什么不同？">7) Java中Runnable和Callable有什么不同？</h5>
<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h5 id="8)_Java中CyclicBarrier_和_CountDownLatch有什么不同？">8) Java中CyclicBarrier 和 CountDownLatch有什么不同？</h5>
<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。<a href="http://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html" target="_blank" rel="external">点此查看更多信息和示例代码</a>。</p>
<h5 id="9)_Java内存模型是什么？">9) Java内存模型是什么？</h5>
<p>Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>可传递性<br>我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
<h5 id="10)_Java中的volatile_变量是什么？">10) Java中的volatile 变量是什么？</h5>
<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。<a href="http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html" target="_blank" rel="external">查看更多volatile的相关内容</a>。</p>
<h5 id="11)_什么是线程安全？Vector是一个线程安全类吗？_（详见这里)">11) 什么是线程安全？Vector是一个线程安全类吗？ （详见这里)</h5>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h5 id="12)_Java中什么是竞态条件？_举个例子说明。">12) Java中什么是竞态条件？ 举个例子说明。</h5>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，<a href="http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html" target="_blank" rel="external">详见答案</a>。</p>
<h5 id="13)_Java中如何停止一个线程？">13) Java中如何停止一个线程？</h5>
<p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。<a href="http://javarevisited.blogspot.com/2011/10/how-to-stop-thread-java-example.html" target="_blank" rel="external">查看示例代码</a>。</p>
<h5 id="14)_一个线程运行时发生异常会怎样？">14) 一个线程运行时发生异常会怎样？</h5>
<p>这是我在一次面试中遇到的一个<a href="http://java67.blogspot.sg/2012/09/top-10-tricky-java-interview-questions-answers.html" target="_blank" rel="external">很刁钻的Java面试题</a>, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h5 id="15）_如何在两个线程间共享数据？">15） 如何在两个线程间共享数据？</h5>
<p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《<a href="http://javarevisited.blogspot.sg/2013/12/inter-thread-communication-in-java-wait-notify-example.html" target="_blank" rel="external">Java线程间通信</a>》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<h5 id="16)_Java中notify_和_notifyAll有什么区别？">16) Java中notify 和 notifyAll有什么区别？</h5>
<p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。<a href="http://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html" target="_blank" rel="external">更详细的资料和示例代码</a>。</p>
<h5 id="17)_为什么wait,_notify_和_notifyAll这些方法不在thread类里面？">17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h5>
<p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以<a href="http://javarevisited.blogspot.sg/2012/02/why-wait-notify-and-notifyall-is.html" target="_blank" rel="external">查看这篇文章</a>了解更多。</p>
<h5 id="18)_什么是ThreadLocal变量？">18) 什么是ThreadLocal变量？</h5>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。<a href="http://javarevisited.blogspot.sg/2012/05/how-to-use-threadlocal-in-java-benefits.html" target="_blank" rel="external">查看答案</a>了解更多。</p>
<h5 id="19)_什么是FutureTask？">19) 什么是FutureTask？</h5>
<p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h5 id="20)_Java中interrupted_和_isInterruptedd方法的区别？">20) Java中interrupted 和 isInterruptedd方法的区别？</h5>
<p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="external">静态方法</a>Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h5 id="21)_为什么wait和notify方法要在同步块中调用？">21) 为什么wait和notify方法要在同步块中调用？</h5>
<p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h5 id="22)_为什么你应该在循环中检查等待条件?">22) 为什么你应该在循环中检查等待条件?</h5>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h5 id="23)_Java中的同步集合与并发集合有什么区别？">23) Java中的同步集合与并发集合有什么区别？</h5>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见<a href="http://javarevisited.blogspot.com/2010/10/what-is-difference-between-synchronized.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="24）_Java中堆和栈有什么不同？">24） Java中堆和栈有什么不同？</h5>
<p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。<br>更多内容详见<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">答案</a>。</p>
<h5 id="25）_什么是线程池？_为什么要使用它？">25） 什么是线程池？ 为什么要使用它？</h5>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。<a href="http://javarevisited.blogspot.com/2013/01/difference-between-stack-and-heap-java.html" target="_blank" rel="external">更多详细内容</a>。</p>
<h5 id="26）_如何写代码来解决生产者消费者问题？">26） 如何写代码来解决生产者消费者问题？</h5>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它<a href="http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="27）_如何避免死锁？">27） 如何避免死锁？</h5>
<p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节<a href="http://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="28)_Java中活锁和死锁有什么区别？">28) Java中活锁和死锁有什么区别？</h5>
<p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h5 id="29）_怎么检测一个线程是否拥有锁？">29） 怎么检测一个线程是否拥有锁？</h5>
<p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多，<a href="http://javarevisited.blogspot.com/2010/10/how-to-check-if-thread-has-lock-on.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="30)_你如何在Java中获取线程堆栈？">30) 你如何在Java中获取线程堆栈？</h5>
<p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h5 id="31)_JVM中哪个参数是用来控制线程的栈堆栈小的">31) JVM中哪个参数是用来控制线程的栈堆栈小的</h5>
<p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看<a href="http://javarevisited.blogspot.com/2011/11/hotspot-jvm-options-java-examples.html" target="_blank" rel="external">JVM配置列表</a>来了解这个参数的更多信息。</p>
<h5 id="32）_Java中synchronized_和_ReentrantLock_有什么不同？">32） Java中synchronized 和 ReentrantLock 有什么不同？</h5>
<p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。<a href="http://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html" target="_blank" rel="external">查看这篇文章了解更多</a></p>
<h5 id="33）_有三个线程T1，T2，T3，怎么确保它们按顺序执行？">33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h5>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。<a href="http://javarevisited.blogspot.sg/2013/02/how-to-join-multiple-threads-in-java-example-tutorial.html" target="_blank" rel="external">查看这篇文章了解更多</a>。</p>
<h5 id="34)_Thread类中的yield方法有什么作用？">34) Thread类中的yield方法有什么作用？</h5>
<p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。<a href="http://java67.blogspot.sg/2012/08/difference-between-yield-and-wait.html" target="_blank" rel="external">查看更多yield方法的相关内容</a>。</p>
<h5 id="35）_Java中ConcurrentHashMap的并发度是什么？">35） Java中ConcurrentHashMap的并发度是什么？</h5>
<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章<a href="http://javarevisited.blogspot.com/2013/02/concurrenthashmap-in-java-example-tutorial-working.html" target="_blank" rel="external">How ConcurrentHashMap works in Java</a>。</p>
<h5 id="36）_Java中Semaphore是什么？">36） Java中Semaphore是什么？</h5>
<p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。<a href="http://javarevisited.blogspot.com/2012/05/counting-semaphore-example-in-java-5.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="37）如果你提交任务时，线程池队列已满。会时发会生什么？">37）如果你提交任务时，线程池队列已满。会时发会生什么？</h5>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h5 id="38)_Java线程池中submit()_和_execute()方法有什么区别？">38) Java线程池中submit() 和 execute()方法有什么区别？</h5>
<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。<a href="http://javarevisited.blogspot.sg/2013/07/how-to-create-thread-pools-in-java-executors-framework-example-tutorial.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="39)_什么是阻塞式方法？">39) 什么是阻塞式方法？</h5>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。<a href="http://javarevisited.blogspot.sg/2012/02/what-is-blocking-methods-in-java-and.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="40)_Swing是线程安全的吗？_为什么？">40) Swing是线程安全的吗？ 为什么？</h5>
<p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。<a href="http://javarevisited.blogspot.com/2013/08/why-swing-is-not-thread-safe-in-java-Swingworker-Event-thread.html" target="_blank" rel="external">查看更多swing和线程安全的相关内容</a>。</p>
<h5 id="41）_Java中invokeAndWait_和_invokeLater有什么区别？">41） Java中invokeAndWait 和 invokeLater有什么区别？</h5>
<p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。<a href="http://javarevisited.blogspot.com/2011/09/invokeandwait-invokelater-swing-example.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="42)_Swing_API中那些方法是线程安全的？">42) Swing API中那些方法是线程安全的？</h5>
<p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h5 id="43)_如何在Java中创建Immutable对象？">43) 如何在Java中创建Immutable对象？</h5>
<p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章<a href="http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" target="_blank" rel="external">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p>
<h5 id="44）_Java中的ReadWriteLock是什么？">44） Java中的ReadWriteLock是什么？</h5>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h5 id="45)_多线程中的忙循环是什么?">45) 多线程中的忙循环是什么?</h5>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。<a href="http://java67.blogspot.com/2012/08/5-thread-interview-questions-answers-in.html" target="_blank" rel="external">你可以查看这篇文章获得更多信息</a>。</p>
<h5 id="46）volatile_变量和_atomic_变量有什么不同？">46）volatile 变量和 atomic 变量有什么不同？</h5>
<p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h5 id="47)_如果同步块内的线程抛出异常会发生什么？">47) 如果同步块内的线程抛出异常会发生什么？</h5>
<p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="external">finally block</a>里释放锁实现。</p>
<h5 id="48）_单例模式的双检锁是什么？">48） 单例模式的双检锁是什么？</h5>
<p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看<a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">how double checked locking on Singleton works</a>这篇文章获得更多信息。</p>
<h5 id="49）_如何在Java中创建线程安全的Singleton？">49） 如何在Java中创建线程安全的Singleton？</h5>
<p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。<a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="50)_写出3条你遵循的多线程最佳实践">50) 写出3条你遵循的多线程最佳实践</h5>
<p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<p>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。<br>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明, <a href="http://javarevisited.blogspot.com/2013/02/concurrent-collections-from-jdk-56-java-example-tutorial.html" target="_blank" rel="external">点击查看</a>。</p>
<h5 id="51)_如何强制启动一个线程？">51) 如何强制启动一个线程？</h5>
<p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h5 id="52)_Java中的fork_join框架是什么？">52) Java中的fork join框架是什么？</h5>
<p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。<a href="http://javarevisited.blogspot.com/2011/09/fork-join-task-java7-tutorial.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<h5 id="53）_Java多线程中调用wait()_和_sleep()方法有什么不同？">53） Java多线程中调用wait() 和 sleep()方法有什么不同？</h5>
<p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。<a href="http://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html" target="_blank" rel="external">查看这篇文章获得更多信息</a>。</p>
<p>以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="1)_什么是线程？">1) 什么是线程？</h5>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。<a href="http://java67.blogspot.com/2014/01/10-points-about-thread-and-javalangthread-in-java.html" target="_blank" rel="external">了解更多详细信息</a>。</p>
<h5 id="2)_线程和进程有什么区别？">2) 线程和进程有什么区别？</h5>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。<a href="http://java67.blogspot.com/2012/12/what-is-difference-between-thread-vs-process-java.html" target="_blank" rel="external">更多详细信息</a>。</p>
<h5 id="3)_如何在Java中实现线程？">3) 如何在Java中实现线程？</h5>
<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="external">更多详细信息</a>.</p>
]]>
    
    </summary>
    
      <category term="java" scheme="http://www.chenbaocheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC OS批量删除文件－删除文件夹下的所有.svn目录]]></title>
    <link href="http://www.chenbaocheng.com/2015/02/22/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89-svn%E7%9B%AE%E5%BD%95/"/>
    <id>http://www.chenbaocheng.com/2015/02/22/删除文件夹下的所有-svn目录/</id>
    <published>2015-02-22T13:25:11.000Z</published>
    <updated>2015-02-22T17:37:29.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">".svn"</span> | xargs rm -fr</div></pre></td></tr></table></figure>

<p><br>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -type d -name <span class="string">".svn"</span> | xargs rm -rf</div></pre></td></tr></table></figure>

<p>xargs它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题</p>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">".svn"</span> -exec rm -fr <span class="string">'{}'</span> +</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">]]>
    </summary>
    
      <category term="os" scheme="http://www.chenbaocheng.com/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言学习 - 配置开发环境(IntelliJ IDEA 14 For Mac OS 10.10)]]></title>
    <link href="http://www.chenbaocheng.com/2015/01/23/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IntelliJ-IDEA-14-For-Mac-OS-10-10/"/>
    <id>http://www.chenbaocheng.com/2015/01/23/Go语言学习-配置开发环境-IntelliJ-IDEA-14-For-Mac-OS-10-10/</id>
    <published>2015-01-23T05:11:31.000Z</published>
    <updated>2015-02-22T17:37:36.000Z</updated>
    <content type="html"><![CDATA[<p><strong>1、安装 Go-Lang</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew install go</div><div class="line">$ go version</div></pre></td></tr></table></figure>

<p><br><strong>2、配置环境变量</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ vim ~/.zshrc</div><div class="line"><span class="keyword">export</span> GOROOT=/usr/local/opt/go/libexec</div><div class="line"><span class="keyword">export</span> GOPATH=<span class="variable">$HOME</span>/.go</div></pre></td></tr></table></figure>

<p><br><strong>3、Intellij IDEA 安装 go-lang-idea-plugin</strong></p>
<ul>
<li>IntelliJ IDEA -&gt; Preferences -&gt; Plugins -&gt; Browse Repositories</li>
<li>搜索golang，点击 “Install plugin”</li>
<li>安装完重启</li>
</ul>
<p><strong>go-lang-idea-plugin会提示配置GOROOT,GOPATH。。。搜了各种资料，需要这样配置一下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim .zshrc</div><div class="line">launchctl setenv GOROOT /usr/local/opt/go/libexec</div><div class="line">launchctl setenv GOBIN /usr/local/opt/go/libexec/bin</div><div class="line">launchctl setenv GOPATH /ROOT/www/go</div></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、安装 Go-Lang</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="li]]>
    </summary>
    
      <category term="golang" scheme="http://www.chenbaocheng.com/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Hexo写博客 --- Hexo的配置与使用]]></title>
    <link href="http://www.chenbaocheng.com/2015/01/09/%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%20---%20Hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.chenbaocheng.com/2015/01/09/用Hexo写博客 --- Hexo的配置与使用/</id>
    <published>2015-01-09T07:20:45.000Z</published>
    <updated>2015-02-22T18:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>本站由 SourceForge 迁移到 GitHub.</p>
<p>之前是在 SourceForge 提供的空间搭了一个 Wordpress, 访问很慢。</p>
<pre><code>Hexo is <span class="operator">a</span> fast, simple &amp; powerful blog framework powered <span class="keyword">by</span> Node.js.
</code></pre><p><br>Hexo 基于 Node.js 开发的一个轻量级的 Blog 框架，使用自然没有 Wordpress 那么方便，好在也是生成 HTML，访问会快些。</p>
<p><strong>搭建本站过程看的一些资料整理一下，逐步操作如下：</strong><br><a id="more"></a><br>1、Mac OS x 默认自带 git，无需重复安装</p>
<p>2、安装 Node.js </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure>

<p><em><br>进入本地存放博客的目录继续操作……</em></p>
<p>3、安装、初始化 Hexo</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#install hexo</span></div><div class="line">npm install -g hexo</div><div class="line"> </div><div class="line"><span class="comment">#init hexo</span></div><div class="line">hexo init ./</div><div class="line">npm install</div></pre></td></tr></table></figure>

<p><br>4、预览网站</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure><br>通过以上操作，一个基于 Hexo 搭建的网站就初步完成了，通过浏览器访问一下劳(piao)动(qie)成果：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br><br><strong>Hexo 的常用操作</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#初始化</span></div><div class="line">hexo init [folder]</div><div class="line"> </div><div class="line"><span class="comment">#新发一片page|post</span></div><div class="line">hexo new [layout] &lt;title&gt;</div><div class="line"> </div><div class="line"><span class="comment">#生成静态文件</span></div><div class="line">hexo generate</div><div class="line"> </div><div class="line"><span class="comment">#清理缓存 --- db.json、public/</span></div><div class="line">hexo clean</div><div class="line"> </div><div class="line"><span class="comment">#启动本地服务，默认端口4000</span></div><div class="line">hexo server</div><div class="line"> </div><div class="line"><span class="comment">#将public/下的文件部署到配置文件制定的服务器</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure><br>详细查看官方文档:<a href="http://hexo.io/docs/commands.html" target="_blank" rel="external">http://hexo.io/docs/commands.html</a><br><br>现在网站已经搭起来了，开始写点什么~<br><br>Hexo 里写文章是用Markdown，如果之前没有用过，建议看看这篇文章 : <a href="http://wowubuntu.com/markdown" target="_blank" rel="external">http://wowubuntu.com/markdown</a><br><br>现在已经了解 Markdown 是什么，那我们继续，<strong>开始用 Hexo 写文章</strong><br><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"Hello world !"</span></div><div class="line"><span class="comment">#会提示你输入dquote，请输入双引号 — ”</span></div><div class="line"><span class="comment">#如果你的文件名里没有特殊字符就不要加双引号了~~~</span></div></pre></td></tr></table></figure>

<p><br>用你喜欢的编辑用户打开 source/_posts/Hello-world.md，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: 标题</div><div class="line">date: 2015-01-09 17:42:00</div><div class="line">categories:</div><div class="line">tags:</div><div class="line">---</div><div class="line">文章正文，啦啦啦啦~</div></pre></td></tr></table></figure>

<p><br>更多编辑文章技能看官方文档：<a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">http://hexo.io/docs/writing.html</a></p>
<p>刷新浏览器，文章列表是不是发生变化了！</p>
<p><strong>如果需要发布到服务器</strong>，需要先生成一下静态文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line"><span class="comment">#hexo generate的简写</span></div></pre></td></tr></table></figure>

<p><br>生成的静态文件地址跟类型相关：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">生成目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post (Default)</td>
<td style="text-align:center">source/_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
</tbody>
</table>
<p><br>OK, 现在网站已经有，是不是迫不及待想发布到服务器让大家来访问了？！</p>
<p>首先，你得有一个 github.com 的账号，如果没有请先<a href="https://github.com/join" target="_blank" rel="external">去注册</a></p>
<p>1、新建一个your_user_name.github.com的仓库<br>2、添加SSH公钥.Account settings &gt; SSH Keys &gt; Add SSH Key<br>3、修改本地博客根目录下的 _config.yml，</p>
<pre><code>deploy:
      <span class="class"><span class="keyword">type</span>: <span class="title">github</span></span>
      repo: https:<span class="comment">//github.com/your_user_name/your_user_name.github.io.git</span>
</code></pre><p><br>4、执行 hexo d</p>
<p>如果想绑定域名，在仓库里新建一个CNAME,文件内容为你的域名，比如chenbaocheng.com,前面不要加http://</p>
<p>修改域名 DNS 信息：</p>
<p>1、增加CNAME记录：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">your_user_name.github.io</td>
</tr>
</tbody>
</table>
<p><br>2、增加 A 记录</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">192.30.252.153</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">192.30.252.154</td>
</tr>
</tbody>
</table>
<p><br>域名绑定参考官方文档：<a href="https://help.github.com/articles/my-custom-domain-isn-t-working/" target="_blank" rel="external">https://help.github.com/articles/my-custom-domain-isn-t-working/</a></p>
<p>—全文完—</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本站由 SourceForge 迁移到 GitHub.</p>
<p>之前是在 SourceForge 提供的空间搭了一个 Wordpress, 访问很慢。</p>
<pre><code>Hexo is <span class="operator">a</span> fast, simple &amp; powerful blog framework powered <span class="keyword">by</span> Node.js.
</code></pre><p><br>Hexo 基于 Node.js 开发的一个轻量级的 Blog 框架，使用自然没有 Wordpress 那么方便，好在也是生成 HTML，访问会快些。</p>
<p><strong>搭建本站过程看的一些资料整理一下，逐步操作如下：</strong><br>]]>
    
    </summary>
    
  </entry>
  
</feed>
